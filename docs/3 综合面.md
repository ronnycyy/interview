# 目录
* 框架 (主React, 副Vue)
* 设计模式 (观察者模式、策略模式等)
* 工程化 (Webpack, Git)
* 性能优化
* 服务端 (Node.js)

============================================== f设计模式 ==============================================
# 平时工作中有用到哪些设计模式？
TODO: 
1.单例模式 继哥写的基础库？ redux的store
2.观察者模式 redux的subscribe和dispatch (如果面试官要求举出更多例子，再讲 Vue的Watcher订阅和Data发布)

# f单例模式
单例模式即一个类只能构造出唯一的实例，单例模式的意义在于共享、唯一。
## 例子
Redux 的 store。 (如果面试官要求举出更多例子，再讲 Vuex的store, JQ的$, 业务场景的购物车🛒等)
## 代码
```js
class Singleton {
  constructor(name) {
    this.name = name;
  }
  static getInstance(name) {
    if (!this.instance) {
      this.instance = new Singleton(name);
    }
    return this.instance;
  }
}
const instance1 = Singleton.getInstance('name1');
const instance2 = Singleton.getInstance('name2');
console.log(instance1 === instance2);  // true，只有一个实例
console.log(instance1.name);  // name1
console.log(instance2.name);  // 依然是 name1
```

# 工厂模式
工厂模式即对创建对象逻辑的封装，或者可以简单理解为对new的封装，这种封装就像创建对象的工厂，故名工厂模式。
## 例子
工厂模式常见于大型项目，比如JQ的$对象，我们创建选择器对象时之所以没有new selector就是因为$()已经是一个工厂方法，其他例子例如React.createElement()、Vue.component()都是工厂模式的实现。
## 代码
```js
class User {
  constructor(name, auth) {
    this.name = name;
    this.auth = auth;
  }
}
class UserFactory {
  static createUser(name, auth) {
    // 工厂内部封装了创建对象的逻辑。
    // 使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和一个普通用户。
    if (auth === 'admin') {
      return new User(name, 1);
    }
    if (auth === 'user') {
      return new User(name, 2);
    }
  }
}
const admin = UserFactory.createUser('boss', 'admin');
const user = UserFactory.createUser('mike', 'user');
```

# 观察者模式
观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。
## 例子
Redux的subscribe和dispatch。
## 代码
```js
// 观察者
class Observer {
  constructor(fn) {
    this.update = fn;
  }
}
// 被观察者
class Subject {
  constructor() {
    this.observers = [];
  }
  register(ob) {
    this.observers.push(ob);
  }
  notify() {
    this.observers.forEach((ob) => {
      ob.update();
    })
  }
}
const ob1 = new Observer(() => console.log('ob1 update!'));
const ob2 = new Observer(() => console.log('ob2 update!'));
const ob3 = new Observer(() => console.log('ob3 update!'));
const subject = new Subject();
subject.register(ob1);
subject.register(ob2);
subject.register(ob3);
subject.notify();
```

# f装饰器模式
装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7的装饰器语法以及React中的高阶组件（HOC）都是这一模式的实现。
## 代码
```js
// ES7的装饰器
function Info(target) {
  target.prototype.name = 'mike';
}

@Info
class Man {}

const man = new Man();
console.log(man.name);  // info
```

# f适配器模式
适配器模式，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题。
## 代码
```js
class Adaptee {
  test() {
      return '旧接口';
  }
}
class Target {
  constructor() {
      this.adaptee = new Adaptee()
  }
  test() {
      const info = this.adaptee.test()
      return `适配${info}`;
  }
}
const target = new Target()
console.log(target.test());
```

# f代理模式
代理模式，为一个对象找一个替代对象，以便对原对象进行访问。即在访问者与目标对象之间加一层代理，通过代理做授权和控制。
## 例子
最常见的例子是经纪人代理明星业务，假设你作为一个投资者，想联系明星打广告，那么你就需要先经过代理经纪人，经纪人对你的资质进行考察，并通知你明星排期，替明星本人过滤不必要的信息。事件代理、JQuery的$.proxy、ES6的proxy都是这一模式的实现。
## 代码
```js
const idol = {
  name: 'mike',
  phone: 10086,
  price: 1000000
}
const agent = new Proxy(idol, {
  get: function(target) {
    //拦截明星电话的请求,只提供经纪人电话
    return '经纪人电话:10010'
  },
  set: function(target, key, value) {
    if(key === 'price' ) {
      //经纪人过滤资质
      if(value < target.price) throw new Error('报价过低')
      target.price = value
    }
  }
})
agent.phone        //经纪人电话:10010
agent.price = 100  //Uncaught Error: 报价过低
```


============================================== f工程化 ================================================
# fGit
Git是一个免费的、开源的分布式版本控制系统，旨在以快速高效的方式处理从小型到大型的所有项目。
Git易于学习、占用空间小、性能极快。它具有方便的工作区、暂存区、本地库和多个工作流分支等特性。

## 架构
远程库
⬆️git push(推送给远程), ⬇️git pull(拉取更新), ⬇️git clone(初始化到本地), ⬇️git remote add <远程别名>（如 origin） <远程链接>(本地已经有项目，添加一个远程库)
本地库
⬆️git commit(提交，生成一个历史版本), ⬇️git branch <分支名>(增加分支), ⬇️git checkout (切换分支), ⬇️git log/git reflog(查看提交日志)
暂存区
⬆️git add(添加到暂存区), ⬇️git restore --stage <file>(取消添加)
工作区   

## 本地库结构
-------- commit1 ----------- commit2 -------- commit3  ---------------- commit 4 -----------------------   分支一
            |                                                                      | 合并给分支一
            -------- commit1 --------------------------------   分支二              |
                              |                                                    | 分支三可以继续走，无影响
                              ------- commit 1 ------------------------------------|-------- 分支三 

### 分支
多个分支是本地库中的多个工作流，每个分支独立管理自己的提交历史。

当前所在的分支，是由 HEAD 决定的。
master,hot-fix 这两个分支其实是两个指针，HEAD 指向谁，谁就是当前分支，切换分支的本质就是改变 HEAD 指向。

#### 例子
两个分支，每个分支有独立的提交历史:
first ---- second  ---- third --- fourth ----- fifth  [master]   
                          |
                        third --------- fourth        [hot-fix]   <= HEAD (当前分支是 hot-fix)
 
#### 优点
同时并行推进多个功能开发，提高开发效率。
各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支造成影响。失败的分支删除了，重新开始即可。

git branch <分支名>: 增加分支
git branch: 查看本地库的分支，以及当前处在哪个分支上
git checkout <分支名>: 切换分支  (改变HEAD指向)
git reflog: 查看所有分支的提交历史

#### 合并冲突的分支
在当前分支下，合并其他分支的修改。(注意合并只会影响当前分支的内容，对其他分支毫无影响)

##### 背景
合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改，Git无法帮我们作出决定，这时就有冲突。
冲突发生时，需要人为决定新代码的内容。

#### 步骤
1. 执行合并
git merge <其他分支>

```shell
Auto-merging test.md  // 正在自动合并 test.md...
CONFLICT (content): Merge conflict in test.md   // test.md 里有合并冲突
Automatic merge failed; fix conflicts and then commit the result.   // 自动合并失败
```

2. vim test.md 查看冲突文件
<<<HEAD
<当前分支的代码>
======
<要合并进来的分支的代码>
>>>>> hot-fix

3. 手动修改
修改`<<<HEAD`和`======`中间的内容，留下你要的部分，然后把分割线删掉。

4. 保存
wq, git add, git commit, 完成以后，`其他分支`的修改就合并到`本分支`了。


## 分支内版本穿梭 (回到某一个提交历史)  f版本穿梭
回到某一个提交历史，作出修改后，再提交到最新修改的后面。 实现回到过去，逆转现在!

first ---- second  ---- third --- fourth ----- fifth                当前在 fifth 提交
                                              [master]

first ---- second  ---- third --- fourth ----- fifth                回到 third 提交
                      [master]       

first ---- second  ---- third --- fourth ----- fifth ---- sixth     基于 third 修改，提交 sixth
                                                        [master]                
### 命令
git reset --hard [commitCode]


## git frebase vs git fmerge
git rebase:  找到当前分支和目标分支的交叉点，交叉点到当前分支尾的部分拆出来，合到目标分支的末尾，也就是合成一条 commit 线。
git merge: 新建一个 commit 结点，两个分支末尾都指向这个新的 commit 结点。

 

# fRedux fredux
Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 

Redux 可以用这三个基本原则来描述:
1. 单一数据源
整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。
这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，你可以把应用的 state 保存在本地，从而加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。

2. State 是只读的
唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。
这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。

3. 使用纯函数来执行修改
为了描述 action 如何改变 state tree ，你需要编写 reducers。
Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分，因为 reducer 只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的 reducer 来处理一些通用任务，如分页器。

## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/redux

### fcreateStore.js
观察者模式: 订阅、取消订阅、发布。
```js
export default function createStore(reducer, initState, rewriteCreateStoreFunction) {
  if (rewriteCreateStoreFunction) {
    const newCreateStore = rewriteCreateStoreFunction(createStore);
    return newCreateStore(reducer, initState);
  }

  let state = initState;
  let listeners = [];

  function subscribe(listener) {
    // 订阅
    listeners.push(listener);
    // 取消订阅
    return function unsubscribe(listener) {
      const index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    }
  }

  function getState() {
    return state;
  }

  function dispatch(action) {
    // 通知用户定义的 reducer 得到新的状态
    state = reducer(state, action);
    // 发布 
    // 无论哪个小状态变化，都将全量通知
    for (let i = 0, len = listeners.length; i < len; i++) {
      const listener = listeners[i];
      listener();
    }
  }

  // 执行所有的 reducer，使得 `以reducer为key的每个store`，在总状态里初始化。
  // 使用 symbol 避免和用户的 action.type 重名
  dispatch({ type: Symbol('__init_store__') });
  /**
   * 实现一个 Symbol?
   * 
   * function MySymbol(name) {
   *    const obj = Object.create({
   *      toString: function() {
   *         return name;
   *      }
   *    })
   *    return obj;
   * }
   */

  function replaceReducer(nextReducer) {
    reducer = nextReducer;
    dispatch({ type: Symbol('__init_store__') });
  }

  return {
    subscribe,
    getState,
    dispatch,
    replaceReducer,
  }
}
```




### fcombineReducer.js
组合用户所有的 reducer，每个 reducer 维护自己的那份 state (totalState[key])，但是每次更新都会创建一个全体的新的 state 返回。
如果确实没有变更，(非常少见，比如发了一个所有 reducer 都不受理的 action)，才会返回之前的 state 引用。
```js
export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);

  // 最后合并好的 reducer
  return function combine(state = {}, action) {
    // 所有的 action, 都是执行这个 combine 函数，改变自己的 state (state[key])，返回整体的 state 中，最后改变整体的 state (引用)。
    const nextState = {}
    // 遍历所有 reducer
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      const reducer = reducers[key];  // counterReducer, infoReducer
      // 某个 reducer 的旧库
      const prevStateForKey = state[key];
      // 执行动作，状态改变，得到该 reducer 的新库
      const nextStateForKey = reducer(prevStateForKey, action);
      // reducer的key和state的key要保持一致
      // 该 reducer 的保存到一份新的总状态里
      nextState[key] = nextStateForKey;
    }
    return nextState;
  }
}
```


### fapplyMiddleware.js  f中间件原理 (中间件们把store.dipatch作为`🧅的最内核`包裹起来)
redux的中间件原理是:
1. 先把 store 传入每一个中间件，它们都返回一个函数，这个函数接受一个next函数，返回另一个函数，如 `(next) => (action) => {...}`
2. 把这些函数通过 compose 组合起来，得到一个总体的函数，也是接受一个next函数，返回另一个函数: `(next) => ex(time(log(next)))`
3. 把 `store.dispatch` 作为 `next` 参数，传给这个函数，执行，最终返回一个符合洋葱模型🧅的函数，洋葱模型最内层就是原始的 store.dispatch:
`(action) => { ex1(next前),  time1,log1,store.dispatch,log2,time2 (next),  ex2(next后)  }`

如果传入的顺序是 applyMiddleware(左1,左2,左3),  那么最终的执行顺序是 左1,左2,左3,store.disptach,左3,左2,左1。

```js
// dispatch 的时候，依次执行所有的 middleware。
const applyMiddleware = function (...middlewares) {

  // 返回这个函数，给 createStore.js 里的 rewriteCreateStoreFunction 调用，再返回一个新的 createStore 函数
  return function (oldCreateStore) {

    // 这个玩意儿是新的 createStore 函数，把中间件嵌入到 dispatch 流程中。
    return function (reducer, initState) {
      const store = oldCreateStore(reducer, initState);
      const simpleStore = { getState: store.getState };

      // 中间件先依次执行一遍，转成 (next) => xxx, 结果放到链中，形成数组
      // 每一个 middleware 变成一个 m(simpleStore) 的执行结果 ----> 一个函数: (next) => (action) => {...}
      // [
      //  (next) => (action) => {...log...}, 
      //  (next) => (action) => {...exception...},
      //  ...
      // ]
      const chain = middlewares.map(m => m(simpleStore));
      // 现在中间件已经变成了 (next) => (action) => xxx 这个鬼样子,
      // 然后 compose 从右到左把中间件组合起来:
      // ex, time, log 三个转成 (next) => .. 的中间件，变成 (...args) => ex(time(log(...args))) 

      // 传入 store.dispatch 执行，返回 ex(time(log(store.dispatch))) 的执行结果, 执行过程是:

      // 1. log 中间件 ”(next) => (action) => xxx“ 执行，返回一个函数，作为 next 给 time 中间件
      // ex(time(   (action) => {..log1..., store.dispatch, ..log2...}       ))

      // 2. time 中间件执行，返回一个函数，作为 next 给 exception 中间件
      // ex(   (action) => {..time..}   )

      // 3. 最后返回一个函数，给 dispatch
      // (action) => { 错误处理(next之前)...,  time中间件执行传过来的函数(action) => {...} (next),  xxx(next之后)  }

      // 所以，在 dispatch 的时候，中间件根据传入 applyMiddleware 的顺序，从左往右，按洋葱模型🧅执行。(左1,左2,左3,store.disptach,左3,左2,左1)
      const dispatch = compose(...chain)(store.dispatch);

      console.log('dispatch', dispatch);

      return {
        ...store,
        dispatch
      }
    }
  }
}
export default applyMiddleware;
```

### fbindActionCreators.js
把所有创建 action 的函数集中到一个对象上，使用时可以直接调用。
比如 const actions = bindActionCreators({ Add, setName }, store.dispatch);  
使用时 actions.Add(); 相当于 store.dispatch({ type: 'ADD' });
```js
/**
 * @param {Function} actionCreator 用户定义的 action 函数，比如 setName 函数。
 * @param {Function} dispatch store.dispatch
 */
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(null, arguments));
  }
}
export default function bindActionCreators(actionCreators, dispatch) {
  const b = {};
  // 把所有创建 action 的函数集中到一个对象上，使用时可以直接调用。
  // for..in  遍历所有可枚举属性，它会把原型上的属性也找出来，只不过 Object.prototype 上的属性是不可枚举的，所以没出来。
  for (const key in actionCreators) {
    const action = actionCreators[key];
    if (typeof action === 'function') {
      b[key] = bindActionCreator(action, dispatch);
    }
  }
  return b;
}
```

## fcompose.js
从右往左组合函数，比如 compose(f, g, h) 返回一个函数: (...args) => f(g(h(...args)))
```js
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg
  }
  if (funcs.length === 1) {
    return funcs[0]
  }
  // a 相当于之前所有组合好的函数, b 是本次要组合的函数, 
  // 比如: (f(g(...args)), h) => (...args) => f(g(h(...args)))
  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

# fRedux-Toolkit fredux-toolkit fToolkit
redux 官方推荐的工具集，比 redux 更加轻量。最佳实践。

# react-redux
`react-redux`是将`Redux store`和`React UI`相结合的`官方绑定层`。
它使 react 组件可以从 redux store 读取数据，也可以向 store 发起 action 以更新状态。
基于 context API 封装。
## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/react-redux (【手写源码系列】40分钟带你从0到1实现一个react-redux)


# fRecoil frecoil f原子化
Recoil 是 React 的状态管理库，只能用在 React 里边。
## 目标
redux太复杂, 得创建 store, reducer, action, ..., 和 react 合起来还得创建 react-redux。项目复杂时，会有多层 Provider 树🌲.
因此，Recoil的目标是: 最小化state，不要有包装，不要多层次的Provider。
## 核心
原子状态变化(text) -> 衍生状态变化(text.length) -> 视图更新。
## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/recoil  (前端中的数据结构和算法2)

# fvuex
大垃圾 只有一个文件 也是基于 redux。


# f状态优化
https://github.com/ronnycyy/state-manager/tree/main/react
两点原则:
1. 将变的和不变的分离。
2. 将`引用比较`改为`浅比较`。

## 将变的与不变的分离
适用于: 父组件的state可分离给子组件。
将state变化的子组件从父组件中抽离出来, 使子组件单独渲染，而不影响父/兄弟组件。
```js
function App() {
  console.log('App render~');
  return (
    <div>
      <h1>将变的部分和不变的部分分离</h1>
      {/* 抽离了变的部分，现在只是 Input 组件重新渲染 Expensive 不会 render 了 */}
      <Input />
      {/* beginWork 中取得 newProps 和 oldProps，判断是相等的 */}
      <Expensive />
    </div>
  );
}
function Input() {
  console.log('Input render~');
  const [text, setText] = useState('');
  // 协调阶段:  App -> div -> h1 -> Input(执行) -> Expensive (深度优先遍历)
  // 前面都对比对比, 没变化没变化,  bailout bailout..., 直到 Input, 发现前后 state 不一致，于是执行。 
  // App 被 bailout 了，不会执行的!  "App render~" 不会打印。
  return (
    <Fragment>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
    </Fragment>
  )
}
// 这个组件每次渲染都要花费至少100ms
function Expensive() {
  console.log('Expensive render~');
  let now = performance.now();
  while (performance.now() - now < 100) { }
  console.log('耗时的组件render');
  return <p>耗时的组件</p>
}
```
## 将`引用比较`改为`浅比较`
适用于: 父组件的state不可分离。
父组件state变化，导致本来不用变化的子组件也跟着重新渲染，为了避免这种情况，应在父组件外部使用 React.memo 包裹子组件，再引入到父组件。
```js
// 在父组件外层包裹，这样 Input 执行时就不会影响。
const MemoUnderInput = React.memo(UnderInput);
function Input() {
  console.log('Input render~');
  const [text, setText] = useState('');
  return (
    <Fragment>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
      {/* <UnderInput /> */}
      {/*
        React.memo 默认情况下会对复杂 props 对象做浅比较。(比如 shallowEqual({},{}) === true, 这两个空对象如果用引用比较结果是false)
        所以不是引用比较了，那么就不会受 Input 影响重新执行，而是不执行。
      */}
      <MemoUnderInput />
    </Fragment>
  )
}
```

# 前端状态管理库的对比
Redux `时间旅行`的理念非常经典，由这个理念发展出了很多状态管理库。
应该怎么选择 React 状态管理库？从两个角度说:
1. 项目规模
2. 项目类型

## 项目规模
1. 很小的项目，玩具项目，没必要用库了，直接 context API 就行。
2. 大一丢丢的项目，但还是一个人写的，比如短期的活动页，可以用一些迷你的库，比如 unstated(基于context封装)
3. 再大一点，需要几个小伙伴合作的，就可以用 dva, mobx, jotai, recoil 等基于`原子状态`理念的。

## 项目类型
1. 普通的后台管理页，要填很多表单 => 双向数据绑定 => 适合用 mobx。
2. 富文本编辑器，我需要完成 `撤销/重做` 这样的功能，那就适合用 redux 系列的`时间旅行`的库。


==============================fReact==============================
# fScheduler
Scheduler 是一个在浏览器环境中实现`调度功能`的包，当前用于 react 内部，但是 react 团队计划将它作为一个独立的包。
*功能*
1. 时间切片
2. 优先级调度
## f时间切片
*TODO*
0. 讲概念、说用途、优缺点
1. React 为什么选择 MessageChannel ?
2. 时间切片是怎么实现的？
*参考*
1. React18 首屏渲染并没有开启 concurrent 模式，如何开启，以调试？
2. SchedulerPostTask 里才是卡颂说的 unstable_shouldYield。
## f优先级调度
*TODO*
0. 讲概念、说用途、优缺点
1. 
*参考*
1. ～/scheduler/src/forks/Scheduler.js 暴露的 unstable_runWithPriority。
*注意*
Scheduler 是独立于 React 的包，所以它的优先级也是独立于 React 的优先级的。

# flane
lane 是 React 内部的优先级模型，和 Scheduler 的优先级模型是分隔开的。源码位于 ~/react-reconciler/src/ReactFiberLane.js
*对lane的要求*
1. 能够表示不同的优先级
2. 可能存在多个相同优先级的更新，所以要能表示`批`的概念
3. 方便进行优先级的运算
*表示不同优先级*
lane 模型借鉴了卡丁车比赛的原理，赛场上有多个赛道，React 用 31 个不同的二进制位，来表示不同的赛道，不同赛道就表示不同的优先级。
比如 SyncLane 占领第 1 位，是比较高的优先级，越往下的位，优先级越低。
*表达 批 的概念*
除了 Lane 类型的变量，React 还定义了 Lanes 类型的变量，它们会占领多个连续的二进制位，表示这些优先级在同一个批次里。
*方便计算*
lane 优先级的计算，其实就是二进制位的计算，比如`按位与`、`按位或`等。位运算是非常快速的。
## f饥饿问题
低优先级任务始终被高优先级任务打断，没有机会被执行，这种问题就是饥饿问题。


# fbatchedUpdates
一次回调中触发多次 setState，将这多次更新合并为一次更新的优化手段，就叫 batchedUpdates。
## legacy模式
*版本*
适用于 React18 以前，使用 `ReactDOM.render(<App />, root)` 渲染的应用。
*源码*
源码位于 ~/react-reconciler/src/ReactFiberWorkLoop.js 的 batchedUpdates 方法:
1. 接收一个函数 fn, fn 通常是组件的 onClick 等事件回调，其中包含多个 setState 方法。
2. fn 执行之前，将它的上下文`或上`一个 BatchedContext，fn 执行完成后，再恢复成之前的上下文。
3. fn 执行时，其中的 setState 会获取到 executionContext, 这时就会得到 BatchedContext，那么就不会立马触发更新，而是在 batchedUpdate 的 finally 里，执行 flushSyncCallbackQueue 里触发更新。
*缺点*
1. 整个过程同步执行，如果将 setState 作为异步调用，那么执行 setState 时已经离开了 batchedUpdates 的上下文，也就获取不到 BatchedContext 了。
## concurrent模式
*版本*
React18, 通过 `ReactDOM.createRoot(root).render(<App />)` 开启，注意 `import ReactDOM from 'react-dom/client';`。
*源码*
this.setState 的源码位于: ~/react-reconciler/src/ReactFiberClassComponent.js 的 classComponentUpdate.enqueueSetState 方法, 通过类实例 instance.updater.enqueueSetState 来调用。
*原理*
1. 第一个 setState 进来，获取 lane, 转化成 Scheduler 的优先级，通过 Scheduler 暴露的 scheduleCallback 调度 performConcurrentWorkOnRoot，同时整个React应用的根结点 FiberRootNode 记录这个被调度的任务和它的优先级。
2. 第二个 setState 进来, 得到一样的 lane, 然后到 ensureRootIsSchedule 时，获取到的 root.callbackNode 是上一个 setState 调度的任务，不为空。既然不为空，那么表示 React应用 有任务正在调度，于是取出这个任务的优先级 root.callbackPriority 和此刻想要调度任务的优先级对比，发现一致(因为 lane 一致)，那么第二次更新就不会被调度，而是直接 return 了，也就是复用了正在调度的任务。
3. 关键就在于，同一个 onClick 里的所有 setState，得到的 lane 都是一致的，从而产生的优先级一致，就可以复用任务。


# f高优更新如何插队 高优更新如何打断低优更新
*DEMO*
两次更新，一次是 NormalPriority 的更新，一次是 1ms 后 UserBlockingPriority 的更新，后面的更新优先级高，会打断前面的更新。
```jsx
setTimeout(() => updateCount(1), 1000);
setTimeout(() => button.click(), 1001);
```
*原理*
React18，useState 的 dispatch，从 dispatchSetState 开始。
1. 调度低优更新 (NormalPriority, 如 useState 返回的 dispatch)
requestUpdateLane获取lane -> 使用lane创建update对象 -> scheduleUpdateOnFiber在当前fiber上调度lane更新 -> ensureRootIsScheduled调度整个应用的根结点 -> lane 转 Schedule Priority -> 调度一次 NormalPriority 的 performConcurrentWorkOnRoot
2. 高优更新 (UserBlockingPriority, 如 onClick 触发的更新)
**2.1 打断低优更新，调度高优更新**
前面都一样，直到 ensureRootIsScheduled，得到的 新任务优先级(newCallbackPriority) 高于 已存在的任务优先级(existingCallbackPriority)，所以取消正在调度中的低优任务，调度本次更高优先级的任务。
```js
// 打断低优任务
if (existingCallbackNode != null) { cancelCallback$1(existingCallbackNode); }
...
// 调度高优任务
scheduleCallback(更高的优先级, render任务);
```
**2.2 清除低优更新产生的影响**
[源码位于 ~/react-reconciler/src/ReactFiberWorkLoop.js: prepareFreshStack]
高优先级任务到达执行时间，开始调用render任务(performConcurrentWorkOnRoot), 在 render 阶段前，先执行 prepareFreshStack，将 workInProgress 重置为 rootFiber，清空上一次更新产生的 fiber 树，重新开始协调。


# fsuspense
React 要实现快速响应，需要解决 2 个问题，一个是 CPU 的瓶颈，一个是 IO 的瓶颈。CPU 瓶颈的解决方案是`时间切片`，而 IO 瓶颈的解决方案就是 Suspense。
*原理*
Suspense 组件进入协调阶段，执行 updateSuspenseComponent，返回一个`离屏Fiber结点`作为子结点。这个离屏 fiber 的 pendingProps 里有一个 childern 属性代表 Suspense 子组件的集合，还有一个 mode 属性代表子组件当前是否可见。如果可见就渲染真实的子组件，如果不可见就渲染 Suspense 的 fallback 属性里定义的组件。
*离屏组件*
fiber.elementType = Symbol(react.offscreen);
*组件树*
Suspense组件 -> OffscreenFiber -> Suspense包裹的子组件
*结束fallback*
1. thrownValue: 这里可以捕获到 Suspense 内部子组件当成错误抛出的 Promise 对象。
2. root: FiberRootNode
renderRootConcurrent 方法中:
```js
do {
  try {
    workLoopConcurrent();
    break;
  } catch (thrownValue) {
    handleError(root, thrownValue);
  }
} while (true);
```
renderRootConcurrent -> 捕获到 Promise 对象 -> handleError -> throwException -> 判断是一个 thenable 对象 -> 找到上面最近的 Suspense 组件 -> 渲染 fallback 组件 -> attachPingListener监听抛出的Promise -> Promise.then -> 执行 pingSuspendedRoot -> ensureRootIsScheduled -> 更新 React 应用，渲染 Suspense 的子组件。


🔥通读一遍 React 官网文档
# f代码分割 fReact代码分割
*讲概念*
代码分割是由如 Webpack，Rollup 这类打包器支持的一项技术，能够创建多个包并在运行时动态加载。
*说用途*
对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。
*列用法*
## 使用import()语法  fimport()
- 当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。对于这一要求你需要 babel-plugin-syntax-dynamic-import 插件。
- 当 Webpack 解析到该语法时，会自动进行代码分割。如果你使用 Create React App，该功能已开箱即用，你可以立刻使用该特性。
**组件**
```jsx
import("./math")
  .then(math => {
    console.log(math.add(16, 26));
  });
```
**webpack配置**
```js
module.exports = {
  entry: {
    main: './src/app.js',
  },
  output: {
    // 命名 bundle
    filename: '[name].bundle.js',
    // 为异步加载的 chunk 命名
    chunkFilename: '[name].bundle.js',
    // bundle 的输出路径
    path: './dist',
  }
};
```
## 2. React.lazy flazy f懒加载
*讲概念*
React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。
*列用法*
1. React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。
2. 在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。
```jsx
import React, { Suspense } from 'react';
const OtherComponent = React.lazy(() => import('./OtherComponent'));
function LazyDemo() {
  const [showLazy, setShowLazy] = React.useState(false);
  const load = () => { setShowLazy(true) }
  return (
    <div>
      <button onClick={load}>点击按钮加载组件</button>
      {
        showLazy ? (
          <Suspense fallback={<h1>正在加载...</h1>}>
            <OtherComponent />
          </Suspense>
        ) : <h1>未加载组件</h1>
      }
    </div>
  );
}
```
3. 基于路由的代码分割
```jsx
import React, { Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
const Home = React.lazy(() => import('./routes/Home'));
const About = React.lazy(() => import('./routes/About'));
const ReactRouterDemo = () => (
  <Router>
    <Suspense fallback={<div>loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
)
```

# fContext
*讲概念*
Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或当前选中的语言。
Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。
*说用途*
在一个典型的 React 应用中，数据是通过 props 属性由父到子进行传递的，但此种用法对于某些类型的属性而言是极其繁琐的，比如当前用户、应用语言、UI主题，这种属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。
*优缺点*
**缺点**
1. Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。
*举例子*
React.createContext 创建 Context 对象，Class.contextType 接收 Context 对象，this.context 读取 Context 对象的值。
```jsx
const ThemeContext = React.createContext('light');
class App extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}
// 中间的组件再也不必指明往下传递 theme 了。
function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}
// 在需要使用 Context 的组件中，指定 contextType 读取当前的 theme context。
// React 会往上找到最近的 theme Provider，然后使用它的值。
class ThemedButton extends React.Component {
  static contextType = ThemeContext;   // 跨组件接收数据
  render() {
    return <Button theme={this.context} />;  // 找到 ThemeContext.Provider value="dark"
  }
}
```
*API*
*** fcreateContext React.createContext ***
```jsx
const ThemeContext = React.createContext('light');
```
1. React.createContext 接收一个 defaultValue，返回一个 Context 对象。
2. 当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。
3. 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。

*** fProvider fContext.Provider ***
```jsx
<ThemeContext.Provider value={/* 某个值 */}>
```
1. 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。
2. Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。
3. 多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。
4. 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。比如 使用了contextType的类组件 和 使用了useContext的函数组件。
5. 通过新旧值检测来确定变化，使用了`Object.is`算法。

*** fClass.contextType ***
挂载在 class 上的 contextType 属性可以赋值为由 React.createContext() 创建的 Context 对象。
此属性可以让你使用 this.context 来获取最近 Context 上的值。你可以在任何生命周期中访问到它，包括 render 函数中。
```jsx
class MyClass extends React.Component {
  static contextType = MyContext;
  render() {
    const value = this.context;  // MyContext.Provider 的 value 值
  }
}
```

*** fConsumer fContext.Consumer ***
Context.Consuer 是一个 React 组件，它可以订阅 context 的变更。
```jsx
<MyContext.Consumer>
  {value => /* 基于 context 值进行渲染*/}
</MyContext.Consumer>
```
它需要一个函数作为子元素。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。

*** fdispalayName fConext.dispalyName ***
context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。
```jsx
const MyContext = React.createContext(/* some value */);
MyContext.displayName = 'MyDisplayName';
/* "MyDisplayName.Provider" 在 DevTools 中 */
/* "MyDisplayName.Consumer" 在 DevTools 中 */
<MyContext.Provider> 
<MyContext.Consumer> 
```


# fRefs转发 fRef
*讲概念*
Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递给子组件。
*说用途*
1. 转发 refs 到 DOM 组件
2. 在高阶组件中转发 refs
*** 转发 refs 到 DOM 组件 ***
1. 通过 React.createRef 创建一个 ref 对象。
2. 通过 ref 属性传递给 React.forwardRef 返回的组件，React 内部将 ref 传递给 forwardRef 接收的函数的第 2 个参数。
3. 在 forwardRef 接收的函数中，将 ref 传递给原生 button 元素，DOM渲染完成后, ref.current 拿到 button 的 DOM 引用。
4. 这样在父组件那一层的 ref 对象，就拿到了 FancyButton 内部的 button 的 DOM 引用。
🔥注意:
1. 第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。
2. Ref 转发不仅限于 DOM 组件，也可以转发 refs 到 class 组件实例中。
```jsx
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));
// ref 属性会获取到 FancyButton 中原生 button 的 DOM 引用
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```
*** 在高阶组件中转发 refs ***
1. ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。
2. 这意味着用于我们 FancyButton 组件的 refs 实际上将被挂载到 LogProps 组件。
3. 幸运的是，我们可以使用 React.forwardRef API 明确地将 refs 转发到内部的 FancyButton 组件。React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点。例如:
```jsx
function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }
    render() {
      const {forwardedRef, ...rest} = this.props;
      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
      return <Component ref={forwardedRef} {...rest} />;
    }
  }
  // 注意 React.forwardRef 回调的第二个参数 “ref”。
  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
  return React.forwardRef((props, ref) => {
    return <LogProps {...props} forwardedRef={ref} />;
  });
}
```

# fcreateRef
React.createRef 创建一个能够通过 ref 属性附加到 React 元素的 ref 对象，通过 current 取得实例，比如 DOM 结点的引用。
```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }
  render() {
    return <input type="text" ref={this.inputRef} />;
  }
  componentDidMount() {
    this.inputRef.current.focus();
  }
}
```

# fforwardRef
React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。
React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 ref 作为参数来调用此函数。此函数应返回 React 节点。
```jsx
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```
在上述的示例中，React 会将 <FancyButton ref={ref}> 元素的 ref 作为第二个参数传递给 React.forwardRef 函数中的渲染函数。
该渲染函数会将 ref 传递给 <button ref={ref}> 元素。
因此，当 React 附加了 ref 属性之后，ref.current 将直接指向 <button> DOM 元素实例。


# f高阶组件 fHOC  Higher-Order Components
*讲概念*
1. 高阶组件又称为 HOC, 是 React 中用于复用组件逻辑的一种高级技巧。
2. HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
3. 简单来说，高阶组件是参数为组件，返回值为新组件的函数。组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。
*说用途*
1. 解决横切关注点问题
**什么是横切关注点**
关注点是指基于功能划分系统的一部分，部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点」。
举例来说，日志功能就是横切关注点的一个典型案例。日志功能往往横跨系统中的各个业务模块，即“横切”所有需要日志功能的类和方法体。所以我们说日志成为了横切整个系统对象结构的关注点 —— 也就叫做横切关注点。
**Mixins如何解决横切关注点问题？**
TODO:
https://zh-hans.reactjs.org/docs/react-without-es6.html#mixins
**为什么Mixins解决横切关注点是有害的？**


*三方库*
1. 在第三方库中很常见，比如 Redux 的 connect 函数、Relay 的 createFragmentContainer。


# f错误边界 fErrorBoundary
*讲概念*
错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。
*说用途*
部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React16 引入了这个新的概念——错误边界。
*列写法*
1. 类组件中定义`static getDerivedStateFromError`或`componentDidCatch`这两个生命周期方法中的任意多个时，它就变成一个错误边界。
2. 当抛出错误后，使用`static getDerivedStateFromError`设置降级UI的数据，使用`componentDidCatch`打印错误信息。
```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true };  // 更新 state 使下一次渲染能够显示降级后的 UI
  }
  componentDidCatch(error, errorInfo) {
    logErrorToMyService(error, errorInfo);  // 将错误日志上报给服务器
  }
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;  // 渲染降级后的 UI
    }
    return this.props.children; 
  }
}
```
```jsx
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>
```
*缺点*
1. 只能在类组件上使用 (包裹的子组件没有限制)
2. 注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。
3. 只能捕获`渲染期间、生命周期方法、整个组件树的构造函数`发生的错误，无法捕获以下场景中产生的错误:
  1. 事件处理
  2. 异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）
  3. 服务端渲染
  4. 它自身抛出来的错误，并非它的子组件
对于这些场景，使用常规的 try/catch 语法来捕获错误。


# 打包
*讲概念*
打包📦是将一个文件和它引用的模块合并到一个单独文件的过程，最终形成一个bundle。接着在页面上引入该bundle，整个应用即可一次性加载。

# Transition
*讲概念*
Transition 是 React18 提出的一个改善用户交互的解决方案。它可以将更新标记为一个 transitions，transitons 可以被中断执行。也就是说，它将更新分为`紧急更新`和`过渡更新`。
1. 紧急更新如输入文本、选中下拉列表一项产生的更新，需要快速给用户反馈，所以会优先渲染。
2. 过渡更新是指从一个视图过渡到另一视图，中间产生的一系列更新，用户不关心这些更新产生的中间状态，只关心最终结果，所以它们`可被中断`且只渲染最终结果。
**例子🌰**
举例来说，比如有一个搜索框，快速输入关键词会实时展示大量搜索结果。每次用户输入都会产生 2 个更新，一个是更新输入框的值(紧急更新)，另一个是更新搜索结果。由于`更新搜索结果`要花费大量时间，且用户更关心输入完成后的结果而不是输入过程中的结果，所以更新搜索结果可以定义为`过渡更新`，它在中间过程会被快速发生的一系列`紧急更新`打断，直到所有的`紧急更新`完毕，`过渡更新`渲染最终的视图。
*说用途(解决了什么问题)*
在大数据量的情况下，一次更新可能引起视图的巨大变化，浏览器需要花费大量时间处理视图而无法响应用户交互，造成卡顿。
*优点*
在以往的方案中，我们常常使用 setTimeout，即使防抖和节流也是如此。下面对比 transition 和 setTimeout 的不同，以展现其优点:
1. 执行时间更早
2. 不会阻塞用户交互
3. 更精确地跟踪loading状态
**执行时间更早**
React.startTransition 中的状态更新是异步，但是包裹状态更新的函数是同步执行的，如果放在 setTimeout 中就是异步执行，所以执行时间更早。
**不会阻塞用户交互**
1. setTimeout 本质上是将`大数据量的那个更新`延迟了，让本次`紧急更新`先渲染，但是延迟的`大数据量的那个更新`终将到来，那时候也会占用浏览器大量时间进行渲染，而无法响应用户交互，所以还是阻塞了用户交互。防抖/节流也是一样的，只是把大量的更新降低为少量的更新，当一次更新非常巨大的时候，无法中断它，也会造成卡顿。
2. 而 transition 的`过渡更新`是可以中断的，`用户交互`到来时优先渲染用户交互，所以不会阻塞。
**更精确地跟踪loading状态**
transition 方案提供了 useTransiton 这个 hook, 它返回一个数组，数组第一项 isPending 代表过渡更新是否正在过渡中, 如果是就是true, 不是就是false, 这可以精确追踪过渡更新的状态，这是 setTimeout 没有实现的。
*列用法*
**fstartTransition**
React.startTransition 接收一个函数 fallback，把 fallback 里面的更新标记为 transitions，它的返回值类型是 void。这个方法是为了在 React.useTransition 不可用时使用。
1. 过渡期的更新会被更紧急的更新取代，如点击操作。
2. 过渡期的更新不会显示重新挂起内容的 fallback，允许用户在渲染更新时继续进行交互。
3. React.startTransition 不提供 isPending 的标志。要跟踪过渡的待定状态，请使用 React.useTransition。
```jsx
// 紧急的更新: 展示用户输入了什么
setInputValue(e.target.value);
// 将包裹到的更新都标记为`过渡`
React.startTransition(() => {
  // 不紧急的更新: 展示搜索结果
  setSearchQuery(e.target.value);
})
```
**fuseTransition**
React.useTransition 接收 0 个参数，返回一个数组:
1. 数组第一项是一个状态值isPending，表示过渡任务的等待状态。
2. 数组第二项是一个函数startTransition，startTransition接收一个函数，将里面的状态更新标记过渡任务。
```jsx
function App() {
  const [isPending, startTransition] = React.useTransition();
  const [count, setCount] = React.useState(0);
  function handleClick() {
    // 将`设置count为count+1`标记为`过渡任务`
    startTransition(() => {
      setCount(c => c + 1);
    })
  }
  return (
    <div>
      {isPending && <Spinner />}
      <button onClick={handleClick}>{count}</button>
    </div>
  );
}
```
*参考*
React工作组的讨论: [https://github.com/reactwg/react-18/discussions/41]











# fstartTransition  React.startTransition
*讲概念*
*说用途 (解决了什么问题)*

*优缺点*




















# fuseTransition
*讲概念*
*说用途*
*优缺点*
*原理*
一次高优更新 isPending 为 true, 一次低优更新 isPending 为 false，根据设备调整等待的时长，在性能较差的设备上，间隔时间就会变长。







# fAPI fReact顶层API
*组件*
* React.Component
* React.PureComponent
* React.memo
*创建React元素*
* React.createElement
* React.createFactory  [已废弃]
*转换元素*
* React.cloneElement
* React.isValidElement
* React.Children
*Fragments*
* React.Fragment
*Refs*
* React.createRef
* React.forwardRef
*Suspenses*
* React.lazy
* React.Suspense
*Transitions*
* React.startTransition
* React.useTransition
*Context*
* React.createContext
*Hooks*
**基础Hook**
* React.useState
* React.useEffect
* React.useContext
**额外的Hook**
* React.useReducer
* React.useCallback
* React.useMemo
* React.useRef
* React.useImperativeHandle
* React.useLayoutEffect
* React.useDebugValue
* React.useDeferredValue
* React.useTransition
* React.useId
**Library Hooks**
* React.useInsertionEffect
* React.useSyncExternalStore

# fuseState
React.useState 接收一个初始值或一个初始化函数, 返回一个数组，数组第一项是状态值state，第二项是改变状态的函数setState。

1. 初始化的时候，返回的 state 和 initialState 相同。
2. setState 接收一个值或者一个函数，调用后，将一次更新任务加入队列。
3. 如果使用 setState 更新的 state 和之前的 state 相同，React 不会重新渲染组件。

*例子 函数式更新 计数器*
```jsx
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      数量: {count}
      <button onClick={() => setCount(initialCount)}>重置</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>减少</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>增加</button>
    </>
  );
}
```
*例子 初始化函数*
```jsx
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```
*用法*
```jsx
const [state, setState] = React.useState(initialState);
```

# fuseEffect
React.useEffect 接收一个create函数，以及一个 deps 依赖数组。当依赖数组中的任何一项改变时，React 会在组件更新完成后，异步执行 create 函数，并返回一个 destory 函数。
*要点*
1. create 函数会在 commit 阶段完成后异步执行(宏任务)，这时候浏览器已经完成了`布局`与`绘制`，可以获取到最新的 DOM 结点。 之所以设置成异步，是因为请求、订阅这种副作用操作，不应该阻塞浏览器的对屏幕的更新。
2. create 函数一般用来执行一些副作用，如设置定时器, 请求数据, 订阅数据 等，destory 函数用来作清除工作，如退订数据。
3. destory 函数会在组件卸载前执行，通常情况下组件会多次渲染，那么在执行下一个 effect 之前，上一个 effect 就已经被清除。
4. 如果想要执行只运行一次的 effect, 可以传递一个空数组。
*对比 useLayoutEffect*
并非所有的副作用都可以被延迟执行，例如，一个对用户可见的 DOM 操作就必须在浏览器执行下一次绘制之前被同步执行，这时候就应该用 useLayoutEffect，它会在 commit 阶段的 layout 阶段触发，对 DOM 的更新会被浏览器同步渲染。
*用法*
```jsx
useEffect(create, deps);
```
*例子*
```jsx
useEffect(() => {
    const subscription = props.source.subscribe();
    return () => {
      subscription.unsubscribe();
    };
  }, [props.source],
);
```

# fuseContext
React.useContext 接收一个 context 对象，返回该 context 对象的当前值。context 对象一般是 React.createContext(obj) 的返回值。
当前的 context 值由上层组件中距离当前组件最近的`Context.Provider`的`value`属性决定。
当组件上层最近的`Context.Provider`更新时，该`Hook`会触发重渲染，并使用最新传递给`Context.Provider`的`value`值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。

*例子 切换主题*
```jsx
import React, { useContext, useState } from 'react';
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};
const ThemeContext = React.createContext(themes.light);
function App() {
  const [theme, setTheme] = useState(themes.dark);
  const onChangeTheme = () => {
    setTheme(theme === themes.dark ? themes.light : themes.dark);
  }
  return (
    <ThemeContext.Provider value={theme}>
      <Toolbar />
      <button onClick={onChangeTheme}>change theme</button>
    </ThemeContext.Provider>
  );
}
function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}
function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      I am styled by theme context!
    </button>
  );
}
```

# fuseReducer
React.useReducer 接收三个参数，返回一个数组。

三个参数分别是:
1. reducer      一个调度函数，传入当前状态state和改变状态的方法action, 返回全新的状态。
2. initialArg   传递给第三个参数init函数的值，一般是state的初始值
3. init         初始值生成函数，接收第二个参数 initialArg，返回值作为 state 的初始值。

返回值是一个数组，包含两项:
1. state        当前的状态
2. dispatch     一个函数，代表改变状态的方法，接收 action，从 reducer 里得到相应的状态。

**注意**
1. 如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行，React 内部通过 Object.is 这个 API 来决定前后 state 是否相同。

*用法*
```jsx
const [state, dispatch] = useReducer(reducer, initialArg, init);
```
*例子*
```jsx
function init(initialCount) {
  return {count: initialCount};
}
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}
function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      </button>
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

# fcallback fuseCallback
React.useCallback 接收两个参数，第一个是`可能被缓存的函数`，第二个是`依赖数组`，返回一个`缓存函数`。
这个`缓存函数`仅在`依赖数组`的某一项改变时才会更新。
*用法*
```jsx
const memoizedCallback = useCallback(
  () => { doSomething(a, b) },
  [a, b],
);
```
它的作用主要是保持函数的引用不变，这样可以避免一些不必要的`重新渲染`。
比如子组件比较两个引用是否相等，如果父组件用了 useCallback 命中了缓存，那么更新前后传递给子组件的就是同一个引用，子组件就可以不必渲染，提高性能。

# fmemo fReact.memo [下一项是useMemo]
React.memo 接收两个参数，一个`函数组件`，以及一个`比较函数`，返回一个`缓存值`。
当`比较函数`返回 true 时，React 将跳过被 React.memo 包裹的组件的渲染，直接返回最近一次的渲染结果;
当`比较函数`返回 false 时，组件重新渲染，React.memo 返回重新渲染的结果。
*注意*
1. 比较函数默认情况下会`浅比较`更新前后的 props，如果一致返回 true, 不一致返回 false。
2. React.memo 默认仅检查 props。如果被包裹的函数组件使用了 useState，useReducer 或 useContext 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。
*用法*
```jsx
const MemoComponent = React.memo(MyComponent, areEqual);
```
*例子*
```jsx
function MyComponent(props) { /* 使用 props 渲染 */ }
function areEqual(prevProps, nextProps) { /* 返回 true 跳过渲染，返回 false 正常渲染。 */ }
export default React.memo(MyComponent, areEqual);
```

# fuseMemo [上一项是React.memo]
useMemo 接收两个参数，一个是`create函数`，一个是`依赖数组`，返回一个缓存值。
当函数组件重新渲染时，如果`依赖数组`中的任何一项发生了改变，`create函数`就会重新执行，返回新的缓存值。
这种优化有助于避免在每次渲染时都进行高开销的计算。
*用法*
```jsx
const memoizedValue = useMemo(create, deps);
```
*注意*
1. 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。
2. 如果传入 deps 一个空数组，那么 useMemo 将只保留第一次的缓存，不会刷新缓存。
3. 不要把副作用这类的操作放在 create 函数中，这属于 useEffect 的适用范畴。传入 useMemo 的函数会在渲染期间执行，而不是渲染完成后。

# f回调ref
给 React 原生DOM元素的 ref 属性传递一个回调函数，这个回调函数将会收到 DOM 实例。
```jsx
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = null;
    this.setTextInputRef = (element) => { this.textInput = element };
  }
  componentDidMount() {
    // 获得 text 输入框 DOM 结点
    console.log(this.textInput);
  }
  render() {
    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React 实例上
    return (
      <div>
        <input type="text" ref={this.setTextInputRef}  />
      </div>
    );
  }
}
```

# fuseRef
React.useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为 useRef 接收的参数(initialValue)。
返回的 ref 对象在组件的整个生命周期内持续存在。

本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。

*例子 命令式地访问子组件*
```jsx
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` 指向已挂载到 DOM 上的 input 元素
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}
```

# fuseImperativeHandle
一般情况下，我们不可以直接引用一个函数组件。但是 useImperativeHandle 可以让你使用 ref 调用一些子组件暴露的方法。
useImperativeHandle 应当与 forwardRef 一起使用。
*例子 父组件调用子组件暴露的方法doit*
```jsx
// 子组件
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    doit: () => {
      // 这里完全可以换成一句 log 啥的，和 useRef 没有关系的那种。
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);

// 父组件
function Parent() {
  const ref = useRef();
  useEffect(() => {
    ref.current.doit();
  })
  return (
    <div>
      <FancyInput ref={ref}>
    <div>
  )
}
```
*用法*
```jsx
useImperativeHandle(ref, createHandle, [deps]);
```


# fuseLayoutEffect
1. 在 commit 阶段的 layout 阶段同步执行，也就是所有的 DOM 变更之后同步调用。
2. 使用方法和 useEffect 相同。
3. 可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。
注意: 尽可能使用标准的 useEffect 以避免阻塞视觉更新。
*用法*
```jsx
useLayoutEffect(create, deps);
```
*例子*
```jsx
function Demo() {
  React.useLayoutEffect(() => {
    console.log('commit阶段-layout阶段同步执行')
  }, []);
  return <div>Demo</div>
}
```


# fuseDebugValue
React.useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。
*例子*
```jsx
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);
  // 在开发者工具中的这个 Hook 旁边显示标签
  // e.g. "FriendStatus: Online"
  useDebugValue(isOnline ? 'Online' : 'Offline');
  return isOnline;
}
```
**延迟格式化 debug 值**
在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。
因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。
例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用:
```jsx
useDebugValue(date, date => date.toDateString());
```

# fuseDeferredValue
React.useDeferredValue 接受一个值，并返回该值的新副本，该副本将推迟到更紧急的更新之后。
如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。

该 hook 与使用防抖和节流去延迟更新的用户空间 hooks 类似。
使用 useDeferredValue 的好处是，React 将在其他工作完成后立即进行更新，而不是等待任意时间。并且像 startTransition 一样，延迟值可以暂停，而不会触发现有内容的意外降级。

useDeferredValue 仅延迟你传递给它的值。
如果你想要在紧急更新期间防止子组件重新渲染，则还必须使用 React.memo 或 React.useMemo 记忆该子组件:
*例子 延迟并防止子组件重渲染*
```jsx
function Typeahead() {
  const query = useSearchQuery('');
  const deferredQuery = useDeferredValue(query);
  // Memoizing 告诉 React 仅当 deferredQuery 改变，
  // 而不是 query 改变的时候才重新渲染
  const suggestions = useMemo(() =>
    <SearchSuggestions query={deferredQuery} />,
    [deferredQuery]
  );
  return (
    <>
      <SearchInput query={query} />
      <Suspense fallback="Loading results...">
        {suggestions}
      </Suspense>
    </>
  );
}
```
记忆该子组件告诉 React 它仅当 deferredQuery 改变而不是 query 改变的时候才需要去重新渲染。
这个限制不是 useDeferredValue 独有的，它和使用防抖或节流的 hooks 类似。


# fuseId
useId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。
注意: useId 生成一个包含 : 的字符串 token。这有助于确保 token 是唯一的，但在 CSS 选择器或 querySelectorAll 等 API 中不受支持。
*例子*
```jsx
import { useId } from 'react';

// 直接传递 id 给需要它的元素
function Checkbox() {
  const id = useId();
  return (
    <>
      <label htmlFor={id}>Do you like React?</label>
      <input id={id} type="checkbox" name="react"/>
    </>
  );
};

// 对于同一组件中的多个 ID，使用相同的 id 并添加后缀
function NameFields() {
  const id = useId();
  return (
    <div>
      <label htmlFor={id + '-firstName'}>First Name</label>
      <div>
        <input id={id + '-firstName'} type="text" />
      </div>
      <label htmlFor={id + '-lastName'}>Last Name</label>
      <div>
        <input id={id + '-lastName'} type="text" />
      </div>
    </div>
  );
}
```

# fComponent
React.Component 是使用 ES6 class 语法定义 React 组件的基类:
```jsx
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

# fPureComponent  fCompoennt和PureCompoennt的区别
1. React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以`浅层对比` prop 和 state 的方式来实现了该函数。
2. 如果 prop 或 state 中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。
仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。
3. React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。
4. 你也可以考虑使用 immutable 对象加速嵌套数据的比较。

# fcreateElement
创建并返回指定类型的新 React 元素。其中的类型参数既可以是标签名字符串（如 'div' 或 'span'），也可以是 React 组件 类型 (类组件或函数组件)，或是 React.Fragment 类型。

*用法*
```js
React.createElement(type, [props], [...children])
```

使用 JSX 编写的代码将会被转换成使用 React.createElement() 的形式。
如果使用了 JSX 方式，那么一般来说就不需要直接调用 React.createElement()。
*JSX*
```jsx
<div>Hello {this.props.toWhat}</div>;
```
*React.createElement*
```js
React.createElement('div', null, `Hello ${this.props.toWhat}`);
```

# fcreateFactory
此辅助函数已废弃，用 React.createElement 代替它。
返回用于生成指定类型 React 元素的函数，如 'div', 'span', React组件等。


# fcloneElement
以 element 元素为样板克隆并返回新的 React 元素。config 中应包含新的 props，key 或 ref。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。新的子元素将取代现有的子元素，如果在 config 中未出现 key 或 ref，那么原始元素的 key 和 ref 将被保留。
*用法*
```js
React.cloneElement(element,[config],[...children])
```
React.cloneElement() 几乎等同于:
```jsx
<element.type {...element.props} {...props}>{children}</element.type>
```
但是，这也保留了组件的 ref。这意味着当通过 ref 获取子节点时，你将不会意外地从你祖先节点上窃取它。相同的 ref 将添加到克隆后的新元素中。如果存在新的 ref 或 key 将覆盖之前的。
引入此 API 是为了替换已弃用的 React.addons.cloneWithProps()。


# fisValidElement
*用法*
```js
React.isValidElement(object);
```
*解释*
传入一个对象，验证对象是否为 React 元素，返回值为 true 或 false。


# fChildren
React.Children 提供了用于处理 this.props.children 的实用方法, 类似于数组的方法。
*React.Children.map*
```js
React.Children.map(children, function[(thisArg)])
```
在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg，返回一个数组。
如果 children 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 null 或是 undefined，则此方法将返回 null 或是 undefined，而不会返回数组。
*React.Children.forEach*
```js
React.Children.forEach(children, function[(thisArg)])
```
与 React.Children.map() 类似，但它只会遍历，不会返回一个数组。
*React.Children.count*
```js
React.Children.count(children)
```
返回 children 中的组件总数量，等同于通过 map 或 forEach 调用回调函数的次数。
*React.Children.only*
```js
React.Children.only(children)
```
children 可能是个数组，这个 API 能验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。
*React.Children.toArray*
```js
React.Children.toArray(children)
```
将 children 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 key。当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 this.props.children 之前对内容重新排序或获取子集时。


# fFragment
*讲概念*
函数组件(或类组件render方法)不能直接返回多个元素，必须由一个元素包裹着这多个元素。而 React.Fragment 组件能够在不额外创建 DOM 元素的情况下，让函数组件(或类组件render方法)返回多个元素。
*🔥注意*
1. 我们也可以使用其简写语法 <></>。
2. 使用 React.Fragement 语法声明的片段可能具有 key。key 是唯一可以传递给 Fragment 的属性。一个使用场景是将一个集合映射到一个 Fragments 数组。
*例子1*
```jsx
class Columns extends React.Component {
  render() {
    return (
      <React.Fragment>
        <td>Hello</td>
        <td>World</td>
      </React.Fragment>
    );
  }
}
// 正确渲染 table
class Table extends React.Component {
  render() {
    return (
      <table>
        <tr>
          <Columns />
        </tr>
      </table>
    );
  }
}
```
*例子2*
```jsx
function Glossary(props) {
  return (
    <dl>
      {props.items.map(item => (
        // 没有`key`，React 会发出一个关键警告
        <React.Fragment key={item.id}>
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </React.Fragment>
      ))}
    </dl>
  );
}
```


# flazy
React.lazy() 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。
*动态加载一个组件*
```js
const SomeComponent = React.lazy(() => import('./SomeComponent'));
```
注意: 渲染 lazy 组件依赖该组件渲染树上层的 <React.Suspense> 组件。这是指定加载指示器（loading indicator）的方式。


# fSuspense
React.Suspense 使得组件可以“等待”某些操作结束后，再进行渲染, 它通过 fallback 属性指定 Loading 状态展示的组件。
*显示 Spinner 直至 OtherComponent 加载完成*
```js
const OtherComponent = React.lazy(() => import('./OtherComponent'));
function MyComponent() {
  return (
    <React.Suspense fallback={<Spinner />}>
      <div>
        <OtherComponent />
      </div>
    </React.Suspense>
  );
}
```
注意: lazy 组件可以位于 Suspense 组件树的深处——它不必包装树中的每一个延迟加载组件。
最佳实践是将 <Suspense> 置于你想展示 Loading 的位置，而 lazy() 则可被放置于任何你想要做代码分割的地方。


# fstartTransition
配合 React.useTransition 使用。React.startTransition 让你把提供的 fallback 里面的更新标记为 transitions。
*用法*
```js
React.startTransition(callback)
```
*注意*
* 过渡期的更新会被更紧急的更新取代，如点击操作。
* 过渡期的更新不会显示重新挂起内容的 fallback，允许用户在渲染更新时继续进行交互。 (TODO: 查看掘金小册)

# fuseTransition
返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。
*用法*
```js
function App() {
  const [isPending, startTransition] = React.useTransition();
  const [count, setCount] = React.useState(0);
  function handleClick() {
    React.startTransition(() => {
      setCount(c => c + 1);
    })
  }
  return (
    <div>
      {isPending && <Spinner />}
      <button onClick={handleClick}>{count}</button>
    </div>
  );
}
```
*注意*
* startTransition 允许你通过标记更新将提供的回调函数作为一个过渡任务
* isPending 指示过渡任务何时活跃以显示一个等待状态
* 过渡任务中触发的更新会让更紧急地更新先进行，比如点击。
* 过渡任务中的更新将不会展示由于再次挂起而导致降级的内容。这个机制允许用户在 React 渲染更新的时候继续与当前内容进行交互。


# fuseSyncExternalStore
**为库作者提供的，用于将库深入集成到 React 模型中，通常不会在应用程序代码中使用**
useSyncExternalStore 是一个推荐用于读取和订阅外部数据源的 hook，其方式与选择性的 hydration 和时间切片等并发渲染功能兼容。

此方法返回存储的值并接受三个参数：
* subscribe：用于注册一个回调函数，当存储值发生更改时被调用。
* getSnapshot： 返回当前存储值的函数。
* getServerSnapshot：返回服务端渲染期间使用的存储值的函数
*用法*
```jsx
const state = useSyncExternalStore(subscribe, getSnapshot[, getServerSnapshot]);
```

# fuseInsertionEffect
**为库作者提供的，用于将库深入集成到 React 模型中，通常不会在应用程序代码中使用**
1. useInsertionEffect 在所有 DOM 突变之前同步触发。也就是在 commit 阶段的 beforeMutation 阶段触发。
2. 使用它在读取 useLayoutEffect 中的布局之前将样式注入 DOM。
3. 由于这个 hook 的作用域有限，所以这个 hook 不能访问 refs，也不能安排更新。
*注意*
useInsertionEffect 应仅限于 css-in-js 库作者使用。优先考虑使用 useEffect 或 useLayoutEffect 来替代。
*用法*
```jsx
useInsertionEffect(didUpdate);
```







# fsetState是同步还是异步  fthis.setState是同步还是异步
在`React`的不同模式下，`this.setState`有不同的表现:
1. 在 legacy 模式下，如果命中了 batchedUpdate 逻辑，就是异步，如果没有命中 batchedUpdate 逻辑就是同步。
2. 在 concurrent 模式下，this.setState 始终表现为异步。

# f防止子组件重新渲染 f性能优化
1. React.memo(function SonComponent() {}, function areEqual(prevProps, nextProps) {...})
2. useMemo(() => <>{...SonComponent}</>, [])
3. PureComponent 浅比较 更新前后的props 和 更新前后的state
4. shouldComponentUpdate(nextProps, nextState)

在 React 中，控制组件是否渲染有三个方面: props, state 和 context, 只要这三者都不变，组件就不会渲染。
如果是父组件引起的子组件渲染，也就是说子组件的 state 和 context 都不变，那么只需要控制 props 不变即可。但是 React 的默认 props 比较策略是`引用比较`，而且每次更新 props 都是一个全新的对象，那么即使更新前后 props 的属性没有任何改变，子组件也会重新渲染。
这时候就要将`引用比较`改为`浅比较`，使用 React 的性能优化 API，如 React.memo, useMemo, PureComponent, shouldComponentUpdate。


## fPureComponent   class Component extends React.PureComponent
以浅比较更新前后的 prop 和 state 的方式来实现了 shouldComponent。
## fshouldComponentUpdate
shouldComponentUpdate(nextProps, nextState), 返回一个布尔值，决定类组件是否重新渲染。

# fhooks
## 讲概念
Hook 是 React 16.8.0 的新增特性。它让函数组件也能做类组件能做的大部分的事，通过hooks函数组件有了自己的状态，可以处理副作用，能获取 ref 等。
## 说用途 (f解决了什么问题 f问题)
1. 在组件之间复用状态逻辑
2. 组合复杂组件的相关逻辑
3. 拥抱函数式编程

* 在组件之间复用状态逻辑
使用 Hook 可以从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。这使得在组件间或社区内共享 Hook 变得更便捷。
* 组合复杂组件的相关逻辑
在 hook 之前我们常常在组件的生命周期中编写一些不相关的代码，比如在 componentDidMount 中获取数据，同时又设置事件监听，然后在 componentWillUnmount 中清除，这样就把不相关的代码组合在一起，而相关的代码又分在了不同地方，这种写法很容易引起 bug。
为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。
* 拥抱函数式编程
根据官网的描述, 编写 class 的方式使得代码不能很好地压缩，并且会使热重载出现不稳定的情况。为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性, 比如维护状态，处理副作用，获取ref等。这样就能用函数组件替代大部分类组件，拥抱函数式编程。
`官网: 我们准备让 Hook 覆盖所有 class 组件的使用场景，但是我们将继续为 class 组件提供支持。`
## 优缺点

## f原理 fhooks原理 f你来聊一下hooks的原理是什么
hooks 本质上是一条单向链表，存在于fiber.memoizedState，当然这个fiber得是函数组件的fiber，通过 next 指针将本函数组件的所有 hook 顺序连接到一起:`fiber.memoizedState: hook1 -> hook2 -> ...`。

函数组件 render 时，分为 首次执行 和 更新 两种情况。以 useState 为例, `首次执行`做的是生成 hook 加入到 fiber.memoizedState, 返回初始值和更新函数也就是dispatchAction; 而`更新`是执行 dispathAction，本质上就是创建 update 对象，加入到 hook.queue.pending;

两种情况都会依次执行 hook, 计算每个 hook 的状态，放到 hook.memoizedState 中。状态计算是基于 hook.queue.pending 这条环状链表，链表上的每个结构都是一个 Update 对象，update 上保存着用户传入的action, 比如 setCount(c => c + 1), 其中的 c => c + 1 这个箭头函数就是 action。 Hook 会基于 hook 原有的 memoizedState，然后执行一圈的环状链表上的 Update 对象，最终得到新的 memoizedState 返回。
```ts
interface Hook {
  baseQueue: null;
  baseState: unknown;  // 基于某个状态，计算本次 memoizedState
  memoizedState: unknown;   // 本 hook 的状态值
  next: Hook;  // 下一个 hook
  queue: Update;  // hook 上的 Update 对象
}
interface Update {
  action: Function | unknown;  // 如 c=>c+1
  next: Update;  // 指向下一个 update 对象
}
```
## f使用hooks的注意事项
1. 约定命名以useXX开头
2. 必须在函数组件内使用，不能在类组件里使用
3. 必须在函数组件作用域顶部使用
4. 每次组件render不能打乱hooks的执行顺序，比如放到条件语句、或循环语句中是不行的。
## 为什么hook不能放在条件语句中
每次App更新的时候，hooks都必须遵照完全一样的顺序，因为它们是保存在一条链表中的，更新的时候只会按链表顺序更新。如果打乱了顺序，链表结点和组件hook的对应关系就会出错。
## f自定义hooks fReact如何封装自定义hooks
自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。
自定义 hook 的 state 是完全独立的，hook 的每次调用都有一个完全独立的 state，因为在同一个组件中多次调用同一个自定义hook，它们的状态也互不影响。
### f自定义hooks必须以"use"开头吗？
必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。
### f自定义hooks的用途
自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题。
*定义自定义hooks*
```js
import { useState, useEffect } from 'react';
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });
  return isOnline;
}
```
*使用自定义hooks*
```js
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);
  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}
```

## fhook相关属性
fiber.memoizedState是 hook
hook.memoizedState 是当前 hook 的状态
hook.next 是下一个hook
hook.queue.pending 是最后一个 update，下一个就是第一个 update。
update.next是下一个update
update.action是待更新的操作，如 num => num+1
## fuseEffect feffect
React 在完成对 DOM 的更改后运行“副作用”函数。原理是在 commit 阶段结束后异步执行。
## fuseLayoutEffect
在 commit 阶段结束时同步执行。
## fuseState发生了什么
基于这个useState代表的hook的hook.memoizedState，遍历 hook 的 update 环: hook.queue.pending，顺序执行所有的update，上一个的输出作为下一个的输入，一直计算到最后，得到最终的state，作为新的hook.memoizedState，清空本hook的update环，返回一个数组，数组的第0项是更新后的状态，第1项是dispatch, 然后更新函数组件。
## fsetNum发生了什么
setNum -> 放置update对象到hook上(多次setNum就有多个update对象，形成一个环)App重新render -> 执行 useState -> 得到新状态num -> 基于新状态得到新的ReactElement -> 渲染新视图


# f事件机制 fReact事件机制
1. React并不是将事件回调绑定到真实的DOM上，而是在根结点处监听所有的事件。在 v17 之前，React 事件是绑定在 document 上的，v17 以后事件绑定到了应用对应的容器结点上(#root)。
2. React 实现了自己的一套事件捕获和事件冒泡机制，当事件发生并且冒泡到根结点t处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。
3. React 的事件并不是原生事件，而是 React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。
## f为什么要有事件系统
有两点原因，一是兼容不同浏览器，二是为了统一管理。
1. 对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架， 为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。
2. v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。
## f合成事件
React 应用中，元素绑定的事件并不是原生事件，而是 React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。
### 优点
- 兼容所有浏览器，更好的跨平台；
- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。
- 方便 react 统一管理和事务机制。
## fReact事件 vs f原生事件
1. 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；
2. 对于事件函数处理语法，原生事件为字符串，react 事件为函数；
3. react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用`preventDefault()`来阻止默认行为。
## f事件捕获 f事件冒泡 fReact是如何模拟事件捕获和事件冒泡的
当事件触发时，React会从当前fiber向上遍历，遇到绑定了事件的fiber时，就会用一个数组收集事件，把冒泡阶段的事件回调用push放进去，也就是插入到数组尾，而把捕获阶段的事件回调用unshift放进去，也就是插入到数组头。直到遍历到根结点。然后依次执行数组里的事件回调。
## f阻止默认行为
在React应用中，可以用`e.preventDefault()`阻止事件默认行为，但不能用类似原生事件的`return false`来阻止。
这是因为在 React 中给元素的事件并不是真正的事件处理函数，导致`return false`方法在 React 应用中失去了作用，preventDefault 也是单独处理的。

# ffiber fReact为什么需要fiber?
## f什么是Fiber
Fiber 包含三层含义: 协调器的架构、静态的数据结构、动态的工作单元。
1. 架构
作为协调器的架构来说，之前 React15 的协调器采用递归的方式执行，数据保存在递归调用栈中，所以被称为 stack reconciler。
而 React16 的协调器基于 Fiber 结点实现，被成为 fiber reconciler。
2. 数据结构
作为静态数据结构来说，每个 fiber 结点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
3. 工作单元
作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

## f纤程
Fiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。

Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。

React Fiber可以理解为:
React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。其中每个任务更新单元为React Element对应的Fiber节点。

## f为什么需要fiber
React 在 16 版本之前，用的是`递归`的方式更新组件，这是一个同步的更新，一旦开始就无法中断，如果这一次更新超过了浏览器一帧的时间，一般是 16 ms，用户交互就会卡顿。显然这不满足 React 快速响应的理念，所以 16 版本以后 React 提出了新的 fiber 架构，用`异步可中断的更新`替代`同步的更新`。

## ffiber解决了哪些问题
1. 解决了 React15 同步更新造成的用户卡顿问题
2. 支持高优先级任务插队低优先级任务
3. 任务中断以后可以恢复，复用之前的中间状态

## f架构 fReact的架构 16之前是什么架构？16之后是什么架构？为什么这么演变？
16 之前，React 只有 协调器 和 渲染器; 16 之后，React 有 调度器、协调器、渲染器。
各模块功能如下:
* 调度器: 调度任务的优先级，高优任务优先进入协调器。
* 协调器: 负责找出变化的组件。
* 渲染器: 负责将变化的组件渲染到页面上。
### Scheduler
Scheduler 是 React 团队为 requestIdleCallback 做的 polyfill,  因为 rIC 有以下缺点:
1. 浏览器兼容性不好;
2. 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低。
### Reconciler
Reconciler 从递归的方式，变为可中断的循环方式，每次循环都会调用 shouldYield(), 如果当前有剩余时间才继续，没有就中断循环。
* 那么React16是如何解决中断更新时DOM渲染不完全的问题呢？
在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记。整个Scheduler与Reconciler的工作都在内存中进行，不展示到视图上。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer，渲染视图。
### Renderer
Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。


# f虚拟DOM fvdom fVirtual DOM
虚拟DOM本质上就是一个对象，该对象描述了一个UI结点所对应的一些必要信息。React 的虚拟DOM 可以理解为 ReactElement 和 Fiber，因为 DIFF 是比较这两者。
## 为什么需要虚拟DOM?
1. 真实DOM的属性太多了，如果直接对真实DOM进diff，消耗性能非常大。
比如，可以在控制台写 document.createElement('div') 得到一个结点，打开这个结点，会看到上面的属性非常多，如果直接做 diff，要对比这么多属性，消耗的性能就非常大。而虚拟 dom 一般就是 { type: 'div', props: {} }, 只需要对比这几个属性，性能损耗大幅降低。
2. 对真实DOM进行curd很消耗性能，可以用虚拟DOM代替。
## 说用途
1. 渲染
2. 比对 dom diff

# fDomDiff fDiff fReactDomDiff fdiff算法
Diff算法在比较`更新前虚拟dom树`和`更新后虚拟dom树`，找出两者之间的差异。React 的 DOM DIFF，是对比老 fiber (current.child) 和 新产生的 ReactElement，从而生成 workInProgress.child。
## 说用途 f为什么需要diff算法？
为了提高渲染性能，每次更新应该只渲染有变化的部分，而`diff算法`的目的就是要找出这个变化的部分。
## 制定规则
为了提高对比的性能，React 在 Dom Diff 时制定了三个规则:
1. 只比较同级元素，不跨层级对比。
2. 不同类型对应不同元素，如 div 和 span，React 不会尝试复用不同类型的元素。
3. 通过 key 来标识更新前后是同一个结点。
## 时间复杂度
时间复杂度 O(N)，N 是这一层的结点个数。因为算法本质就是遍历一次老结点，遍历一次新结点。
这个问题实际上是: 同一层上的编辑距离问题。
## 具体过程  fDomDiff的过程
React 的 Dom Diff 分为 单结点diff 和 多结点diff。这里的`单结点`或`多结点`指的是新结点，新结点只有单个就是单结点diff，新结点有多个就是多结点diff。
### 单结点diff
因为只有一个新结点，所以通过 sibling 指针遍历老结点即可，遍历过程比较新老结点的 type 和 key, 有三种情况:
1. 如果 type 和 key 都相同，说明这个老结点可以复用，标记剩余的老结点为`删除`，返回这个可复用的老结点。
2. 如果 key 相同，但是 type 不同，自己和弟弟都标记为删除，跳出遍历，直接新建一个结点，标记`插入`。
3. 如果 key 不同，删除这个老结点，继续遍历下一个老结点。如果遍历完了还是没有结点可复用，那就新建一个结点，标记`插入`。
🌰例子
比如: liA,liB,liC => liB
DIFF过程就是:  
liA => liB ❌ Deletion
liB => liB ✅ 复用
liC        ❌ Deletion
### 多结点diff
分为四步:
1. 同时遍历新老结点，处理更新 (新结点用索引:newIdx++, 老结点用指针: oldFiber = oldFiber.sibling)
2. 如果有剩余的老结点，删除多余的老结点 (deleteRemainingChildren)
3. 如果有剩余的新结点，增加新结点 
4. 处理移动的情况

* 处理移动的情况
在第一步处理更新时，可能因 key 不同而直接跳出循环，这样也跳过了二、三步，直接来到第四步处理移动。
处理移动的步骤:
1. 将剩余的老结点都放入一个 Map 中，以 oldFiber.key 或 oldFiber.index 为键，以 oldFiber本身为值。
2. 设置一个 lastPlacedIndex 变量，代表最后一个可复用的结点在 oldFibers 中的位置索引。
3. 遍历剩余的新结点，通过 newChild.key 查找 Map 中是否有可复用的老结点，可复用是指 key 和 type 都相同:
  
  * 如果有，复用老结点，然后比较 lastPlacedIndex 和 oldFiber.index，由于结点是从左往右遍历的，在没有移动的情况下，新老 index 应该同步变大，
    本次复用的 oldFiber 应该在最后一个可复用的 oldFiber 右边，也就是说 oldFiber.index 应该 >= lastPlacedIndex，但是比较结果有两种情况:

    - oldFiber.index < lastPlacedIndex, 说明 `本次复用的oldFiber` 在`最后一个可复用的oldFiber`左边，也就说明`本次复用的oldFiber`在更新后向右移动了，所以 newFiber 标记为`移动`(移动也就是Placement，在老结点存在的情况下，插入就是移动), lastPlacedIndex 不变。

    - oldFiber.index >= lastPlacedIndex, 说明 `本次复用的oldFiber` 在`最后一个可复用的oldFiber`右边，这说明 `本次复用的oldFiber` 没有移动, 本次复用的oldFiber`要作为`最后一个可复用的oldFiber`给下一轮循环的 oldFiber 作参照物，所以更新 lastPlacedIndex 为 oldFiber.index。

  * 如果没有，创建新的 fiber。

### 多结点diff的例子
liA,liB,liC,liD,liE,liF  => liA,liC,liE,liB,liG,liD
 0   1   2   3   4   5       0   1   2   3   4   5

1. 同时遍历新老结点，liA=>liA 复用，liB=>liC key 不同跳出，进入`处理移动`的环节。
2. 将老 liB 以后的所有老结点放入 Map, 遍历剩余的新结点。
3. lastPlacedIndex 设置为0，在 Map 中查找新结点 liC，发现有可以复用的结点，于是复用，同时更新 lastPlacedIndex 为 oldLiC.index = 2。
4. 继续遍历新结点，liE 可复用，而且 oldLiE.index >= lastPlacedIndex，没有移动，无需标记，更新 lastPlacedIndex 为 oldLiE.index = 4。
5. 继续遍历新结点，liB 可复用，但此时 oldLiB.index < lastPlacedIndex，说明 liB 移动了，标记 `Placement`。
6. 继续遍历新结点，liG 不在老结点中，标记`Placement`。
7. 继续遍历新结点，liD 可复用，oldLiD.index < lastPlacedIndex, 标记 `Placement`。 

                 A        B       C              D                 E               F   
                 A        C       E              B                 G               D
                复用     复用     复用         复用(移动)          不可复用(插入)    复用(移动)
lastPlaceIndex   0        2       4              4                 4               4
                >=       >=      >=    oldIndex < lastPlacedIndex       oldIndex < lastPlacedIndex

### 资料
前端与黑客安全  01:24:52
Electron+游戏引擎+前端黑客与安全 00:10:41  Dom Diff: vue vs react


# fuseEffect 和 fcomponentDidMount 有什么不同？
useEffect 的回调函数 create 会在 commit 阶段结束后，异步执行。
componentDidMount 会在mutation阶段完成视图更新后，在layout阶段同步执行。

这道题在探讨的其实是 useEffect 的 create 函数 fn 与 cDM 的执行时机有什么不同，而 fn 的执行依赖于 useEffect 的第二个参数 deps。所以这道题可以概括为2个问题：
1 deps 如何影响 fn 的执行？
2 fn 和 cDM 的执行时机？

* 第1个问题
useEfffect的标记是 Passive。
useEffect(fn)      每次组件更新，都会打标记
useEffect(fn,[])   只有mount 会打标记
useEffect(fn, deps) 只有mount时，或deps里的元素改了才会打标记

class 组件会在 mount时标记 Placement。

- Placement结点
在 mutation阶段调用 appendChild方法，然后在 layout 阶段调用 cDM方法。
- Passive 结点
在 layout 阶段结束后，异步调用 useEffect的create函数。

* 第2个问题
useEffect的回调函数create 会在commit 阶段结束后异步执行
cDM会在mutation阶段完成视图更新后，在layout阶段同步执行。

useLayoutEffect 和 cDM 的调用时机一致。


==============================fWebpack==============================
# fwebpack生命周期 f工作流程 f构建流程
1. 初始化参数
从配置文件和 shell 语句中读取与合并参数，得出最终的参数。
2. 开始编译
用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始编译。
3. 寻找入口
根据 entry 找到所有 入口文件。
4. 编译模块
从每个入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 输出资源
根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。
6. 写入磁盘
在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
在以上过程中，webapck 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，从而可以改变 webpack 的运行结果。

# fchunk
1. chunk 是 webpack 打包过程中，一系列关联 module 的集合。比如有 3 种方式可以产生 chunk:
*入口 chunk*
webpack 从入口模块开始打包，入口模块引用其他模块，模块再引用模块，从入口开始的一系列模块，就形成了一个 chunk，多个入口就有多个 chunk。
*按需加载*
按需加载的模块，比如 import(..), 也会产生 chunk。
*代码分割*
在 webpack 中配置代码分割，会产生 chunk。
2. chunk 在构建完成时，就呈现为 bundle，一般来说，一个 chunk 对应一个 bundle。但是也有例外，比如 devtool 设置为 source-map 时，一个 chunk 会打包出 2 个 bundle，一个是 main.js，一个是 main.js.map, chunk 是过程中的代码块，bundle 是结果的代码块。
## f入口chunk
下面的例子会生成 2 个 chunk, 使用 entry 的 key 命名，所以一个叫 pageA, 一个叫 pageB。
```js
module.exports = {
  entry: {
    pageA: ...,
    pageB: ...,
  },
  output: {
    filename: '[name].bundle.js'
  }
}
```
## f按需加载
在代码中使用 import(...)按需加载代码，在 webpack 配置中使用 output.chunkFilename 为异步加载的 chunk 命名。
```js
module.exports = {
  entry: ...,
  output: {
    ...,
    chunkFilename: '[name].async.bundle.js'
  }
}
```
## f代码分割 fwebpack代码分割
配置 splitChunks 可以将 entry, 异步 chunk 等 chunk 进一步分割，产生更多 chunk。
```js
module.exports = {
  optimization: {
    splitChunks: {
      ....
    }
  }
}
```

# fTreeShaking f摇树优化
Tree-Shaking 是一种基于 ES Module 规范的 无用代码清除(Dead Code Elimination) 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。
## f开启TreeShaking  f在 webpack 中开启 TreeShaking
1. 使用 ESM 规范编写模块代码。
2. 配置 optimization.usedExports 为 true，启动标记功能。
3. 启动代码优化功能，可以通过如下方式的任意一种实现:
  - 配置 mode = production
  - 配置 optimization.minimize = true
  - 提供 optimization.minimizer 数组
例如, 在 webpack.config.js 中:
```js
module.exports = {
  entry: "./src/index",
  mode: "production",
  devtool: false,
  optimization: {
    usedExports: true,
  },
};
```
## fES6模块特点 fESM规范
1. 只能作为模块顶层的语句出现。
2. 导入导出的模块名只能是字符串常量。
3. 导入的值是不可变的。
以上三点，决定了 ESM 是完全静态的，跟运行时无关，所以可以在编译时，从代码字面量中就推断出哪些模块值未被使用，这是实现 Tree Shaking 技术的必要条件。
```js
// index.js 主模块
import {bar} from './bar';
console.log(bar);  // 仅使用了 bar, 没有使用 foo
// bar.js 模块
export const bar = 'bar';
export const foo = 'foo';   // foo 未被使用, 会被视作无用代码而删除。
```
## f原理 fTreeShaking原理
Webpack 中，Tree-shaking 分为两步:
1. 第一步、先标记出模块导出值中哪些没有被用过。
2. 第二步、使用 Terser或UglifyJS 等 DCE工具 删掉这些没被用到的导出语句。
标记过程大致可划分为三个步骤:
  - Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中。
  - Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用。
  - 生成产物时，若变量没有被其它模块使用则删除对应的导出语句。

🌰例子
```js
{
  // bar 模块
  "./src/bar.js":  ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.d(__webpack_exports__, {
      "bar": () => (/* binding */ bar)
      // 这里就没有导出 foo，因为根本没用到。
      // 后面 Terser 插件的 DCE 功能，会把 const foo = 'foo' 摇掉。
    });
    /* unused harmony export foo */
    const bar = 'bar';
    const foo = 'foo';
  })
}
```

# f缓存 fwebpack缓存
1. cache-loader
2. hard-source-webpack-plugin
3. babel-loader
## hard-source-webpack-plugin
模块解析的阶段，用于中间的缓存。
第一次是正常的构建速度，但是会保存缓存数据到 xxx 里。
第二次使用缓存来构建，速度提升。
## babel-loader
运行以后，会增加 node_modules/.cache/babel-loader 这个文件夹，存放缓存的文件
```js
{
  loader: 'babel-loader',
  options: {
    cacheDirectory: true // 开启缓存
  }
}
```

# f热更新🔥 fdevServer
安装 webpack-dev-server, 然后在开发环境下配置:
```js
devServer: {
  contentBase: join(__dirname, '../dist'),
  hot: true,
  port: 3000
}
```
TODO: 原理

## f系统级通知
按下 Ctrl+S, 无需查看 terminal, 系统会通知你成功/失败。只需安装 webpack-build-notifier, 配置插件:
```js
plugins: [
  new WebpackBuildNotifierPlugin({
    title: "My Webpack Project",
    logo: path.resolve("./img/favicon.png"),
    suppressSuccess: true,
  })
]
```
