# 目录
* 框架 (主React, 副Vue)
* 设计模式 (观察者模式、策略模式等)
* 工程化 (Webpack, Git)
* 性能优化
* 服务端 (Node.js)

============================================== f设计模式 ==============================================
# 平时工作中有用到哪些设计模式？
TODO: 
1.单例模式 继哥写的基础库？ redux的store
2.观察者模式 redux的subscribe和dispatch (如果面试官要求举出更多例子，再讲 Vue的Watcher订阅和Data发布)

# f单例模式
单例模式即一个类只能构造出唯一的实例，单例模式的意义在于共享、唯一。
## 例子
Redux 的 store。 (如果面试官要求举出更多例子，再讲 Vuex的store, JQ的$, 业务场景的购物车🛒等)
## 代码
```js
class Singleton {
  constructor(name) {
    this.name = name;
  }
  static getInstance(name) {
    if (!this.instance) {
      this.instance = new Singleton(name);
    }
    return this.instance;
  }
}
const instance1 = Singleton.getInstance('name1');
const instance2 = Singleton.getInstance('name2');
console.log(instance1 === instance2);  // true，只有一个实例
console.log(instance1.name);  // name1
console.log(instance2.name);  // 依然是 name1
```

# 工厂模式
工厂模式即对创建对象逻辑的封装，或者可以简单理解为对new的封装，这种封装就像创建对象的工厂，故名工厂模式。
## 例子
工厂模式常见于大型项目，比如JQ的$对象，我们创建选择器对象时之所以没有new selector就是因为$()已经是一个工厂方法，其他例子例如React.createElement()、Vue.component()都是工厂模式的实现。
## 代码
```js
class User {
  constructor(name, auth) {
    this.name = name;
    this.auth = auth;
  }
}
class UserFactory {
  static createUser(name, auth) {
    // 工厂内部封装了创建对象的逻辑。
    // 使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和一个普通用户。
    if (auth === 'admin') {
      return new User(name, 1);
    }
    if (auth === 'user') {
      return new User(name, 2);
    }
  }
}
const admin = UserFactory.createUser('boss', 'admin');
const user = UserFactory.createUser('mike', 'user');
```

# 观察者模式
观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。
## 例子
Redux的subscribe和dispatch。
## 代码
```js
// 观察者
class Observer {
  constructor(fn) {
    this.update = fn;
  }
}
// 被观察者
class Subject {
  constructor() {
    this.observers = [];
  }
  register(ob) {
    this.observers.push(ob);
  }
  notify() {
    this.observers.forEach((ob) => {
      ob.update();
    })
  }
}
const ob1 = new Observer(() => console.log('ob1 update!'));
const ob2 = new Observer(() => console.log('ob2 update!'));
const ob3 = new Observer(() => console.log('ob3 update!'));
const subject = new Subject();
subject.register(ob1);
subject.register(ob2);
subject.register(ob3);
subject.notify();
```

# f装饰器模式
装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7的装饰器语法以及React中的高阶组件（HOC）都是这一模式的实现。
## 代码
```js
// ES7的装饰器
function Info(target) {
  target.prototype.name = 'mike';
}

@Info
class Man {}

const man = new Man();
console.log(man.name);  // info
```

# f适配器模式
适配器模式，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题。
## 代码
```js
class Adaptee {
  test() {
      return '旧接口';
  }
}
class Target {
  constructor() {
      this.adaptee = new Adaptee()
  }
  test() {
      const info = this.adaptee.test()
      return `适配${info}`;
  }
}
const target = new Target()
console.log(target.test());
```

# f代理模式
代理模式，为一个对象找一个替代对象，以便对原对象进行访问。即在访问者与目标对象之间加一层代理，通过代理做授权和控制。
## 例子
最常见的例子是经纪人代理明星业务，假设你作为一个投资者，想联系明星打广告，那么你就需要先经过代理经纪人，经纪人对你的资质进行考察，并通知你明星排期，替明星本人过滤不必要的信息。事件代理、JQuery的$.proxy、ES6的proxy都是这一模式的实现。
## 代码
```js
const idol = {
  name: 'mike',
  phone: 10086,
  price: 1000000
}
const agent = new Proxy(idol, {
  get: function(target) {
    //拦截明星电话的请求,只提供经纪人电话
    return '经纪人电话:10010'
  },
  set: function(target, key, value) {
    if(key === 'price' ) {
      //经纪人过滤资质
      if(value < target.price) throw new Error('报价过低')
      target.price = value
    }
  }
})
agent.phone        //经纪人电话:10010
agent.price = 100  //Uncaught Error: 报价过低
```


============================================== f工程化 ================================================
# fGit
Git是一个免费的、开源的分布式版本控制系统，旨在以快速高效的方式处理从小型到大型的所有项目。
Git易于学习、占用空间小、性能极快。它具有方便的工作区、暂存区、本地库和多个工作流分支等特性。

## 架构
远程库
⬆️git push(推送给远程), ⬇️git pull(拉取更新), ⬇️git clone(初始化到本地), ⬇️git remote add <远程别名>（如 origin） <远程链接>(本地已经有项目，添加一个远程库)
本地库
⬆️git commit(提交，生成一个历史版本), ⬇️git branch <分支名>(增加分支), ⬇️git checkout (切换分支), ⬇️git log/git reflog(查看提交日志)
暂存区
⬆️git add(添加到暂存区), ⬇️git restore --stage <file>(取消添加)
工作区   

## 本地库结构
-------- commit1 ----------- commit2 -------- commit3  ---------------- commit 4 -----------------------   分支一
            |                                                                      | 合并给分支一
            -------- commit1 --------------------------------   分支二              |
                              |                                                    | 分支三可以继续走，无影响
                              ------- commit 1 ------------------------------------|-------- 分支三 

### 分支
多个分支是本地库中的多个工作流，每个分支独立管理自己的提交历史。

当前所在的分支，是由 HEAD 决定的。
master,hot-fix 这两个分支其实是两个指针，HEAD 指向谁，谁就是当前分支，切换分支的本质就是改变 HEAD 指向。

#### 例子
两个分支，每个分支有独立的提交历史:
first ---- second  ---- third --- fourth ----- fifth  [master]   
                          |
                        third --------- fourth        [hot-fix]   <= HEAD (当前分支是 hot-fix)
 
#### 优点
同时并行推进多个功能开发，提高开发效率。
各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支造成影响。失败的分支删除了，重新开始即可。

git branch <分支名>: 增加分支
git branch: 查看本地库的分支，以及当前处在哪个分支上
git checkout <分支名>: 切换分支  (改变HEAD指向)
git reflog: 查看所有分支的提交历史

#### 合并冲突的分支
在当前分支下，合并其他分支的修改。(注意合并只会影响当前分支的内容，对其他分支毫无影响)

##### 背景
合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改，Git无法帮我们作出决定，这时就有冲突。
冲突发生时，需要人为决定新代码的内容。

#### 步骤
1. 执行合并
git merge <其他分支>

```shell
Auto-merging test.md  // 正在自动合并 test.md...
CONFLICT (content): Merge conflict in test.md   // test.md 里有合并冲突
Automatic merge failed; fix conflicts and then commit the result.   // 自动合并失败
```

2. vim test.md 查看冲突文件
<<<HEAD
<当前分支的代码>
======
<要合并进来的分支的代码>
>>>>> hot-fix

3. 手动修改
修改`<<<HEAD`和`======`中间的内容，留下你要的部分，然后把分割线删掉。

4. 保存
wq, git add, git commit, 完成以后，`其他分支`的修改就合并到`本分支`了。


## 分支内版本穿梭 (回到某一个提交历史)  f版本穿梭
回到某一个提交历史，作出修改后，再提交到最新修改的后面。 实现回到过去，逆转现在!

first ---- second  ---- third --- fourth ----- fifth                当前在 fifth 提交
                                              [master]

first ---- second  ---- third --- fourth ----- fifth                回到 third 提交
                      [master]       

first ---- second  ---- third --- fourth ----- fifth ---- sixth     基于 third 修改，提交 sixth
                                                        [master]                
### 命令
git reset --hard [commitCode]


## git frebase vs git fmerge
git rebase:  找到当前分支和目标分支的交叉点，交叉点到当前分支尾的部分拆出来，合到目标分支的末尾，也就是合成一条 commit 线。
git merge: 新建一个 commit 结点，两个分支末尾都指向这个新的 commit 结点。

 

# fRedux fredux
Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 

Redux 可以用这三个基本原则来描述:
1. 单一数据源
整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。
这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，你可以把应用的 state 保存在本地，从而加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。

2. State 是只读的
唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。
这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。

3. 使用纯函数来执行修改
为了描述 action 如何改变 state tree ，你需要编写 reducers。
Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分，因为 reducer 只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的 reducer 来处理一些通用任务，如分页器。

## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/redux

### fcreateStore.js
观察者模式: 订阅、取消订阅、发布。
```js
export default function createStore(reducer, initState, rewriteCreateStoreFunction) {
  if (rewriteCreateStoreFunction) {
    const newCreateStore = rewriteCreateStoreFunction(createStore);
    return newCreateStore(reducer, initState);
  }

  let state = initState;
  let listeners = [];

  function subscribe(listener) {
    // 订阅
    listeners.push(listener);
    // 取消订阅
    return function unsubscribe(listener) {
      const index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    }
  }

  function getState() {
    return state;
  }

  function dispatch(action) {
    // 通知用户定义的 reducer 得到新的状态
    state = reducer(state, action);
    // 发布 
    // 无论哪个小状态变化，都将全量通知
    for (let i = 0, len = listeners.length; i < len; i++) {
      const listener = listeners[i];
      listener();
    }
  }

  // 执行所有的 reducer，使得 `以reducer为key的每个store`，在总状态里初始化。
  // 使用 symbol 避免和用户的 action.type 重名
  dispatch({ type: Symbol('__init_store__') });
  /**
   * 实现一个 Symbol?
   * 
   * function MySymbol(name) {
   *    const obj = Object.create({
   *      toString: function() {
   *         return name;
   *      }
   *    })
   *    return obj;
   * }
   */

  function replaceReducer(nextReducer) {
    reducer = nextReducer;
    dispatch({ type: Symbol('__init_store__') });
  }

  return {
    subscribe,
    getState,
    dispatch,
    replaceReducer,
  }
}
```




### fcombineReducer.js
组合用户所有的 reducer，每个 reducer 维护自己的那份 state (totalState[key])，但是每次更新都会创建一个全体的新的 state 返回。
如果确实没有变更，(非常少见，比如发了一个所有 reducer 都不受理的 action)，才会返回之前的 state 引用。
```js
export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);

  // 最后合并好的 reducer
  return function combine(state = {}, action) {
    // 所有的 action, 都是执行这个 combine 函数，改变自己的 state (state[key])，返回整体的 state 中，最后改变整体的 state (引用)。
    const nextState = {}
    // 遍历所有 reducer
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      const reducer = reducers[key];  // counterReducer, infoReducer
      // 某个 reducer 的旧库
      const prevStateForKey = state[key];
      // 执行动作，状态改变，得到该 reducer 的新库
      const nextStateForKey = reducer(prevStateForKey, action);
      // reducer的key和state的key要保持一致
      // 该 reducer 的保存到一份新的总状态里
      nextState[key] = nextStateForKey;
    }
    return nextState;
  }
}
```


### fapplyMiddleware.js  f中间件原理 (中间件们把store.dipatch作为`🧅的最内核`包裹起来)
redux的中间件原理是:
1. 先把 store 传入每一个中间件，它们都返回一个函数，这个函数接受一个next函数，返回另一个函数，如 `(next) => (action) => {...}`
2. 把这些函数通过 compose 组合起来，得到一个总体的函数，也是接受一个next函数，返回另一个函数: `(next) => ex(time(log(next)))`
3. 把 `store.dispatch` 作为 `next` 参数，传给这个函数，执行，最终返回一个符合洋葱模型🧅的函数，洋葱模型最内层就是原始的 store.dispatch:
`(action) => { ex1(next前),  time1,log1,store.dispatch,log2,time2 (next),  ex2(next后)  }`

如果传入的顺序是 applyMiddleware(左1,左2,左3),  那么最终的执行顺序是 左1,左2,左3,store.disptach,左3,左2,左1。

```js
// dispatch 的时候，依次执行所有的 middleware。
const applyMiddleware = function (...middlewares) {

  // 返回这个函数，给 createStore.js 里的 rewriteCreateStoreFunction 调用，再返回一个新的 createStore 函数
  return function (oldCreateStore) {

    // 这个玩意儿是新的 createStore 函数，把中间件嵌入到 dispatch 流程中。
    return function (reducer, initState) {
      const store = oldCreateStore(reducer, initState);
      const simpleStore = { getState: store.getState };

      // 中间件先依次执行一遍，转成 (next) => xxx, 结果放到链中，形成数组
      // 每一个 middleware 变成一个 m(simpleStore) 的执行结果 ----> 一个函数: (next) => (action) => {...}
      // [
      //  (next) => (action) => {...log...}, 
      //  (next) => (action) => {...exception...},
      //  ...
      // ]
      const chain = middlewares.map(m => m(simpleStore));
      // 现在中间件已经变成了 (next) => (action) => xxx 这个鬼样子,
      // 然后 compose 从右到左把中间件组合起来:
      // ex, time, log 三个转成 (next) => .. 的中间件，变成 (...args) => ex(time(log(...args))) 

      // 传入 store.dispatch 执行，返回 ex(time(log(store.dispatch))) 的执行结果, 执行过程是:

      // 1. log 中间件 ”(next) => (action) => xxx“ 执行，返回一个函数，作为 next 给 time 中间件
      // ex(time(   (action) => {..log1..., store.dispatch, ..log2...}       ))

      // 2. time 中间件执行，返回一个函数，作为 next 给 exception 中间件
      // ex(   (action) => {..time..}   )

      // 3. 最后返回一个函数，给 dispatch
      // (action) => { 错误处理(next之前)...,  time中间件执行传过来的函数(action) => {...} (next),  xxx(next之后)  }

      // 所以，在 dispatch 的时候，中间件根据传入 applyMiddleware 的顺序，从左往右，按洋葱模型🧅执行。(左1,左2,左3,store.disptach,左3,左2,左1)
      const dispatch = compose(...chain)(store.dispatch);

      console.log('dispatch', dispatch);

      return {
        ...store,
        dispatch
      }
    }
  }
}
export default applyMiddleware;
```

### fbindActionCreators.js
把所有创建 action 的函数集中到一个对象上，使用时可以直接调用。
比如 const actions = bindActionCreators({ Add, setName }, store.dispatch);  
使用时 actions.Add(); 相当于 store.dispatch({ type: 'ADD' });
```js
/**
 * @param {Function} actionCreator 用户定义的 action 函数，比如 setName 函数。
 * @param {Function} dispatch store.dispatch
 */
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(null, arguments));
  }
}
export default function bindActionCreators(actionCreators, dispatch) {
  const b = {};
  // 把所有创建 action 的函数集中到一个对象上，使用时可以直接调用。
  // for..in  遍历所有可枚举属性，它会把原型上的属性也找出来，只不过 Object.prototype 上的属性是不可枚举的，所以没出来。
  for (const key in actionCreators) {
    const action = actionCreators[key];
    if (typeof action === 'function') {
      b[key] = bindActionCreator(action, dispatch);
    }
  }
  return b;
}
```

## fcompose.js
从右往左组合函数，比如 compose(f, g, h) 返回一个函数: (...args) => f(g(h(...args)))
```js
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg
  }
  if (funcs.length === 1) {
    return funcs[0]
  }
  // a 相当于之前所有组合好的函数, b 是本次要组合的函数, 
  // 比如: (f(g(...args)), h) => (...args) => f(g(h(...args)))
  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

# fRedux-Toolkit fredux-toolkit fToolkit
redux 官方推荐的工具集，比 redux 更加轻量。最佳实践。

# react-redux
`react-redux`是将`Redux store`和`React UI`相结合的`官方绑定层`。
它使 react 组件可以从 redux store 读取数据，也可以向 store 发起 action 以更新状态。
基于 context API 封装。
## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/react-redux (【手写源码系列】40分钟带你从0到1实现一个react-redux)


# fRecoil frecoil f原子化
Recoil 是 React 的状态管理库，只能用在 React 里边。
## 目标
redux太复杂, 得创建 store, reducer, action, ..., 和 react 合起来还得创建 react-redux。项目复杂时，会有多层 Provider 树🌲.
因此，Recoil的目标是: 最小化state，不要有包装，不要多层次的Provider。
## 核心
原子状态变化(text) -> 衍生状态变化(text.length) -> 视图更新。
## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/recoil  (前端中的数据结构和算法2)

# fvuex
大垃圾 只有一个文件 也是基于 redux。


# f状态优化
https://github.com/ronnycyy/state-manager/tree/main/react
两点原则:
1. 将变的和不变的分离。
2. 将`引用比较`改为`浅比较`。

## 将变的与不变的分离
适用于: 父组件的state可分离给子组件。
将state变化的子组件从父组件中抽离出来, 使子组件单独渲染，而不影响父/兄弟组件。
```js
function App() {
  console.log('App render~');
  return (
    <div>
      <h1>将变的部分和不变的部分分离</h1>
      {/* 抽离了变的部分，现在只是 Input 组件重新渲染 Expensive 不会 render 了 */}
      <Input />
      {/* beginWork 中取得 newProps 和 oldProps，判断是相等的 */}
      <Expensive />
    </div>
  );
}
function Input() {
  console.log('Input render~');
  const [text, setText] = useState('');
  // 协调阶段:  App -> div -> h1 -> Input(执行) -> Expensive (深度优先遍历)
  // 前面都对比对比, 没变化没变化,  bailout bailout..., 直到 Input, 发现前后 state 不一致，于是执行。 
  // App 被 bailout 了，不会执行的!  "App render~" 不会打印。
  return (
    <Fragment>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
    </Fragment>
  )
}
// 这个组件每次渲染都要花费至少100ms
function Expensive() {
  console.log('Expensive render~');
  let now = performance.now();
  while (performance.now() - now < 100) { }
  console.log('耗时的组件render');
  return <p>耗时的组件</p>
}
```
## 将`引用比较`改为`浅比较`
适用于: 父组件的state不可分离。
父组件state变化，导致本来不用变化的子组件也跟着重新渲染，为了避免这种情况，应在父组件外部使用 React.memo 包裹子组件，再引入到父组件。
```js
// 在父组件外层包裹，这样 Input 执行时就不会影响。
const MemoUnderInput = React.memo(UnderInput);
function Input() {
  console.log('Input render~');
  const [text, setText] = useState('');
  return (
    <Fragment>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
      {/* <UnderInput /> */}
      {/*
        React.memo 默认情况下会对复杂 props 对象做浅比较。(比如 shallowEqual({},{}) === true, 这两个空对象如果用引用比较结果是false)
        所以不是引用比较了，那么就不会受 Input 影响重新执行，而是不执行。
      */}
      <MemoUnderInput />
    </Fragment>
  )
}
```

# 前端状态管理库的对比
Redux `时间旅行`的理念非常经典，由这个理念发展出了很多状态管理库。
应该怎么选择 React 状态管理库？从两个角度说:
1. 项目规模
2. 项目类型

## 项目规模
1. 很小的项目，玩具项目，没必要用库了，直接 context API 就行。
2. 大一丢丢的项目，但还是一个人写的，比如短期的活动页，可以用一些迷你的库，比如 unstated(基于context封装)
3. 再大一点，需要几个小伙伴合作的，就可以用 dva, mobx, jotai, recoil 等基于`原子状态`理念的。

## 项目类型
1. 普通的后台管理页，要填很多表单 => 双向数据绑定 => 适合用 mobx。
2. 富文本编辑器，我需要完成 `撤销/重做` 这样的功能，那就适合用 redux 系列的`时间旅行`的库。


==============================  fReact  ==============================
# fsetState是同步还是异步  fthis.setState是同步还是异步
在`React`的不同模式下，`this.setState`有不同的表现:
1. 在 legacy 模式下，如果命中了 batchedUpdate 逻辑，就是异步，如果没有命中 batchedUpdate 逻辑就是同步。
2. 在 concurrent 模式下，this.setState 始终表现为异步。

# f防止子组件重新渲染 f性能优化
1. React.memo(function SonComponent() {}, function areEqual(prevProps, nextProps) {...})
2. useMemo(() => <>{...SonComponent}</>, [])
3. PureComponent 浅比较 更新前后的props 和 更新前后的state
4. shouldComponentUpdate(nextProps, nextState)

在 React 中，控制组件是否渲染有三个方面: props, state 和 context, 只要这三者都不变，组件就不会渲染。
如果是父组件引起的子组件渲染，也就是说子组件的 state 和 context 都不变，那么只需要控制 props 不变即可。但是 React 的默认 props 比较策略是`引用比较`，而且每次更新 props 都是一个全新的对象，那么即使更新前后 props 的属性没有任何改变，子组件也会重新渲染。
这时候就要将`引用比较`改为`浅比较`，使用 React 的性能优化 API，如 React.memo, useMemo, PureComponent, shouldComponentUpdate。
## fmemo fReact.memo  React.memo(ReactComponent, arePropsEqual)
React.memo 是一个高阶组件，它接收一个 React 组件，如果这个组件的 props 在更新前后`浅比较`不变，则组件不必重新渲染。
如果想控制比较过程，可以将自定义的比较函数传入 React.memo 的第二个函数 areEqual, 它会得到 prevProps 和 nextProps，如果 props 比较相等返回 true, 那就不会重新渲染; 如果比较不等返回 false，就会重新渲染。
## fuseMemo  fuseMemo(create, deps)
useMemo接收两个参数，第一个是create函数，第二个是deps数组，返回值是create函数首次执行的结果。当 deps数组里的所有依赖项都没有改变时，每次执行useMemo都返回一样的缓存值。而当任意一个依赖项发生改变时，会重新执行create，得到的结果作为useMemo的新的缓存值返回。
useMemo的缓存值是绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在。
我们可以把子组件作为 create 的返回结果放入 useMemo，同时传入空的 deps 数组，这样父组件重新渲染时，子组件就不会重新渲染。
## fPureComponent   class Component extends React.PureComponent
以浅比较更新前后的 prop 和 state 的方式来实现了 shouldComponent。
## fshouldComponentUpdate
shouldComponentUpdate(nextProps, nextState), 返回一个布尔值，决定类组件是否重新渲染。

# fhooks
## 讲概念
Hook 是 React 16.8.0 的新增特性。它让函数组件也能做类组件能做的大部分的事，通过hooks函数组件有了自己的状态，可以处理副作用，能获取 ref 等。
## 说用途 (f解决了什么问题 f问题)
* 在组件之间复用状态逻辑
使用 Hook 可以从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。这使得在组件间或社区内共享 Hook 变得更便捷。
* 组合复杂组件的相关逻辑
在 hook 之前我们常常在组件的生命周期中编写一些不相关的代码，比如在 componentDidMount 中获取数据，同时又设置事件监听，然后在 componentWillUnmount 中清除，这样就把不相关的代码组合在一起，而相关的代码又分在了不同地方，这种写法很容易引起 bug。
为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。
* 拥抱函数式编程
根据官网的描述, 编写 class 的方式使得代码不能很好地压缩，并且会使热重载出现不稳定的情况。为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性, 比如维护状态，处理副作用，获取ref等。这样就能用函数组件替代大部分类组件，拥抱函数式编程。
`官网: 我们准备让 Hook 覆盖所有 class 组件的使用场景，但是我们将继续为 class 组件提供支持。`
## 优缺点

## f原理 fhooks原理 f你来聊一下hooks的原理是什么
从数据结构的角度说，hooks是一条单向链表，存在于fiber.memoizedState，当然这个fiber得是函数组件的fiber，通过 next 指针将本函数组件的所有 hook 顺序连接到一起:`fiber.memoizedState: hook1 -> hook2 -> ...`。

函数组件 render 时，分为 首次执行 和 更新 两种情况。以 useState 为例, `首次执行`做的是生成 hook 加入到 fiber.memoizedState, 返回初始值和更新函数也就是dispatchAction; 而`更新`是执行 dispathAction，本质上就是创建 update 对象，加入到 hook.queue.pending;

两种情况都会依次执行 hook, 计算每个 hook 的状态，放到 hook.memoizedState 中。状态计算是基于 hook.queue.pending 这条环状链表，链表上的每个结构都是一个 Update 对象，update 上保存着用户传入的action, 比如 setCount(c => c + 1), 其中的 c => c + 1 这个箭头函数就是 action。 Hook 会基于 hook 原有的 memoizedState，然后执行一圈的环状链表上的 Update 对象，最终得到新的 memoizedState 返回。
```ts
interface Hook {
  baseQueue: null;
  baseState: unknown;  // 基于某个状态，计算本次 memoizedState
  memoizedState: unknown;   // 本 hook 的状态值
  next: Hook;  // 下一个 hook
  queue: Update;  // hook 上的 Update 对象
}
interface Update {
  action: Function | unknown;  // 如 c=>c+1
  next: Update;  // 指向下一个 update 对象
}
```
## fuseEffect feffect
React 在完成对 DOM 的更改后运行“副作用”函数。原理是在 commit 阶段结束后异步执行。
## fuseLayoutEffect
在 commit 阶段结束时同步执行。
## f使用hooks的注意事项
1. 约定命名以useXX开头
2. 必须在函数组件内使用，不能在类组件里使用
3. 必须在函数组件作用域顶部使用
4. 每次组件render不能打乱hooks的执行顺序，比如放到条件语句、或循环语句中是不行的。
## 为什么hook不能放在条件语句中
每次App更新的时候，hooks都必须遵照完全一样的顺序，因为它们是保存在一条链表中的，更新的时候只会按链表顺序更新。如果打乱了顺序，链表结点和组件hook的对应关系就会出错。
## fuseState发生了什么
基于这个useState代表的hook的hook.memoizedState，遍历 hook 的 update 环: hook.queue.pending，顺序执行所有的update，上一个的输出作为下一个的输入，一直计算到最后，得到最终的state，作为新的hook.memoizedState，清空本hook的update环，返回一个数组，数组的第0项是更新后的状态，第1项是dispatch, 然后更新函数组件。
## fsetNum发生了什么
setNum -> 放置update对象到hook上(多次setNum就有多个update对象，形成一个环)App重新render -> 执行 useState -> 得到新状态num -> 基于新状态得到新的ReactElement -> 渲染新视图
## fhook相关属性
fiber.memoizedState是 hook
hook.memoizedState 是当前 hook 的状态
hook.next 是下一个hook
hook.queue.pending 是最后一个 update，下一个就是第一个 update。
update.next是下一个update
update.action是待更新的操作，如 num => num+1

## f自定义hooks fReact如何封装自定义hooks
自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。
自定义 hook 的 state 是完全独立的，hook 的每次调用都有一个完全独立的 state，因为在同一个组件中多次调用同一个自定义hook，它们的状态也互不影响。
### f自定义hooks必须以"use"开头吗？
必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。
### f自定义hooks的用途
自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题。

## f高阶组件 fHOC
高阶组件是一个函数，以React组件为参数，经过一系列逻辑，返回一个新的组件。
`const EnhancedComponent = higherOrderComponent(WrappedComponent);`
高阶组件不会修改传入的组件，它是通过将组件包装在容器组件中来组成新组件，高阶组件是纯函数，没有副作用。
### 例子
react-redux 的 connect 函数。

# f事件机制 fReact事件机制
1. React并不是将事件回调绑定到真实的DOM上，而是在根结点处监听所有的事件。在 v17 之前，React 事件是绑定在 document 上的，v17 以后事件绑定到了应用对应的容器结点上(#root)。
2. React 实现了自己的一套事件捕获和事件冒泡机制，当事件发生并且冒泡到根结点t处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。
3. React 的事件并不是原生事件，而是 React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。
## f为什么要有事件系统
有两点原因，一是兼容不同浏览器，二是为了统一管理。
1. 对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架， 为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。
2. v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。
## f合成事件
React 应用中，元素绑定的事件并不是原生事件，而是 React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。
### 优点
- 兼容所有浏览器，更好的跨平台；
- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。
- 方便 react 统一管理和事务机制。
## fReact事件 vs f原生事件
1. 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；
2. 对于事件函数处理语法，原生事件为字符串，react 事件为函数；
3. react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用`preventDefault()`来阻止默认行为。
## f事件捕获 f事件冒泡 fReact是如何模拟事件捕获和事件冒泡的
当事件触发时，React会从当前fiber向上遍历，遇到绑定了事件的fiber时，就会用一个数组收集事件，把冒泡阶段的事件回调用push放进去，也就是插入到数组尾，而把捕获阶段的事件回调用unshift放进去，也就是插入到数组头。直到遍历到根结点。然后依次执行数组里的事件回调。
## f阻止默认行为
在React应用中，可以用`e.preventDefault()`阻止事件默认行为，但不能用类似原生事件的`return false`来阻止。
这是因为在 React 中给元素的事件并不是真正的事件处理函数，导致`return false`方法在 React 应用中失去了作用，preventDefault 也是单独处理的。

# ffiber fReact为什么需要fiber?
## f什么是Fiber
Fiber 包含三层含义: 协调器的架构、静态的数据结构、动态的工作单元。
1. 架构
作为协调器的架构来说，之前 React15 的协调器采用递归的方式执行，数据保存在递归调用栈中，所以被称为 stack reconciler。
而 React16 的协调器基于 Fiber 结点实现，被成为 fiber reconciler。
2. 数据结构
作为静态数据结构来说，每个 fiber 结点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
3. 工作单元
作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

## f纤程
Fiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。

Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。

React Fiber可以理解为:
React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。其中每个任务更新单元为React Element对应的Fiber节点。

## f为什么需要fiber
React 在 16 版本之前，用的是`递归`的方式更新组件，这是一个同步的更新，一旦开始就无法中断，如果这一次更新超过了浏览器一帧的时间，一般是 16 ms，用户交互就会卡顿。显然这不满足 React 快速响应的理念，所以 16 版本以后 React 提出了新的 fiber 架构，用`异步可中断的更新`替代`同步的更新`。

## ffiber解决了哪些问题
1. 解决了 React15 同步更新造成的用户卡顿问题
2. 支持高优先级任务插队低优先级任务
3. 任务中断以后可以恢复，复用之前的中间状态

## f架构 fReact的架构 16之前是什么架构？16之后是什么架构？为什么这么演变？
16 之前，React 只有 协调器 和 渲染器; 16 之后，React 有 调度器、协调器、渲染器。
各模块功能如下:
* 调度器: 调度任务的优先级，高优任务优先进入协调器。
* 协调器: 负责找出变化的组件。
* 渲染器: 负责将变化的组件渲染到页面上。
### Scheduler
Scheduler 是 React 团队为 requestIdleCallback 做的 polyfill,  因为 rIC 有以下缺点:
1. 浏览器兼容性不好;
2. 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低。
### Reconciler
Reconciler 从递归的方式，变为可中断的循环方式，每次循环都会调用 shouldYield(), 如果当前有剩余时间才继续，没有就中断循环。
* 那么React16是如何解决中断更新时DOM渲染不完全的问题呢？
在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记。整个Scheduler与Reconciler的工作都在内存中进行，不展示到视图上。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer，渲染视图。
### Renderer
Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。


# f虚拟DOM fvdom fVirtual DOM
虚拟DOM本质上就是一个对象，该对象描述了一个UI结点所对应的一些必要信息。React 的虚拟DOM 可以理解为 ReactElement 和 Fiber，因为 DIFF 是比较这两者。
## 为什么需要虚拟DOM?
1. 真实DOM的属性太多了，如果直接对真实DOM进diff，消耗性能非常大。
比如，可以在控制台写 document.createElement('div') 得到一个结点，打开这个结点，会看到上面的属性非常多，如果直接做 diff，要对比这么多属性，消耗的性能就非常大。而虚拟 dom 一般就是 { type: 'div', props: {} }, 只需要对比这几个属性，性能损耗大幅降低。
2. 对真实DOM进行curd很消耗性能，可以用虚拟DOM代替。
## 说用途
1. 渲染
2. 比对 dom diff

# fDomDiff fDiff fReactDomDiff fdiff算法
Diff算法在比较`更新前虚拟dom树`和`更新后虚拟dom树`，找出两者之间的差异。React 的 DOM DIFF，是对比老 fiber (current.child) 和 新产生的 ReactElement，从而生成 workInProgress.child。
## 说用途 f为什么需要diff算法？
为了提高渲染性能，每次更新应该只渲染有变化的部分，而`diff算法`的目的就是要找出这个变化的部分。
## 制定规则
为了提高对比的性能，React 在 Dom Diff 时制定了三个规则:
1. 只比较同级元素，不跨层级对比。
2. 不同类型对应不同元素，如 div 和 span，React 不会尝试复用不同类型的元素。
3. 通过 key 来标识更新前后是同一个结点。
## 时间复杂度
时间复杂度 O(N)，N 是这一层的结点个数。因为算法本质就是遍历一次老结点，遍历一次新结点。
这个问题实际上是: 同一层上的编辑距离问题。
## 具体过程  fDomDiff的过程
React 的 Dom Diff 分为 单结点diff 和 多结点diff。这里的`单结点`或`多结点`指的是新结点，新结点只有单个就是单结点diff，新结点有多个就是多结点diff。
### 单结点diff
因为只有一个新结点，所以通过 sibling 指针遍历老结点即可，遍历过程比较新老结点的 type 和 key, 有三种情况:
1. 如果 type 和 key 都相同，说明这个老结点可以复用，标记剩余的老结点为`删除`，返回这个可复用的老结点。
2. 如果 key 相同，但是 type 不同，自己和弟弟都标记为删除，跳出遍历，直接新建一个结点，标记`插入`。
3. 如果 key 不同，删除这个老结点，继续遍历下一个老结点。如果遍历完了还是没有结点可复用，那就新建一个结点，标记`插入`。
🌰例子
比如: liA,liB,liC => liB
DIFF过程就是:  
liA => liB ❌ Deletion
liB => liB ✅ 复用
liC        ❌ Deletion
### 多结点diff
分为四步:
1. 同时遍历新老结点，处理更新 (新结点用索引:newIdx++, 老结点用指针: oldFiber = oldFiber.sibling)
2. 如果有剩余的老结点，删除多余的老结点 (deleteRemainingChildren)
3. 如果有剩余的新结点，增加新结点 
4. 处理移动的情况

* 处理移动的情况
在第一步处理更新时，可能因 key 不同而直接跳出循环，这样也跳过了二、三步，直接来到第四步处理移动。
处理移动的步骤:
1. 将剩余的老结点都放入一个 Map 中，以 oldFiber.key 或 oldFiber.index 为键，以 oldFiber本身为值。
2. 设置一个 lastPlacedIndex 变量，代表最后一个可复用的结点在 oldFibers 中的位置索引。
3. 遍历剩余的新结点，通过 newChild.key 查找 Map 中是否有可复用的老结点，可复用是指 key 和 type 都相同:
  
  * 如果有，复用老结点，然后比较 lastPlacedIndex 和 oldFiber.index，由于结点是从左往右遍历的，在没有移动的情况下，新老 index 应该同步变大，
    本次复用的 oldFiber 应该在最后一个可复用的 oldFiber 右边，也就是说 oldFiber.index 应该 >= lastPlacedIndex，但是比较结果有两种情况:

    - oldFiber.index < lastPlacedIndex, 说明 `本次复用的oldFiber` 在`最后一个可复用的oldFiber`左边，也就说明`本次复用的oldFiber`在更新后向右移动了，所以 newFiber 标记为`移动`(移动也就是Placement，在老结点存在的情况下，插入就是移动), lastPlacedIndex 不变。

    - oldFiber.index >= lastPlacedIndex, 说明 `本次复用的oldFiber` 在`最后一个可复用的oldFiber`右边，这说明 `本次复用的oldFiber` 没有移动, 本次复用的oldFiber`要作为`最后一个可复用的oldFiber`给下一轮循环的 oldFiber 作参照物，所以更新 lastPlacedIndex 为 oldFiber.index。

  * 如果没有，创建新的 fiber。

### 多结点diff的例子
liA,liB,liC,liD,liE,liF  => liA,liC,liE,liB,liG,liD
 0   1   2   3   4   5       0   1   2   3   4   5

1. 同时遍历新老结点，liA=>liA 复用，liB=>liC key 不同跳出，进入`处理移动`的环节。
2. 将老 liB 以后的所有老结点放入 Map, 遍历剩余的新结点。
3. lastPlacedIndex 设置为0，在 Map 中查找新结点 liC，发现有可以复用的结点，于是复用，同时更新 lastPlacedIndex 为 oldLiC.index = 2。
4. 继续遍历新结点，liE 可复用，而且 oldLiE.index >= lastPlacedIndex，没有移动，无需标记，更新 lastPlacedIndex 为 oldLiE.index = 4。
5. 继续遍历新结点，liB 可复用，但此时 oldLiB.index < lastPlacedIndex，说明 liB 移动了，标记 `Placement`。
6. 继续遍历新结点，liG 不在老结点中，标记`Placement`。
7. 继续遍历新结点，liD 可复用，oldLiD.index < lastPlacedIndex, 标记 `Placement`。 

                 A        B       C              D                 E               F   
                 A        C       E              B                 G               D
                复用     复用     复用         复用(移动)          不可复用(插入)    复用(移动)
lastPlaceIndex   0        2       4              4                 4               4
                >=       >=      >=    oldIndex < lastPlacedIndex       oldIndex < lastPlacedIndex

### 资料
前端与黑客安全  01:24:52
Electron+游戏引擎+前端黑客与安全 00:10:41  Dom Diff: vue vs react


# fuseEffect 和 fcomponentDidMount 有什么不同？
useEffect 的回调函数 create 会在 commit 阶段结束后，异步执行。
componentDidMount 会在mutation阶段完成视图更新后，在layout阶段同步执行。

这道题在探讨的其实是 useEffect 的 create 函数 fn 与 cDM 的执行时机有什么不同，而 fn 的执行依赖于 useEffect 的第二个参数 deps。所以这道题可以概括为2个问题：
1 deps 如何影响 fn 的执行？
2 fn 和 cDM 的执行时机？

* 第1个问题
useEfffect的标记是 Passive。
useEffect(fn)      每次组件更新，都会打标记
useEffect(fn,[])   只有mount 会打标记
useEffect(fn, deps) 只有mount时，或deps里的元素改了才会打标记

class 组件会在 mount时标记 Placement。

- Placement结点
在 mutation阶段调用 appendChild方法，然后在 layout 阶段调用 cDM方法。
- Passive 结点
在 layout 阶段结束后，异步调用 useEffect的create函数。

* 第2个问题
useEffect的回调函数create 会在commit 阶段结束后异步执行
cDM会在mutation阶段完成视图更新后，在layout阶段同步执行。

useLayoutEffect 和 cDM 的调用时机一致。


==============================  fWebpack  ==============================
# fwebpack生命周期 f工作流程 f构建流程
1. 初始化参数
从配置文件和 shell 语句中读取与合并参数，得出最终的参数。
2. 开始编译
用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始编译。
3. 寻找入口
根据 entry 找到所有 入口文件。
4. 编译模块
从每个入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 输出资源
根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。
6. 写入磁盘
在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
在以上过程中，webapck 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，从而可以改变 webpack 的运行结果。

# fchunk
1. chunk 是 webpack 打包过程中，一系列关联 module 的集合。比如有 3 种方式可以产生 chunk:
*入口 chunk*
webpack 从入口模块开始打包，入口模块引用其他模块，模块再引用模块，从入口开始的一系列模块，就形成了一个 chunk，多个入口就有多个 chunk。
*按需加载*
按需加载的模块，比如 import(..), 也会产生 chunk。
*代码分割*
在 webpack 中配置代码分割，会产生 chunk。
2. chunk 在构建完成时，就呈现为 bundle，一般来说，一个 chunk 对应一个 bundle。但是也有例外，比如 devtool 设置为 source-map 时，一个 chunk 会打包出 2 个 bundle，一个是 main.js，一个是 main.js.map, chunk 是过程中的代码块，bundle 是结果的代码块。
## f入口chunk
下面的例子会生成 2 个 chunk, 使用 entry 的 key 命名，所以一个叫 pageA, 一个叫 pageB。
```js
module.exports = {
  entry: {
    pageA: ...,
    pageB: ...,
  },
  output: {
    filename: '[name].bundle.js'
  }
}
```
## f按需加载
在代码中使用 import(...)按需加载代码，在 webpack 配置中使用 output.chunkFilename 为异步加载的 chunk 命名。
```js
module.exports = {
  entry: ...,
  output: {
    ...,
    chunkFilename: '[name].async.bundle.js'
  }
}
```
## f代码分割
配置 splitChunks 可以将 entry, 异步 chunk 等 chunk 进一步分割，产生更多 chunk。
```js
module.exports = {
  optimization: {
    splitChunks: {
      ....
    }
  }
}
```

# fTreeShaking f摇树优化
Tree-Shaking 是一种基于 ES Module 规范的 无用代码清除(Dead Code Elimination) 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。
## f开启TreeShaking  f在 webpack 中开启 TreeShaking
1. 使用 ESM 规范编写模块代码。
2. 配置 optimization.usedExports 为 true，启动标记功能。
3. 启动代码优化功能，可以通过如下方式的任意一种实现:
  - 配置 mode = production
  - 配置 optimization.minimize = true
  - 提供 optimization.minimizer 数组
例如, 在 webpack.config.js 中:
```js
module.exports = {
  entry: "./src/index",
  mode: "production",
  devtool: false,
  optimization: {
    usedExports: true,
  },
};
```
## fES6模块特点 fESM规范
1. 只能作为模块顶层的语句出现。
2. 导入导出的模块名只能是字符串常量。
3. 导入的值是不可变的。
以上三点，决定了 ESM 是完全静态的，跟运行时无关，所以可以在编译时，从代码字面量中就推断出哪些模块值未被使用，这是实现 Tree Shaking 技术的必要条件。
```js
// index.js 主模块
import {bar} from './bar';
console.log(bar);  // 仅使用了 bar, 没有使用 foo
// bar.js 模块
export const bar = 'bar';
export const foo = 'foo';   // foo 未被使用, 会被视作无用代码而删除。
```
## f原理 fTreeShaking原理
Webpack 中，Tree-shaking 分为两步:
1. 第一步、先标记出模块导出值中哪些没有被用过。
2. 第二步、使用 Terser或UglifyJS 等 DCE工具 删掉这些没被用到的导出语句。
标记过程大致可划分为三个步骤:
  - Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中。
  - Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用。
  - 生成产物时，若变量没有被其它模块使用则删除对应的导出语句。

🌰例子
```js
{
  // bar 模块
  "./src/bar.js":  ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.d(__webpack_exports__, {
      "bar": () => (/* binding */ bar)
      // 这里就没有导出 foo，因为根本没用到。
      // 后面 Terser 插件的 DCE 功能，会把 const foo = 'foo' 摇掉。
    });
    /* unused harmony export foo */
    const bar = 'bar';
    const foo = 'foo';
  })
}
```

# f缓存 fwebpack缓存
1. cache-loader
2. hard-source-webpack-plugin
3. babel-loader
## hard-source-webpack-plugin
模块解析的阶段，用于中间的缓存。
第一次是正常的构建速度，但是会保存缓存数据到 xxx 里。
第二次使用缓存来构建，速度提升。
## babel-loader
运行以后，会增加 node_modules/.cache/babel-loader 这个文件夹，存放缓存的文件
```js
{
  loader: 'babel-loader',
  options: {
    cacheDirectory: true // 开启缓存
  }
}
```

# f热更新🔥 fdevServer
安装 webpack-dev-server, 然后在开发环境下配置:
```js
devServer: {
  contentBase: join(__dirname, '../dist'),
  hot: true,
  port: 3000
}
```

## f系统级通知
按下 Ctrl+S, 无需查看 terminal, 系统会通知你成功/失败。只需安装 webpack-build-notifier, 配置插件:
```js
plugins: [
  new WebpackBuildNotifierPlugin({
    title: "My Webpack Project",
    logo: path.resolve("./img/favicon.png"),
    suppressSuccess: true,
  })
]
```
