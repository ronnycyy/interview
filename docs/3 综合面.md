============================================== f设计模式 ==============================================
# 平时工作中有用到哪些设计模式？
TODO: 
1.单例模式 继哥写的基础库？ redux的store
2.观察者模式 redux的subscribe和dispatch (如果面试官要求举出更多例子，再讲 Vue的Watcher订阅和Data发布)

# f单例模式
单例模式即一个类只能构造出唯一的实例，单例模式的意义在于共享、唯一。
## 例子
Redux 的 store。 (如果面试官要求举出更多例子，再讲 Vuex的store, JQ的$, 业务场景的购物车🛒等)
## 代码
```js
class Singleton {
  constructor(name) {
    this.name = name;
  }
  static getInstance(name) {
    if (!this.instance) {
      this.instance = new Singleton(name);
    }
    return this.instance;
  }
}
const instance1 = Singleton.getInstance('name1');
const instance2 = Singleton.getInstance('name2');
console.log(instance1 === instance2);  // true，只有一个实例
console.log(instance1.name);  // name1
console.log(instance2.name);  // 依然是 name1
```

# 工厂模式
工厂模式即对创建对象逻辑的封装，或者可以简单理解为对new的封装，这种封装就像创建对象的工厂，故名工厂模式。
## 例子
工厂模式常见于大型项目，比如JQ的$对象，我们创建选择器对象时之所以没有new selector就是因为$()已经是一个工厂方法，其他例子例如React.createElement()、Vue.component()都是工厂模式的实现。
## 代码
```js
class User {
  constructor(name, auth) {
    this.name = name;
    this.auth = auth;
  }
}
class UserFactory {
  static createUser(name, auth) {
    // 工厂内部封装了创建对象的逻辑。
    // 使用者在外部创建对象时,不需要知道各个权限对应哪个字段, 不需要知道赋权的逻辑，只需要知道创建了一个管理员和一个普通用户。
    if (auth === 'admin') {
      return new User(name, 1);
    }
    if (auth === 'user') {
      return new User(name, 2);
    }
  }
}
const admin = UserFactory.createUser('boss', 'admin');
const user = UserFactory.createUser('mike', 'user');
```

# 观察者模式
观察者监听被观察者的变化，被观察者发生改变时，通知所有的观察者。
## 例子
Redux的subscribe和dispatch。
## 代码
```js
// 观察者
class Observer {
  constructor(fn) {
    this.update = fn;
  }
}
// 被观察者
class Subject {
  constructor() {
    this.observers = [];
  }
  register(ob) {
    this.observers.push(ob);
  }
  notify() {
    this.observers.forEach((ob) => {
      ob.update();
    })
  }
}
const ob1 = new Observer(() => console.log('ob1 update!'));
const ob2 = new Observer(() => console.log('ob2 update!'));
const ob3 = new Observer(() => console.log('ob3 update!'));
const subject = new Subject();
subject.register(ob1);
subject.register(ob2);
subject.register(ob3);
subject.notify();
```

# f装饰器模式
装饰器模式，可以理解为对类的一个包装，动态地拓展类的功能，ES7的装饰器语法以及React中的高阶组件（HOC）都是这一模式的实现。
## 代码
```js
// ES7的装饰器
function Info(target) {
  target.prototype.name = 'mike';
}

@Info
class Man {}

const man = new Man();
console.log(man.name);  // info
```

# f适配器模式
适配器模式，将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。我们在生活中就常常有使用适配器的场景，例如出境旅游插头插座不匹配，这时我们就需要使用转换插头，也就是适配器来帮我们解决问题。
## 代码
```js
class Adaptee {
  test() {
      return '旧接口';
  }
}
class Target {
  constructor() {
      this.adaptee = new Adaptee()
  }
  test() {
      const info = this.adaptee.test()
      return `适配${info}`;
  }
}
const target = new Target()
console.log(target.test());
```

# f代理模式
代理模式，为一个对象找一个替代对象，以便对原对象进行访问。即在访问者与目标对象之间加一层代理，通过代理做授权和控制。
## 例子
最常见的例子是经纪人代理明星业务，假设你作为一个投资者，想联系明星打广告，那么你就需要先经过代理经纪人，经纪人对你的资质进行考察，并通知你明星排期，替明星本人过滤不必要的信息。事件代理、JQuery的$.proxy、ES6的proxy都是这一模式的实现。
## 代码
```js
const idol = {
  name: 'mike',
  phone: 10086,
  price: 1000000
}
const agent = new Proxy(idol, {
  get: function(target) {
    //拦截明星电话的请求,只提供经纪人电话
    return '经纪人电话:10010'
  },
  set: function(target, key, value) {
    if(key === 'price' ) {
      //经纪人过滤资质
      if(value < target.price) throw new Error('报价过低')
      target.price = value
    }
  }
})
agent.phone        //经纪人电话:10010
agent.price = 100  //Uncaught Error: 报价过低
```


============================================== fGit ================================================
# finit git init
1. 创建一个新的存储库。
2. 设置一个 .git 子目录。
3. 创建一个新的主分支。


# fGit
Git是一个免费的、开源的分布式版本控制系统，旨在以快速高效的方式处理从小型到大型的所有项目。
Git易于学习、占用空间小、性能极快。它具有方便的工作区、暂存区、本地库和多个工作流分支等特性。

## 架构
远程库
⬆️git push(推送给远程), ⬇️git pull(拉取更新), ⬇️git clone(初始化到本地), ⬇️git remote add <远程别名>（如 origin） <远程链接>(本地已经有项目，添加一个远程库)
本地库
⬆️git commit(提交，生成一个历史版本), ⬇️git branch <分支名>(增加分支), ⬇️git checkout (切换分支), ⬇️git log/git reflog(查看提交日志)
暂存区
⬆️git add(添加到暂存区), ⬇️git restore --stage <file>(取消添加)
工作区   

## 本地库结构
-------- commit1 ----------- commit2 -------- commit3  ---------------- commit 4 -----------------------   分支一
            |                                                                      | 合并给分支一
            -------- commit1 --------------------------------   分支二              |
                              |                                                    | 分支三可以继续走，无影响
                              ------- commit 1 ------------------------------------|-------- 分支三 

### 分支
多个分支是本地库中的多个工作流，每个分支独立管理自己的提交历史。

当前所在的分支，是由 HEAD 决定的。
master,hot-fix 这两个分支其实是两个指针，HEAD 指向谁，谁就是当前分支，切换分支的本质就是改变 HEAD 指向。

#### 例子
两个分支，每个分支有独立的提交历史:
first ---- second  ---- third --- fourth ----- fifth  [master]   
                          |
                        third --------- fourth        [hot-fix]   <= HEAD (当前分支是 hot-fix)
 
#### 优点
同时并行推进多个功能开发，提高开发效率。
各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支造成影响。失败的分支删除了，重新开始即可。

git branch <分支名>: 增加分支
git branch: 查看本地库的分支，以及当前处在哪个分支上
git checkout <分支名>: 切换分支  (改变HEAD指向)
git reflog: 查看所有分支的提交历史

#### 合并冲突的分支
在当前分支下，合并其他分支的修改。(注意合并只会影响当前分支的内容，对其他分支毫无影响)

##### 背景
合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改，Git无法帮我们作出决定，这时就有冲突。
冲突发生时，需要人为决定新代码的内容。

#### 步骤
1. 执行合并
git merge <其他分支>

```shell
Auto-merging test.md  // 正在自动合并 test.md...
CONFLICT (content): Merge conflict in test.md   // test.md 里有合并冲突
Automatic merge failed; fix conflicts and then commit the result.   // 自动合并失败
```

2. vim test.md 查看冲突文件
<<<HEAD
<当前分支的代码>
======
<要合并进来的分支的代码>
>>>>> hot-fix

3. 手动修改
修改`<<<HEAD`和`======`中间的内容，留下你要的部分，然后把分割线删掉。

4. 保存
wq, git add, git commit, 完成以后，`其他分支`的修改就合并到`本分支`了。


## 分支内版本穿梭 (回到某一个提交历史)  f版本穿梭
回到某一个提交历史，作出修改后，再提交到最新修改的后面。 实现回到过去，逆转现在!

first ---- second  ---- third --- fourth ----- fifth                当前在 fifth 提交
                                              [master]

first ---- second  ---- third --- fourth ----- fifth                回到 third 提交
                      [master]       

first ---- second  ---- third --- fourth ----- fifth ---- sixth     基于 third 修改，提交 sixth
                                                        [master]                
### 命令
git reset --hard [commitCode]


## git frebase vs git fmerge
git rebase:  找到当前分支和目标分支的交叉点，交叉点到当前分支尾的部分拆出来，合到目标分支的末尾，也就是合成一条 commit 线。
git merge: 新建一个 commit 结点，两个分支末尾都指向这个新的 commit 结点。

 
============================================fRedux======================
Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 

Redux 可以用这三个基本原则来描述:
1. 单一数据源
整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。
这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，你可以把应用的 state 保存在本地，从而加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。

2. State 是只读的
唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。
这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。

3. 使用纯函数来执行修改
为了描述 action 如何改变 state tree ，你需要编写 reducers。
Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分，因为 reducer 只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的 reducer 来处理一些通用任务，如分页器。

## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/redux

### fcreateStore.js
观察者模式: 订阅、取消订阅、发布。
```js
export default function createStore(reducer, initState, rewriteCreateStoreFunction) {
  if (rewriteCreateStoreFunction) {
    const newCreateStore = rewriteCreateStoreFunction(createStore);
    return newCreateStore(reducer, initState);
  }

  let state = initState;
  let listeners = [];

  function subscribe(listener) {
    // 订阅
    listeners.push(listener);
    // 取消订阅
    return function unsubscribe(listener) {
      const index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    }
  }

  function getState() {
    return state;
  }

  function dispatch(action) {
    // 通知用户定义的 reducer 得到新的状态
    state = reducer(state, action);
    // 发布 
    // 无论哪个小状态变化，都将全量通知
    for (let i = 0, len = listeners.length; i < len; i++) {
      const listener = listeners[i];
      listener();
    }
  }

  // 执行所有的 reducer，使得 `以reducer为key的每个store`，在总状态里初始化。
  // 使用 symbol 避免和用户的 action.type 重名
  dispatch({ type: Symbol('__init_store__') });
  /**
   * 实现一个 Symbol?
   * 
   * function MySymbol(name) {
   *    const obj = Object.create({
   *      toString: function() {
   *         return name;
   *      }
   *    })
   *    return obj;
   * }
   */

  function replaceReducer(nextReducer) {
    reducer = nextReducer;
    dispatch({ type: Symbol('__init_store__') });
  }

  return {
    subscribe,
    getState,
    dispatch,
    replaceReducer,
  }
}
```




### fcombineReducer.js
组合用户所有的 reducer，每个 reducer 维护自己的那份 state (totalState[key])，但是每次更新都会创建一个全体的新的 state 返回。
如果确实没有变更，(非常少见，比如发了一个所有 reducer 都不受理的 action)，才会返回之前的 state 引用。
```js
export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers);

  // 最后合并好的 reducer
  return function combine(state = {}, action) {
    // 所有的 action, 都是执行这个 combine 函数，改变自己的 state (state[key])，返回整体的 state 中，最后改变整体的 state (引用)。
    const nextState = {}
    // 遍历所有 reducer
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      const reducer = reducers[key];  // counterReducer, infoReducer
      // 某个 reducer 的旧库
      const prevStateForKey = state[key];
      // 执行动作，状态改变，得到该 reducer 的新库
      const nextStateForKey = reducer(prevStateForKey, action);
      // reducer的key和state的key要保持一致
      // 该 reducer 的保存到一份新的总状态里
      nextState[key] = nextStateForKey;
    }
    return nextState;
  }
}
```


### fapplyMiddleware.js  f中间件原理 (中间件们把store.dipatch作为`🧅的最内核`包裹起来)
redux的中间件原理是:
1. 先把 store 传入每一个中间件，它们都返回一个函数，这个函数接受一个next函数，返回另一个函数，如 `(next) => (action) => {...}`
2. 把这些函数通过 compose 组合起来，得到一个总体的函数，也是接受一个next函数，返回另一个函数: `(next) => ex(time(log(next)))`
3. 把 `store.dispatch` 作为 `next` 参数，传给这个函数，执行，最终返回一个符合洋葱模型🧅的函数，洋葱模型最内层就是原始的 store.dispatch:
`(action) => { ex1(next前),  time1,log1,store.dispatch,log2,time2 (next),  ex2(next后)  }`

如果传入的顺序是 applyMiddleware(左1,左2,左3),  那么最终的执行顺序是 左1,左2,左3,store.disptach,左3,左2,左1。

```js
// dispatch 的时候，依次执行所有的 middleware。
const applyMiddleware = function (...middlewares) {

  // 返回这个函数，给 createStore.js 里的 rewriteCreateStoreFunction 调用，再返回一个新的 createStore 函数
  return function (oldCreateStore) {

    // 这个玩意儿是新的 createStore 函数，把中间件嵌入到 dispatch 流程中。
    return function (reducer, initState) {
      const store = oldCreateStore(reducer, initState);
      const simpleStore = { getState: store.getState };

      // 中间件先依次执行一遍，转成 (next) => xxx, 结果放到链中，形成数组
      // 每一个 middleware 变成一个 m(simpleStore) 的执行结果 ----> 一个函数: (next) => (action) => {...}
      // [
      //  (next) => (action) => {...log...}, 
      //  (next) => (action) => {...exception...},
      //  ...
      // ]
      const chain = middlewares.map(m => m(simpleStore));
      // 现在中间件已经变成了 (next) => (action) => xxx 这个鬼样子,
      // 然后 compose 从右到左把中间件组合起来:
      // ex, time, log 三个转成 (next) => .. 的中间件，变成 (...args) => ex(time(log(...args))) 

      // 传入 store.dispatch 执行，返回 ex(time(log(store.dispatch))) 的执行结果, 执行过程是:

      // 1. log 中间件 ”(next) => (action) => xxx“ 执行，返回一个函数，作为 next 给 time 中间件
      // ex(time(   (action) => {..log1..., store.dispatch, ..log2...}       ))

      // 2. time 中间件执行，返回一个函数，作为 next 给 exception 中间件
      // ex(   (action) => {..time..}   )

      // 3. 最后返回一个函数，给 dispatch
      // (action) => { 错误处理(next之前)...,  time中间件执行传过来的函数(action) => {...} (next),  xxx(next之后)  }

      // 所以，在 dispatch 的时候，中间件根据传入 applyMiddleware 的顺序，从左往右，按洋葱模型🧅执行。(左1,左2,左3,store.disptach,左3,左2,左1)
      const dispatch = compose(...chain)(store.dispatch);

      console.log('dispatch', dispatch);

      return {
        ...store,
        dispatch
      }
    }
  }
}
export default applyMiddleware;
```

### fbindActionCreators.js
把所有创建 action 的函数集中到一个对象上，使用时可以直接调用。
比如 const actions = bindActionCreators({ Add, setName }, store.dispatch);  
使用时 actions.Add(); 相当于 store.dispatch({ type: 'ADD' });
```js
/**
 * @param {Function} actionCreator 用户定义的 action 函数，比如 setName 函数。
 * @param {Function} dispatch store.dispatch
 */
function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(null, arguments));
  }
}
export default function bindActionCreators(actionCreators, dispatch) {
  const b = {};
  // 把所有创建 action 的函数集中到一个对象上，使用时可以直接调用。
  // for..in  遍历所有可枚举属性，它会把原型上的属性也找出来，只不过 Object.prototype 上的属性是不可枚举的，所以没出来。
  for (const key in actionCreators) {
    const action = actionCreators[key];
    if (typeof action === 'function') {
      b[key] = bindActionCreator(action, dispatch);
    }
  }
  return b;
}
```

## fcompose.js
从右往左组合函数，比如 compose(f, g, h) 返回一个函数: (...args) => f(g(h(...args)))
```js
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg
  }
  if (funcs.length === 1) {
    return funcs[0]
  }
  // a 相当于之前所有组合好的函数, b 是本次要组合的函数, 
  // 比如: (f(g(...args)), h) => (...args) => f(g(h(...args)))
  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```

# fRedux-Toolkit fredux-toolkit fToolkit
redux 官方推荐的工具集，比 redux 更加轻量。最佳实践。

# react-redux
`react-redux`是将`Redux store`和`React UI`相结合的`官方绑定层`。
它使 react 组件可以从 redux store 读取数据，也可以向 store 发起 action 以更新状态。
基于 context API 封装。
## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/react-redux (【手写源码系列】40分钟带你从0到1实现一个react-redux)


# fRecoil frecoil f原子化
Recoil 是 React 的状态管理库，只能用在 React 里边。
## 目标
redux太复杂, 得创建 store, reducer, action, ..., 和 react 合起来还得创建 react-redux。项目复杂时，会有多层 Provider 树🌲.
因此，Recoil的目标是: 最小化state，不要有包装，不要多层次的Provider。
## 核心
原子状态变化(text) -> 衍生状态变化(text.length) -> 视图更新。
## 手写源码
https://github.com/ronnycyy/state-manager/tree/main/recoil  (前端中的数据结构和算法2)

# fvuex
大垃圾 只有一个文件 也是基于 redux。

# 前端状态管理库的对比
Redux `时间旅行`的理念非常经典，由这个理念发展出了很多状态管理库。
应该怎么选择 React 状态管理库？从两个角度说:
1. 项目规模
2. 项目类型

## 项目规模
1. 很小的项目，玩具项目，没必要用库了，直接 context API 就行。
2. 大一丢丢的项目，但还是一个人写的，比如短期的活动页，可以用一些迷你的库，比如 unstated(基于context封装)
3. 再大一点，需要几个小伙伴合作的，就可以用 dva, mobx, jotai, recoil 等基于`原子状态`理念的。

## 项目类型
1. 普通的后台管理页，要填很多表单 => 双向数据绑定 => 适合用 mobx。
2. 富文本编辑器，我需要完成 `撤销/重做` 这样的功能，那就适合用 redux 系列的`时间旅行`的库。


==============================fReact==============================
# fScheduler f调度更新
Scheduler 是一个在浏览器环境中实现`调度功能`的包，它提供了 2 个功能，一个是时间切片，一个是优先级调度。当前 Scheduler 用于 react 内部，但是 react 团队计划将它作为一个独立的包。
## f时间切片
*讲概念*
时间切片的本质是模拟实现 requestIdleCallback，也就是说，要在浏览器一帧的空闲时间执行 React 的任务，从而不占用重排重绘的时间，以提供快速响应的效果。主流浏览器的刷新频率是 60 Hz, 也就是一帧 16.6 ms。这一帧浏览器要做的事情有:  task - job - requestAnimationFrame - 重排/重绘 - requestIdleCallbak。时间切片默认的任务执行时间是 5ms，超过执行时间后，会中断执行，交换控制权给浏览器以执行重排重绘，这样看到的效果就是，一个 React 长任务，被切分在一片一片的 5ms 多一点的时间里执行。
*时间切片是怎么实现的 fMessageChannel*
React 首选 MesssageChannel 实现时间切片，如果环境不支持，再降级到 setTimeout。
```js
/* 建立一个消息通道 */
const channel = new MessageChannel();
/* 建立一个port发送消息 */
const port = channel.port2;
/* 接收消息 */
channel.port1.onmessage = function(){
  /* 宏任务中, 执行 React 任务 */
  scheduledHostCallback();
};
/* 向浏览器请求执行更新任务 */
port.postMessage();
```
*为什么是MessageChannel*
1. MessageChannel 比 setTimeout 执行时机更加靠前，能让任务更早触发。
2. 递归执行 setTimeout 时，最后间隔时间会变成 4ms 左右，而不是最初的 1ms，一帧才 16ms，这就造成了浪费。
```js
let time = 0
let nowTime = +new Date()
let timer = null;
const poll = function(){
    timer = setTimeout(()=>{
        const lastTime = nowTime
        nowTime = +new Date()
        console.log( '递归setTimeout(fn,0)产生时间差：' , nowTime -lastTime )
        poll()
    },0)
    time++
    if(time === 20) clearTimeout(timer)
}
poll();
```

## f优先级调度
*讲概念*
1. Scheduler 提供一个方法叫 runWithProirity, 它接收 2 个参数，一个是优先级，一个是回调函数，提供的功能是: 以某个优先级调度这个回调函数。
2. Scheduler 提供了 5 种优先级，优先级代表任务的到期时间。[(scheduler/src/SchedulerPriorities.js)]
3. 在一个大型的 React 应用中，某一刻会有很多任务，有些任务到期了，就认为是已就绪，未到期的就是未就绪。Scheduler 将`已就绪任务`和`未就绪任务`分别放入 2 个队列中，一个叫 taskQueue，一个叫 timerQueue，它们底层都是通过`小根堆`实现的，排序的依据就是任务的到期时间。当 timerQueue 中有任务过期时，就从堆顶弹出这个任务，加入到 taskQueue 中等待被执行。[(scheduler/src/Scheduler.js):advanceTimers]
4. 放入 MessageChannel 的回调是 flushWork，flushWork 会将`未就绪任务`加入 timerQueu，并将循环 taskQueue 的任务执行，直到被中断。
*优先级*
```js
// 由高到低，代表到期时间越来越大
var IMMEDIATE_PRIORITY_TIMEOUT = -1;   // 立即执行优先级 (已经到期)
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;  // 用户交互优先级
var NORMAL_PRIORITY_TIMEOUT = 5000;  // 普通优先级
var LOW_PRIORITY_TIMEOUT = 10000;  // 低优先级
var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;   // 空闲优先级 (最大的31位整数, 永不到期)
```

# f中断与恢复
1. performConcurrentWorkOnRoot 是被调度的 render 阶段的执行函数，它在被打断时会将自己返回。 
2. 这个返回值将作为当前被打断任务的回调函数， React 会标记该任务是被中断了，这个任务将留在 taskQueue 中，等待下次被调度。
3. 调度再次到来，被打断的任务继续执行 performConcurrentWorkOnRoot。
*源码*
```js
// ~/react/packages/scheduler/src/forks/Scheduler.js
function workLoop(...) {
  const continuationCallback = callback(didUserCallbackTimeout);
  currentTime = getCurrentTime();
  if (typeof continuationCallback === 'function') {
    // continuationCallback是函数
    currentTask.callback = continuationCallback;
    markTaskYield(currentTask, currentTime);
  } else {
    if (enableProfiling) {
      markTaskCompleted(currentTask, currentTime);
      currentTask.isQueued = false;
    }
    if (currentTask === peek(taskQueue)) {
      // 将当前任务清除
      pop(taskQueue);
    }
  }
  advanceTimers(currentTime);
}
```
```js
// ~/react-reconciler/src/ReactFiberWorkLoop.new.js: performConcurrentWorkOnRoot
function performConcurrentWorkOnRoot() {
  if (root.callbackNode === originalCallbackNode) {
    return performConcurrentWorkOnRoot.bind(null, root);
  }
  ...
}
```

# flane
lane 是 React 内部的优先级模型，和 Scheduler 的优先级模型是分隔开的。源码位于 ~/react-reconciler/src/ReactFiberLane.js
*对lane的要求*
1. 能够表示不同的优先级
2. 可能存在多个相同优先级的更新，所以要能表示`批`的概念
3. 方便进行优先级的运算
*表示不同优先级*
lane 模型借鉴了卡丁车比赛的原理，赛场上有多个赛道，React 用 31 个不同的二进制位，来表示不同的赛道，不同赛道就表示不同的优先级。
比如 SyncLane 占领第 1 位，是比较高的优先级，越往下的位，优先级越低。
*表达 批 的概念*
除了 Lane 类型的变量，React 还定义了 Lanes 类型的变量，它们会占领多个连续的二进制位，表示这些优先级在同一个批次里。
*方便计算*
lane 优先级的计算，其实就是二进制位的计算，比如`按位与`、`按位或`等。位运算是非常快速的。
## f饥饿问题
低优先级任务始终被高优先级任务打断，没有机会被执行，这种问题就是饥饿问题。


# fbatchedUpdates
一次回调中触发多次 setState，将这多次更新合并为一次更新的优化手段，就叫 batchedUpdates。
## legacy模式
*版本*
适用于 React18 以前，使用 `ReactDOM.render(<App />, root)` 渲染的应用。
*源码*
源码位于 ~/react-reconciler/src/ReactFiberWorkLoop.js 的 batchedUpdates 方法:
1. 接收一个函数 fn, fn 通常是组件的 onClick 等事件回调，其中包含多个 setState 方法。
2. fn 执行之前，将它的上下文`或上`一个 BatchedContext，fn 执行完成后，再恢复成之前的上下文。
3. fn 执行时，其中的 setState 会获取到 executionContext, 这时就会得到 BatchedContext，那么就不会立马触发更新，而是在 batchedUpdate 的 finally 里，执行 flushSyncCallbackQueue 里触发更新。
*缺点*
1. 整个过程同步执行，如果将 setState 作为异步调用，那么执行 setState 时已经离开了 batchedUpdates 的上下文，也就获取不到 BatchedContext 了。
## concurrent模式
*版本*
React18, 通过 `ReactDOM.createRoot(root).render(<App />)` 开启，注意 `import ReactDOM from 'react-dom/client';`。
*源码*
this.setState 的源码位于: ~/react-reconciler/src/ReactFiberClassComponent.js 的 classComponentUpdate.enqueueSetState 方法, 通过类实例 instance.updater.enqueueSetState 来调用。
*原理*
1. 第一个 setState 进来，获取 lane, 转化成 Scheduler 的优先级，通过 Scheduler 暴露的 scheduleCallback 调度 performConcurrentWorkOnRoot，同时整个React应用的根结点 FiberRootNode 记录这个被调度的任务和它的优先级。
2. 第二个 setState 进来, 得到一样的 lane, 然后到 ensureRootIsSchedule 时，获取到的 root.callbackNode 是上一个 setState 调度的任务，不为空。既然不为空，那么表示 React应用 有任务正在调度，于是取出这个任务的优先级 root.callbackPriority 和此刻想要调度任务的优先级对比，发现一致(因为 lane 一致)，那么第二次更新就不会被调度，而是直接 return 了，也就是复用了正在调度的任务。
3. 关键就在于，同一个 onClick 里的所有 setState，得到的 lane 都是一致的，从而产生的优先级一致，就可以复用任务。


# f高优更新如何插队 高优更新如何打断低优更新
*DEMO*
两次更新，一次是 NormalPriority 的更新，一次是 1ms 后 UserBlockingPriority 的更新，后面的更新优先级高，会打断前面的更新。
```jsx
setTimeout(() => updateCount(1), 1000);
setTimeout(() => button.click(), 1001);
```
*原理*
React18，useState 的 dispatch，从 dispatchSetState 开始。
1. 调度低优更新 (NormalPriority, 如 useState 返回的 dispatch)
requestUpdateLane获取lane -> 使用lane创建update对象 -> scheduleUpdateOnFiber在当前fiber上调度lane更新 -> ensureRootIsScheduled调度整个应用的根结点 -> lane 转 Schedule Priority -> 调度一次 NormalPriority 的 performConcurrentWorkOnRoot
2. 高优更新 (UserBlockingPriority, 如 onClick 触发的更新)
**2.1 打断低优更新，调度高优更新**
前面都一样，直到 ensureRootIsScheduled，得到的 新任务优先级(newCallbackPriority) 高于 已存在的任务优先级(existingCallbackPriority)，所以取消正在调度中的低优任务，调度本次更高优先级的任务。
```js
// 打断低优任务
if (existingCallbackNode != null) { cancelCallback$1(existingCallbackNode); }
...
// 调度高优任务
scheduleCallback(更高的优先级, render任务);
```
**2.2 清除低优更新产生的影响**
[源码位于 ~/react-reconciler/src/ReactFiberWorkLoop.js: prepareFreshStack]
高优先级任务到达执行时间，开始调用render任务(performConcurrentWorkOnRoot), 在 render 阶段前，先执行 prepareFreshStack，将 workInProgress 重置为 rootFiber，清空上一次更新产生的 fiber 树，重新开始协调。


# fsuspense
React 要实现快速响应，需要解决 2 个问题，一个是 CPU 的瓶颈，一个是 IO 的瓶颈。CPU 瓶颈的解决方案是`时间切片`，而 IO 瓶颈的解决方案就是 Suspense。
*原理*
Suspense 组件进入协调阶段，执行 updateSuspenseComponent，返回一个`离屏Fiber结点`作为子结点。这个离屏 fiber 的 pendingProps 里有一个 childern 属性代表 Suspense 子组件的集合，还有一个 mode 属性代表子组件当前是否可见。如果可见就渲染真实的子组件，如果不可见就渲染 Suspense 的 fallback 属性里定义的组件。
*离屏组件*
fiber.elementType = Symbol(react.offscreen);
*组件树*
Suspense组件 -> OffscreenFiber -> Suspense包裹的子组件
*结束fallback*
1. thrownValue: 这里可以捕获到 Suspense 内部子组件当成错误抛出的 Promise 对象。
2. root: FiberRootNode
renderRootConcurrent 方法中:
```js
do {
  try {
    workLoopConcurrent();
    break;
  } catch (thrownValue) {
    handleError(root, thrownValue);
  }
} while (true);
```
renderRootConcurrent -> 捕获到 Promise 对象 -> handleError -> throwException -> 判断是一个 thenable 对象 -> 找到上面最近的 Suspense 组件 -> 渲染 fallback 组件 -> attachPingListener监听抛出的Promise -> Promise.then -> 执行 pingSuspendedRoot -> ensureRootIsScheduled -> 更新 React 应用，渲染 Suspense 的子组件。


🔥通读一遍 React 官网文档
# f代码分割 fReact代码分割
*讲概念*
代码分割是由如 Webpack，Rollup 这类打包器支持的一项技术，能够创建多个包并在运行时动态加载。
*说用途*
对你的应用进行代码分割能够帮助你“懒加载”当前用户所需要的内容，能够显著地提高你的应用性能。尽管并没有减少应用整体的代码体积，但你可以避免加载用户永远不需要的代码，并在初始加载的时候减少所需加载的代码量。
*列用法*
## 使用import()语法  fimport()
- 当使用 Babel 时，你要确保 Babel 能够解析动态 import 语法而不是将其进行转换。对于这一要求你需要 babel-plugin-syntax-dynamic-import 插件。
- 当 Webpack 解析到该语法时，会自动进行代码分割。如果你使用 Create React App，该功能已开箱即用，你可以立刻使用该特性。
**组件**
```jsx
import("./math")
  .then(math => {
    console.log(math.add(16, 26));
  });
```
**webpack配置**
```js
module.exports = {
  entry: {
    main: './src/app.js',
  },
  output: {
    // 命名 bundle
    filename: '[name].bundle.js',
    // 为异步加载的 chunk 命名
    chunkFilename: '[name].bundle.js',
    // bundle 的输出路径
    path: './dist',
  }
};
```
## 2. React.lazy flazy f懒加载
*讲概念*
React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）。
*列用法*
1. React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件。
2. 在 Suspense 组件中渲染 lazy 组件，如此使得我们可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。
```jsx
import React, { Suspense } from 'react';
const OtherComponent = React.lazy(() => import('./OtherComponent'));
function LazyDemo() {
  const [showLazy, setShowLazy] = React.useState(false);
  const load = () => { setShowLazy(true) }
  return (
    <div>
      <button onClick={load}>点击按钮加载组件</button>
      {
        showLazy ? (
          <Suspense fallback={<h1>正在加载...</h1>}>
            <OtherComponent />
          </Suspense>
        ) : <h1>未加载组件</h1>
      }
    </div>
  );
}
```
3. 基于路由的代码分割
```jsx
import React, { Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
const Home = React.lazy(() => import('./routes/Home'));
const About = React.lazy(() => import('./routes/About'));
const ReactRouterDemo = () => (
  <Router>
    <Suspense fallback={<div>loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
)
```

# fContext
*讲概念*
Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或当前选中的语言。
Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。
*说用途*
在一个典型的 React 应用中，数据是通过 props 属性由父到子进行传递的，但此种用法对于某些类型的属性而言是极其繁琐的，比如当前用户、应用语言、UI主题，这种属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。
*优缺点*
**缺点**
1. Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。
*举例子*
React.createContext 创建 Context 对象，Class.contextType 接收 Context 对象，this.context 读取 Context 对象的值。
```jsx
const ThemeContext = React.createContext('light');
class App extends React.Component {
  render() {
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}
// 中间的组件再也不必指明往下传递 theme 了。
function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}
// 在需要使用 Context 的组件中，指定 contextType 读取当前的 theme context。
// React 会往上找到最近的 theme Provider，然后使用它的值。
class ThemedButton extends React.Component {
  static contextType = ThemeContext;   // 跨组件接收数据
  render() {
    return <Button theme={this.context} />;  // 找到 ThemeContext.Provider value="dark"
  }
}
```
*API*
*** fcreateContext React.createContext ***
```jsx
const ThemeContext = React.createContext('light');
```
1. React.createContext 接收一个 defaultValue，返回一个 Context 对象。
2. 当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。
3. 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。

*** fProvider fContext.Provider ***
```jsx
<ThemeContext.Provider value={/* 某个值 */}>
```
1. 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。
2. Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。
3. 多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。
4. 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。比如 使用了contextType的类组件 和 使用了useContext的函数组件。
5. 通过新旧值检测来确定变化，使用了`Object.is`算法。

*** fClass.contextType ***
挂载在 class 上的 contextType 属性可以赋值为由 React.createContext() 创建的 Context 对象。
此属性可以让你使用 this.context 来获取最近 Context 上的值。你可以在任何生命周期中访问到它，包括 render 函数中。
```jsx
class MyClass extends React.Component {
  static contextType = MyContext;
  render() {
    const value = this.context;  // MyContext.Provider 的 value 值
  }
}
```

*** fConsumer fContext.Consumer ***
Context.Consuer 是一个 React 组件，它可以订阅 context 的变更。
```jsx
<MyContext.Consumer>
  {value => /* 基于 context 值进行渲染*/}
</MyContext.Consumer>
```
它需要一个函数作为子元素。这个函数接收当前的 context 值，并返回一个 React 节点。传递给函数的 value 值等价于组件树上方离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。

*** fdispalayName fConext.dispalyName ***
context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。
```jsx
const MyContext = React.createContext(/* some value */);
MyContext.displayName = 'MyDisplayName';
/* "MyDisplayName.Provider" 在 DevTools 中 */
/* "MyDisplayName.Consumer" 在 DevTools 中 */
<MyContext.Provider> 
<MyContext.Consumer> 
```

# f更新 f状态更新 触发状态更新
有 3 个步骤到达 render 阶段:
1. 创建update对象 (`createUpdate`)
2. 从fiber到root (`markUpdateLaneFromFiberToRoot`)
3. 调度更新 (`ensureRootIsScheduled`)
## 创建update对象
有 5 种方法可以创建 update 对象:
1. this.setState
2. this.forceUpdate
3. useState
4. useReducer
5. ReactDOM.render
每次`状态更新`都会创建一个保存更新状态相关内容的对象，我们叫他 Update。在 render 阶段的 beginWork 中会根据 Update 计算新的 state。
## 从fiber到root
调用 markUpdateLaneFromFiberToRoot, 该方法做的工作可以概括为：从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber。
## 调度更新
现在我们拥有一个rootFiber，该rootFiber对应的Fiber树中某个Fiber节点包含一个Update。接下来通知Scheduler根据更新的优先级，决定以同步还是异步的方式调度本次更新。这里调用的方法是 ensureRootIsScheduled, 调度的方法是 performSyncWorkOnRoot 或者 performConcurrentWorkOnRoot, 也就是 render 阶段的入口。
```js
if (newCallbackPriority === SyncLanePriority) {
  // 任务已经过期，需要同步执行render阶段
  newCallbackNode = scheduleSyncCallback(
    performSyncWorkOnRoot.bind(null, root)
  );
} else {
  // 根据任务优先级异步执行render阶段
  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
    newCallbackPriority
  );
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
```


# fRef fRefs转发 
*讲概念*
Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递给子组件。
*说用途*
1. 转发 refs 到 DOM 组件
2. 在高阶组件中转发 refs
*** 转发 refs 到 DOM 组件 ***
1. 通过 React.createRef 创建一个 ref 对象。
2. 通过 ref 属性传递给 React.forwardRef 返回的组件，React 内部将 ref 传递给 forwardRef 接收的函数的第 2 个参数。
3. 在 forwardRef 接收的函数中，将 ref 传递给原生 button 元素，DOM渲染完成后, ref.current 拿到 button 的 DOM 引用。
4. 这样在父组件那一层的 ref 对象，就拿到了 FancyButton 内部的 button 的 DOM 引用。
🔥注意:
1. 第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。
2. Ref 转发不仅限于 DOM 组件，也可以转发 refs 到 class 组件实例中。
```jsx
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));
// ref 属性会获取到 FancyButton 中原生 button 的 DOM 引用
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```
*** 在高阶组件中转发 refs ***
1. ref 不是 prop 属性。就像 key 一样，其被 React 进行了特殊处理。如果你对 HOC 添加 ref，该 ref 将引用最外层的容器组件，而不是被包裹的组件。
2. 这意味着用于我们 FancyButton 组件的 refs 实际上将被挂载到 LogProps 组件。
3. 幸运的是，我们可以使用 React.forwardRef API 明确地将 refs 转发到内部的 FancyButton 组件。React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点。例如:
```jsx
function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }
    render() {
      const {forwardedRef, ...rest} = this.props;
      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
      return <Component ref={forwardedRef} {...rest} />;
    }
  }
  // 注意 React.forwardRef 回调的第二个参数 “ref”。
  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
  return React.forwardRef((props, ref) => {
    return <LogProps {...props} forwardedRef={ref} />;
  });
}
```

# fcreateRef
React.createRef 创建一个能够通过 ref 属性附加到 React 元素的 ref 对象，通过 current 取得实例，比如 DOM 结点的引用。
```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }
  render() {
    return <input type="text" ref={this.inputRef} />;
  }
  componentDidMount() {
    this.inputRef.current.focus();
  }
}
```

# fforwardRef
React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。
React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 ref 作为参数来调用此函数。此函数应返回 React 节点。
```jsx
const FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));
const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```
在上述的示例中，React 会将 <FancyButton ref={ref}> 元素的 ref 作为第二个参数传递给 React.forwardRef 函数中的渲染函数。
该渲染函数会将 ref 传递给 <button ref={ref}> 元素。
因此，当 React 附加了 ref 属性之后，ref.current 将直接指向 <button> DOM 元素实例。


# f事件系统
事件系统是 React 模拟浏览器的事件运行机制，实现的一套提供`合成事件、冒泡/捕获机制、事件委托`的系统。
*React为什么有自己的事件系统?*
1. 提供兼容性。
对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架 (e.xx都可以用)，为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。
2. 集中委托、统一管理
v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。造成一些不可控的情况。由于不是绑定在真实的 DOM 上，所以 React 需要模拟一套事件流：事件捕获 -> 事件源 -> 事件冒泡，也包括重写一下事件源对象 event 。
3. 支持 SSR 和 跨端
这种事件系统，大部分处理逻辑都在底层处理了，这对后期的 ssr 和跨端支持度很高。

# f绑定事件 f事件绑定
1. 建立`合成事件`映射到`原生事件数组`的映射表
这个阶段在 react-dom 加载完毕后就执行，执行各个插件的 registerEvents 方法，注册 React事件系统 定义的 冒泡/捕获阶段 的事件。
建立 React合成事件 -- 原生事件列表 映射表，然后把原生事件都放到 allNativeEvents 这个集合里。[registerDirectEvent]
  ```js
  const registrationNameDependencies = {
    onChange: ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange'],
    onClick: ['click'],
    ...
  }
  const allNativeEvents = new Set();
  allNativeEvents.add(dependencies[i]);
  ```
2. React.createRoot 为入口函数，开始执行运行时代码。
3. listenToAllSupportedEvents 遍历所有原生事件，逐一将回调函数绑定到 div#root 上。
4. addTrappedEventListener 
  - 得到某个原生事件的回调函数，如 click 的回调函数。
  具体的做法是: 执行 createEventListenerWrapperWithPriority，根据原生事件得到优先级, 如 click 事件得到 DiscreteEventPriority，再通过优先级得到回调函数, 对于 click 事件，绑定的是 dispatchDiscreteEvent。
  - 将回调函数注册到 div#root 上。
  具体的做法是: 以 click 事件为例，获取整个 React应用的容器 div#root 结点，然后通过 addEventListener 这个 API，将回调函数加入到 click 事件的回调中。
 
# f触发事件 f事件触发
触发合成事件 onClick 的流程:
1. 触发 div#root 的原生 click 事件， 监听 click 事件的回调是 dispatchDiscreteEvent，触发这个回调函数。
2. 在批处理的上下文中，执行回调。
3. 执行 dispatchEventsForPlugins 方法
  - 3.1 收集回调和合成事件源e [执行事件插件的提取事件方法，如SimpleEventPlugin.extractEvents()]
      1. 收集回调函数 
          从触发事件的 fiber 开始一路往上窜到 rootFiber，收集沿途监听 onClick 的所有 fiber 的信息，构建出 listeners 数组。
      2. 创建合成事件源e
        如果收集到的 listeners 数组不为空，就实例化合成事件源 e:
          * 把原生事件源的一些属性复制到合成事件源上，比如 altKey, bubbles, ...。 
          * 自定义 preventDefault方法 以及 stopPropagation 方法。
  - 3.2 依次触发回调 [processDispatchQueue]
      遍历 listeners 数组，传入合成事件源，依次触发事件。如果是冒泡阶段就从头到尾遍历，如果是捕获阶段就从尾到头遍历，以模拟浏览器事件传播机制。
    遍历的过程，如果在某个回调上，执行了 stopPropagation，就把合成事件源的 isPropagationStopped 赋值为一个只会返回 true 的函数。然后后续继续遍历的时候，检查`e.isPropagationStopped()`时会返回 true, 那么就会 return 掉，停止遍历。


## f合成事件 f事件合成
合成事件是指，在 React 中的一个事件，是由原生浏览器的一个或多个事件合成的。比如 React 的 onChange 事件，是由 'change', 'click', 'focusin', 'focusout' 等多个原生事件合成的。React 用很多一系列事件插件来定义`合成事件`由哪些原生事件合成, 比如 ChangeEventPlugin 定义的就是 onChange。
触发合成事件后的合成事件源 e 是由 React 自己定义的事件基类 SyntheticBaseEvent 实例化而来。
```js
// 源码位于 ～/react/packages/react-dom/src/events/SyntheticEvent.js
function createSyntheticEvent(Interface: EventInterfaceType) {
  function SyntheticBaseEvent() {
    // 把原生事件的属性，复制到合成事件上。
  }
  // 自定义 preventDefault 和 stopPropagation 方法。
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: fn1,
    stopPropagation: fn2,
  })
  // 工厂类
  return SyntheticBaseEvent;
}
```
```ts
// 合成事件类
interface BaseSyntheticEvent<E = object, C = any, T = any> {
  // 浏览器的原生事件
  nativeEvent: E;
  // 绑定了合成事件的 React 原生组件对应的 DOM 结点，如 button 的上级 div
  currentTarget: C;
  // 触发了合成事件的 React 原生组件对应的 DOM 结点，如 button
  target: T;
  // 自定义的阻止浏览器默认行为方法
  preventDefault(): void;
  // 自定义的停止冒泡方法
  stopPropagation(): void;
  // ...
}
```

# f事件插件
事件插件记录了 React合成事件 和 浏览器原生事件之间的映射关系，每个插件主要提供 2 个方法，一个是 registerEvents 用于事件注册，一个是 extractEvents 用于事件触发。
1. [registerEvents]
加载 react-dom 这个包后，立即执行插件的 registerEvents 方法，将 合成事件对应的原生事件，记录到全局映射表 registrationNameDependencies 和集合 allNativeEvents 中。
2. [extractEvents]
触发合成事件时，会调用插件的 extractEvents 方法:
  - 创建合成事件源e
  通过 createSyntheticEvent 方法，得到一个合成事件实例。
  - 创建回调列表listeners
  从触发合成事件的fiber开始，往上，只有要组件监听了该合成事件，如(onClick), 都做成一个对象 { instance:Fiber, listener, currentTarget },
  存到一个数组 listeners 里。
3. 源码位于: ~/react/packages/react-dom/src/events/DOMPluginEventSystem.js


# fbubbles fevent.bubbles
返回一个布尔值，表明当前事件是否会向 DOM 树上层元素冒泡。


# fProfiler
React.Profiler 是一个 React 组件，用于测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，从而使用 React 性能优化 API 来优化应用。
*用法*
Profiler 接收 2 个参数，一个是子树的 id，一个是当组件树中的组件“提交”更新的时候被React调用的回调函数 onRender(function)。
*源码*
源码位于: ~/react/packages/react-reconciler/src/ReactFiberCommitWork.new.js: commitLayoutEffectOnFiber, 即在 commit 阶段的 layout 阶段触发。

## fonRender  Profiler.onRender
Profiler 需要一个 onRender 函数作为参数。 React 会在 profile 包含的组件树中任何组件 “提交” 一个更新的时候调用这个函数。 它的参数描述了渲染了什么和花费了多久。
主要的指标是 actualDuration, 它代表本次更新 committed 花费的渲染时间，使用 React 性能优化 API 之后，对比更新前后的 actualDuration 能得到提升的效率。

**例子 fReact.Profiler**
```jsx
// DEMO
function App() {
  const onRenderCallback = (
    id, // 发生提交的 Profiler 树的 “id”
    phase, // "mount" 或 "update" 
    actualDuration, // 本次更新 committed 花费的渲染时间
    baseDuration, // 估计不使用 memoization 的情况下渲染整颗子树需要的时间
    startTime, // 本次更新中 React 开始渲染的时间
    commitTime, // 本次更新中 React committed 的时间
    interactions // 属于本次更新的 interactions 的集合
  ) => {
    // 合计或记录渲染时间。。。
  }
  return (
    <div>
      <React.Profiler id="Middle" onRender={onRenderCallback}>
        <Middle />
      </React.Profiler>
    </div>
  );
}

// Profiler源码
function commitLayoutEffectOnFiber(.., finishedWork: Fiber) {
  switch (finishedWork.tag) {
    ...
    case Profiler: {
      if (enableProfilerTimer) {
        if (typeof onRender === 'function') {
          onRender(
            finishedWork.memoizedProps.id,
            phase,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitTime,
          );
        }
      }
    }
  }
}
```


# fPortals
*讲概念*
Portal 是 React 官方提供的一种`将子节点渲染到父组件以外DOM节点`的方案。通过 ReactDOM.createPortal 来使用。
*说用途*
1. Portal 适用于需要子组件在视觉上`跳出`其容器的场景，例如，对话框、悬浮卡以及提示框。
*注意点*
1. 事件冒泡仍会到达 React 父组件
尽管组件存在于外部 DOM 下，但它仍处于 React 树中，所以其内部触发的事件仍会冒泡到 React 祖先组件上。
*举例子*
```jsx
const modalRoot = document.getElementById('modal-root');
class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement('div');
  }
  componentDidMount() {
    // 在 Modal 的所有子元素被挂载后，这个 portal 元素会被嵌入到 DOM 树中，这意味着子元素将被挂载到一个分离的 DOM 节点中。
    modalRoot.appendChild(this.el);
  }
  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }
  render() {
    return ReactDOM.createPortal(this.props.children,this.el);
  }
}
class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { clicks: 0 };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick(e) {
    // 当子元素里的按钮被点击时，这个将会被触发更新父元素的 state，即使这个按钮在 DOM 中不是直接关联的后代。
    this.setState(state => ({
      clicks: state.clicks + 1
    }));
  }
  render() {
    return (
      <div onClick={this.handleClick}>
        <p>Number of clicks: {this.state.clicks}</p>
        <p>在真实 DOM 树中，button 结点不是 div 结点的子结点。</p>
        <Modal>
          <Child />
        </Modal>
      </div>
    );
  }
}
function Child() {
  // 这个按钮的点击事件会冒泡到 React 祖先组件，因为这里没有定义 'onClick' 属性。
  return (
    <div className="modal">
      <h1>被挂载在 Portal 上的组件</h1>
      <button>Click</button>
    </div>
  );
}
```

## fcreatePortal
[注意这是ReactDOM暴露的方法]
ReactDOM.createPortal(child, container) 接收 2 个参数:
1. 第 1 个参数 child 是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。
2. 第 2 个参数 container 是一个 DOM 元素，child 对于的真实DOM结点，将被挂载到 container 下。



# f性能优化
React 性能优化主要关注点在于: 避免子树的不必要渲染，对于此项性能优化，我总结了 3 个步骤:
*React性能优化应该遵循的步骤*
1. 寻找项目中的损耗性能严重的子树
2. 在子树的根结点使用性能优化API
3. 子树中运用分离变与不变的原则
**寻找项目中的损耗性能严重的子树**
通过 React DevTool 等工具，找到项目中性能损耗严重的子树。
**在子树的根结点使用性能优化API**
PureComponent, React.memo, React.useMemo，让子树的根结点满足性能优化的条件，复用上一次的渲染结果。
**子树中运用分离变与不变的原则**
子树从根结点收到的 props 对象不变以后，再通过分离变与不变的原则，尽量去命中性能优化的策略。
搜索🔍 [例子]: f使用React性能优化API

*f分离变与不变原则*
通俗来讲，就是把 React组件中，变的部分和不变的部分分离，变的部分有 props, state, context。
比如有一个耗时的函数组件，想要让它命中 React 的性能优化机制，本质上就是复用上一次的渲染结果，在函数组件里就是返回值。而能够复用上一次渲染结果，就说明它本次`执行`的返回值跟上次是一样的，返回值只受 props, state, context 这三者影响。所以，要让耗时组件命中性能优化，就需要使这三者都不变:
  1. props: 是从父组件传过来的，因此需要让父组件满足性能优化，也就是父组件的的 props, state, context 都不变。
  2. state: 子组件自己维护，使它不变。
  3. context: 使 Context 提供的值不变。
搜索🔍 [例子]: f分离变的部分与不变的部分
**总结**
1. 即使我们不使用任何性能优化 API，单单是分离好变与不变的部分，我们也可以优化 React 组件。
2. 这个方法的本质是，把父组件的变的部分抽离出来，实际上起到性能优化效果的是子孙组件。

*React性能优化API原理*
React性能优化API, 本质上就是要将组件更新前后的`props对象全等比较`改为`props对象浅比较`。
**props对象全等比较**
全等比较是 React 默认的 props 比较方法，它比较两个 props 对象引用的地址，如果不相等，说明组件有更新。
**全等比较源码**
```js
// ~/react/packages/react-reconciler/src/ReactFiberBeginWork.js
function beginWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;
    if (oldProps !== newProps) {
      // 比较更新前后的 props 对象，发现引用不相等，React 认为组件有更新，于是重新 render。
      didReceiveUpdate = true;
    }
  }
}
```
**props对象浅比较**
浅比较是 props 对象变化前后，里面的每一个 key，对应的 value 都一一比较，这种方法是不高效的，但是更容易命中性能优化。通过 React 性能优化 API 开启浅比较，如 React.memo。这样 memo 下面的子组件，更新前后会收到两个引用地址一样的空 props 对象，通过全等比较。
**React.memo原理**
1. beginWork -> updateSimpleMemoComponent 
2. shallowEqual(prevProps, nextProps) 浅比较 props 对象，发现相等。
3. 检查 state 和 context 是否更新，发现没有更新。
4. bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)  命中 bailout 逻辑，复用上一次的渲染结果。

**例子 f使用React性能优化API**
```jsx
const numCtx = React.createContext(0);
const updateNumCtx = React.createContext(() => { });
// 只有父组件传递进来的 props, 没有 state, 也没有 context。
// 造成重新渲染的原因，就是父组件重新渲染，传递了一个新的 空 props 对象，经过引用比较，发现不一致，所以 render。
// 🔥让 Middle 命中性能优化的方法:
// 通过 React.memo 包裹，把 props 对象更新前后的 引用比较 改为 浅比较，如果浅比较相同就复用上一次的渲染结果，本次不 render。
// Button 子组件收到的 props 就是上一次渲染父组件传给它的 props，那么前后 props 的引用就是相同的，state, context 都没变，所以不会 render，达到了性能优化的目的。
const Middle = React.memo(() => {
  return (
    <>
      <Button />
      <Show />
    </>
  )
});
function Button() {
  const updateNum = useContext(updateNumCtx);
  console.log('btn render')
  return (
    <button onClick={() => updateNum(Math.random())}>产生随机数</button>
  )
}
function Show() {
  const num = useContext(numCtx);
  return <p>num is: {num}</p>;
}
function App() {
  const [num, updateNum] = useState(0);
  return (
    <numCtx.Provider value={num}>
      <updateNumCtx.Provider value={updateNum}>
        <Middle />
      </updateNumCtx.Provider>
    </numCtx.Provider>
  );
}
```

**例子 f分离变的部分与不变的部分 DEMO1**
1. 修改前，每次输入文本都会重新渲染 ExpensiveCpu 组件，卡 100ms。
2. 修改后，将父组件的 state 转移到 Input 组件。这样父组件就满足了性能优化条件，传给 耗时组件的 props 就不变了。
```jsx
// 修改前
function PerformanceDemo1() {
  const [text, setText] = useState('');
  return (
    <div>
      <input onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
      <ExpensiveCpu />
    </div>
  )
}
function ExpensiveCpu() {
  let now = Date.now();
  while (Date.now() - now < 100) { }
  console.log('耗时的组件render~');
  return <h1>耗时的组件</h1>
}
```
```jsx
// 修改后
function PerformanceDemo2() {
  return (
    <div>
      <Input />
      <ExpensiveCpu />
    </div>
  )
}
function Input() {
  const [text, setText] = useState('');
  return (
    <>
      <input onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
    </>
  )
}
function ExpensiveCpu() {
  let now = Date.now();
  while (Date.now() - now < 100) { }
  console.log('耗时的组件render~');
  return <h1>耗时的组件</h1>
}
```

**例子 f分离变的部分与不变的部分 DEMO2**
1. 修改前，每次输入文本都会重新渲染 ExpensiveCpu 组件，卡 100ms。
2. 修改后，将父组件的 state 转移到 InputWrapper 组件, 父组件变的部分全部清空。 InputWrapper 组件通过 children 插槽接收子组件。状态变化时，只有 InputWrapper 有变的部分，耗时组件是在父组件中的，父组件是不变的，所以耗时组件也不变，变的只是 InputWrapper 组件。
```jsx
// 修改前
// 这个例子也是将变的部分与不变的部分分离，但是利用了插槽的特性
function PerformanceDemo1() {
  const [text, setText] = useState('');
  return (
    <div title={text}>
      <input onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
      <ExpensiveCpu />
    </div>
  )
}
function ExpensiveCpu() {
  let now = Date.now();
  while (Date.now() - now < 100) { }
  console.log('耗时的组件render~');
  return <h1>耗时的组件</h1>
}
```
```jsx
// 修改后
function PerformanceDemo1() {
  return (
    <InputWrapper>
      <ExpensiveCpu />
    </InputWrapper>
  )
}
function InputWrapper({ children }) {
  const [text, setText] = useState('');
  return (
    <div title={text}>
      <input onChange={(e) => setText(e.target.value)} />
      <p>text is {text}</p>
      { children}
    </div>
  )
}
function ExpensiveCpu() {
  let now = Date.now();
  while (Date.now() - now < 100) { }
  console.log('耗时的组件render~');
  return <h1>耗时的组件</h1>
}
```

# fJSX
*讲概念*
JSX 是 React.createElement(component, props, ...children) 函数的语法糖。
**JSX例子 编译JSX**
```jsx
// JSX
<MyButton color="blue" shadowSize={2}>Click Me</MyButton>
// 编译为
React.createElement(MyButton, {color: 'blue', shadowSize: 2}, 'Click Me');
```
*说用途*
1. 直观地编写 React 组件的 UI。
*注意点*
1. 必须引入 React 库
我们在使用 JSX 时，必须引入 React，虽然从写法上看不出来用了 React 这个库，但是编译后用到了 React.createElement，所以 React 库也必须包含在 JSX 代码作用域内。
如果你不使用 JavaScript 打包工具而是直接通过 script 标签加载 React，则必须将 React 挂载到全局变量中。
2. 可以在 JSX 类型中使用点语法
在 JSX 中，你也可以使用点语法来引用一个 React 组件。当你在一个模块中导出许多 React 组件时，这会非常方便。
3. 用户定义的组件必须以大写字母开头
小写字母开头的元素代表一个 HTML 原生结点，比如 div 或 span，他们会生成相应的字符串'div'或者'span'，传递给 React.createElement 作为参数。
大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件，如 Foo 会编译为 React.createElement(Foo)。
4. 在运行时选择类型
我们不能将通用表达式作为 React 元素类型。如果你想通过通用表达式来（动态）决定元素类型，你需要首先将它赋值给`大写字母开头`的变量。这通常用于根据 prop 来渲染不同组件的情况下。
5. 返回一个数组
React 组件也能够返回存储在数组中的一组元素。
6. {} 中的子元素
我们可以将包裹在 {} 中的 JS 表达式、函数、布尔值、Null、Undefined 作为子元素。

**JSX {} 中的子元素**
```jsx
// JavaScript 表达式可以被包裹在 {} 中作为子元素。例如，以下表达式是等价的：
<MyComponent>foo</MyComponent>
<MyComponent>{'foo'}</MyComponent>

// false, null, undefined, and true 是合法的子元素。但它们并不会被渲染。以下的 JSX 表达式渲染结果相同：
<div>{true}</div>
<div />
<div></div>
<div>{false}</div>
<div>{null}</div>
<div>{undefined}</div>

// 值得注意的是有一些 “falsy” 值，如数字 0，仍然会被 React 渲染。例如，当数组为空时以下代码会渲染为数字 0
<div>
  {props.messages.length && <MessageList messages={props.messages} />}
</div>
// 要解决这个问题，确保 && 之前的表达式总是布尔值
<div>
  {props.messages.length > 0 && <MessageList messages={props.messages} />}
</div>
// 反之，如果你想渲染 false、true、null、undefined 等值，你需要先将它们转换为字符串
<div>
  My JavaScript variable is {String(myVariable)}.
</div>
```

**JSX例子 返回一个数组是可行的**
```jsx
render() {
  // 不需要用额外的元素包裹列表元素！
  return [
    // 不要忘记设置 key :)
    <li key="A">First item</li>,
    <li key="B">Second item</li>,
    <li key="C">Third item</li>,
  ];
}
```

**JSX例子 在运行时选择类型**
```jsx
import React from 'react';
import { PhotoStory, VideoStory } from './stories';
const components = {
  photo: PhotoStory,
  video: VideoStory
};
function Story(props) {
  // 正确！JSX 类型可以是大写字母开头的变量。
  const SpecificStory = components[props.storyType];
  return <SpecificStory story={props.story} />;
}
```
**JSX例子 可以在 JSX 类型中使用点语法**
```jsx
import React from 'react';
const MyComponents = {
  DatePicker: function DatePicker(props) {
    return <div>Imagine a {props.color} datepicker here.</div>;
  }
}
function BlueDatePicker() {
  return <MyComponents.DatePicker color="blue" />;
}
```
**JSX例子 必须引入 React 库**
```jsx
import React from 'react';
import CustomButton from './CustomButton';
function WarningButton() {
  // return React.createElement(CustomButton, {color: 'red'}, null);
  return <CustomButton color="red" />;
}
```


# f高阶组件 fHOC  Higher-Order Components
*讲概念*
1. 高阶组件又称为 HOC, 是 React 中用于复用组件逻辑的一种高级技巧。
2. HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
3. 简单来说，高阶组件是参数为组件，返回值为新组件的函数，组件将 props 转换为 UI，而高阶组件是将组件转换为另一个组件。
*说用途*
1. 解决横切关注点问题
**什么是横切关注点 f横切关注点**
关注点是指基于功能划分系统的一部分，部分关注点「横切」程序代码中的数个模块，即在多个模块中都有出现，它们即被称作「横切关注点」。
举例来说，日志功能就是横切关注点的一个典型案例。日志功能往往横跨系统中的各个业务模块，即“横切”所有需要日志功能的类和方法体。所以我们说日志成为了横切整个系统对象结构的关注点 —— 也就叫做横切关注点。
**HOC解决横切关注点**
1. 定义一个容器函数，将横切关注点的逻辑集中起来，接收被包装的组件，返回一个新的容器组件。该容器组件集成了关注点的逻辑，它接收所有不相关的 props，把 props 传递给被包装的组件，渲染被包装组件的 UI。容器函数完成后，我们可以让被`横切`到的组件共享它。
```jsx
// 此函数接收一个组件, 以及一个获取数据的方法，返回另一个组件，这个返回的组件已经嵌入了公用的逻辑:
//  1. 在挂载时，向 DataSource 添加一个更改侦听器。
//  2. 在侦听器内部，当数据源发生变化时，调用 setState。
//  3. 在卸载时，删除侦听器。
function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = { data: selectData(DataSource, props) };
    }
    componentDidMount() {
      DataSource.addChangeListener(this.handleChange);
    }
    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }
    handleChange() {
      this.setState({ data: selectData(DataSource, this.props) });
    }
    render() {
      // 使用新数据渲染被包装的组件! 请注意，我们可能还会传递其他属性。
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}
```
*注意点*
1. HOC 是纯函数，没有副作用。
HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。
2. 不要试图在 HOC 中修改组件原型。
比如 `InputComponent.prototype.componentDidUpdate = function() {...}`，这样做会产生一些不良后果:
  - 输入组件再也无法像 HOC 增强之前那样使用了
  - 如果你再用另一个同样会修改 componentDidUpdate 的 HOC 增强它，那么前面的 HOC 就会失效！
  - 这个 HOC 也无法应用于没有生命周期的函数组件
HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能。
3. 将不相关的 props 传递给被包裹的组件
HOC 为组件添加特性。自身不应该大幅改变约定。HOC 返回的组件与原组件应保持类似的接口。
HOC 应该透传与自身无关的 props。大多数 HOC 都应该包含一个 render 方法，剔除横切关注点需要的 props，将剩下的 props 传递给被包装的组件。
4. 不要在 render 方法中使用 HOC。
每次调用 render 函数都会创建一个新的增强组件，这将导致子树每次渲染都会进行卸载，和重新挂载的操作！这不仅仅是性能问题，重新挂载组件会导致该组件及其所有子组件的状态丢失。如果在组件之外创建 HOC，这样一来组件只会创建一次。因此，每次 render 时都会是同一个组件。一般来说，这跟你的预期表现是一致的。
5. 务必复制静态方法
当我们将 HOC 应用于组件时，原始组件将使用容器组件进行包装。这意味着新组件没有原始组件的任何静态方法。
为了解决这个问题，我们可以在返回之前把这些方法拷贝到容器组件上。但要这样做，我们需要知道哪些方法应该被拷贝，可以使用 hoist-non-react-statics 自动拷贝所有非 React 默认的静态方法(如 static getDerivedStateFromProps 不会被拷贝)。
6. Refs 不会被传递
虽然高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。这个问题的解决方案是通过使用 React.forwardRef API，forwardRef 收到 ref 以后传递给容器组件，容器组件再转发给被包装的组件。

**HOC例子 不要试图在 HOC 中修改组件原型**
```jsx
function logProps(InputComponent) {
  InputComponent.prototype.componentDidUpdate = function(prevProps) {
    console.log('Current props: ', this.props);
    console.log('Previous props: ', prevProps);
  }
  return InputComponent;
}
// 应该通过包装
function logProps(WrappedComponent) {
  return class extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('Current props: ', this.props);
      console.log('Previous props: ', prevProps);
    }
    render() {
      return <WrappedComponent {...this.props} />;
    }
  }
}
// 每次调用 logProps 时，增强组件都会有 log 输出
const EnhancedComponent = logProps(InputComponent);
```
**HOC例子 将不相关的 props 传递给被包裹的组件**
```jsx
render() {
  // 过滤掉非此 HOC 额外的 props，且不要进行透传
  const { extraProp, ...passThroughProps } = this.props;
  // 将 props 注入到被包装的组件中。
  // 通常为 state 的值或者实例方法。
  const injectedProp = someStateOrInstanceMethod;
  // 将 props 传递给被包装组件
  return (
    <WrappedComponent
      injectedProp={injectedProp}
      {...passThroughProps}
    />
  );
}
```
**HOC例子 不要在 render 方法中使用 HOC**
```jsx
render() {
  // 每次调用 render 函数都会创建一个新的 EnhancedComponent; EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
  return <EnhancedComponent />;
}
```
**HOC例子 务必复制静态方法**
```jsx
import React from 'react';
import hoistNonReactStatic from 'hoist-non-react-statics';

function enhance(WrappedComponent) {
  class Enhance extends React.Component {
    constructor(props) {
      super(props);
    }
    render() {
      return <WrappedComponent {...this.props} />
    }
  }
  hoistNonReactStatic(Enhance, WrappedComponent);
  return Enhance;
}

class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { age: 10 };
  }
  static getDerivedStateFromProps(props, state) {
    return { age: 18 }
  }
  render() {
    return <h1>MyComponent</h1>;
  }
}
MyComponent.staticMethod = function () {
  console.log('I am static.');
}
export default enhance(MyComponent);
```
**HOC例子 高阶组件转发Refs**
```jsx
function logProps(Component) {
  class LogProps extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('old props:', prevProps);
      console.log('new props:', this.props);
    }
    render() {
      const {forwardedRef, ...rest} = this.props;
      // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
      return <Component ref={forwardedRef} {...rest} />;
    }
  }
  // 注意 React.forwardRef 回调的第二个参数 “ref”。
  // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
  // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
  return React.forwardRef((props, ref) => {
    return <LogProps {...props} forwardedRef={ref} />;
  });
}
```

*三方库*
1. HOC 在第三方库中很常见，比如 Redux 的 connect 函数、Relay 的 createFragmentContainer。
```jsx
// redux 的 connect 函数
const ConnectedComment = connect(commentSelector, commentActions)(CommentList);
// 刚刚发生了什么？！如果你把它分开，就会更容易看出发生了什么:
// connect 是一个函数，它的返回值为另外一个函数。
const enhance = connect(commentListSelector, commentListActions);
// 返回值为 HOC，它会返回已经连接 Redux store 的组件
const ConnectedComment = enhance(CommentList);
```


# f错误边界 fErrorBoundary
*讲概念*
错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。
*说用途*
部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React16 引入了这个新的概念——错误边界。
*列写法*
1. 类组件中定义`static getDerivedStateFromError`或`componentDidCatch`这两个生命周期方法中的任意多个时，它就变成一个错误边界。
2. 当抛出错误后，使用`static getDerivedStateFromError`设置降级UI的数据，使用`componentDidCatch`打印错误信息。
```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true };  // 更新 state 使下一次渲染能够显示降级后的 UI
  }
  componentDidCatch(error, errorInfo) {
    logErrorToMyService(error, errorInfo);  // 将错误日志上报给服务器
  }
  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;  // 渲染降级后的 UI
    }
    return this.props.children; 
  }
}
```
```jsx
<ErrorBoundary>
  <MyComponent />
</ErrorBoundary>
```
*缺点*
1. 只能在类组件上使用 (包裹的子组件没有限制)
2. 注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。
3. 只能捕获`渲染期间、生命周期方法、整个组件树的构造函数`发生的错误，无法捕获以下场景中产生的错误:
  1. 事件处理
  2. 异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）
  3. 服务端渲染
  4. 它自身抛出来的错误，并非它的子组件
对于这些场景，使用常规的 try/catch 语法来捕获错误。


# 打包
*讲概念*
打包📦是将一个文件和它引用的模块合并到一个单独文件的过程，最终形成一个bundle。接着在页面上引入该bundle，整个应用即可一次性加载。

# Transition
*讲概念*
Transition 是 React18 提出的一个改善用户交互的解决方案。它可以将更新标记为一个 transitions，transitons 可以被中断执行。也就是说，它将更新分为`紧急更新`和`过渡更新`。
1. 紧急更新如输入文本、选中下拉列表一项产生的更新，需要快速给用户反馈，所以会优先渲染。
2. 过渡更新是指从一个视图过渡到另一视图，中间产生的一系列更新，用户不关心这些更新产生的中间状态，只关心最终结果，所以它们`可被中断`且只渲染最终结果。
**例子🌰**
举例来说，比如有一个搜索框，快速输入关键词会实时展示大量搜索结果。每次用户输入都会产生 2 个更新，一个是更新输入框的值(紧急更新)，另一个是更新搜索结果。由于`更新搜索结果`要花费大量时间，且用户更关心输入完成后的结果而不是输入过程中的结果，所以更新搜索结果可以定义为`过渡更新`，它在中间过程会被快速发生的一系列`紧急更新`打断，直到所有的`紧急更新`完毕，`过渡更新`渲染最终的视图。
*说用途(解决了什么问题)*
在大数据量的情况下，一次更新可能引起视图的巨大变化，浏览器需要花费大量时间处理视图而无法响应用户交互，造成卡顿。
*优点*
在以往的方案中，我们常常使用 setTimeout，即使防抖和节流也是如此。下面对比 transition 和 setTimeout 的不同，以展现其优点:
1. 执行时间更早
2. 不会阻塞用户交互
3. 更精确地跟踪loading状态
**执行时间更早**
React.startTransition 中的状态更新是异步，但是包裹状态更新的函数是同步执行的，如果放在 setTimeout 中就是异步执行，所以执行时间更早。
**不会阻塞用户交互**
1. setTimeout 本质上是将`大数据量的那个更新`延迟了，让本次`紧急更新`先渲染，但是延迟的`大数据量的那个更新`终将到来，那时候也会占用浏览器大量时间进行渲染，而无法响应用户交互，所以还是阻塞了用户交互。防抖/节流也是一样的，只是把大量的更新降低为少量的更新，当一次更新非常巨大的时候，无法中断它，也会造成卡顿。
2. 而 transition 的`过渡更新`是可以中断的，`用户交互`到来时优先渲染用户交互，所以不会阻塞。
**更精确地跟踪loading状态**
transition 方案提供了 useTransiton 这个 hook, 它返回一个数组，数组第一项 isPending 代表过渡更新是否正在过渡中, 如果是就是true, 不是就是false, 这可以精确追踪过渡更新的状态，这是 setTimeout 没有实现的。
*列用法*
**fstartTransition**
React.startTransition 接收一个函数 fallback，把 fallback 里面的更新标记为 transitions，它的返回值类型是 void。这个方法是为了在 React.useTransition 不可用时使用。
1. 过渡期的更新会被更紧急的更新取代，如点击操作。
2. 过渡期的更新不会显示重新挂起内容的 fallback，允许用户在渲染更新时继续进行交互。
3. React.startTransition 不提供 isPending 的标志。要跟踪过渡的待定状态，请使用 React.useTransition。
```jsx
// 紧急的更新: 展示用户输入了什么
setInputValue(e.target.value);
// 将包裹到的更新都标记为`过渡`
React.startTransition(() => {
  // 不紧急的更新: 展示搜索结果
  setSearchQuery(e.target.value);
})
```
**fuseTransition**
React.useTransition 接收 0 个参数，返回一个数组:
1. 数组第一项是一个状态值isPending，表示过渡任务的等待状态。
2. 数组第二项是一个函数startTransition，startTransition接收一个函数，将里面的状态更新标记过渡任务。
```jsx
function App() {
  const [isPending, startTransition] = React.useTransition();
  const [count, setCount] = React.useState(0);
  function handleClick() {
    // 将`设置count为count+1`标记为`过渡任务`
    startTransition(() => {
      setCount(c => c + 1);
    })
  }
  return (
    <div>
      {isPending && <Spinner />}
      <button onClick={handleClick}>{count}</button>
    </div>
  );
}
```
*参考*
React工作组的讨论: [https://github.com/reactwg/react-18/discussions/41]


# Refs and the DOM
TODO:


# fAPI fReact顶层API
*组件*
* React.Component
* React.PureComponent
* React.memo
*创建React元素*
* React.createElement
* React.createFactory  [已废弃]
*转换元素*
* React.cloneElement
* React.isValidElement
* React.Children
*Fragments*
* React.Fragment
*Refs*
* React.createRef
* React.forwardRef
*Suspenses*
* React.lazy
* React.Suspense
*Transitions*
* React.startTransition
* React.useTransition
*Context*
* React.createContext
*Hooks*
**基础Hook**
* React.useState
* React.useEffect
* React.useContext
**额外的Hook**
* React.useReducer
* React.useCallback
* React.useMemo
* React.useRef
* React.useImperativeHandle
* React.useLayoutEffect
* React.useDebugValue
* React.useDeferredValue
* React.useTransition
* React.useId
**Library Hooks**
* React.useInsertionEffect
* React.useSyncExternalStore

# fuseState
React.useState 接收一个初始值或一个初始化函数, 返回一个数组，数组第一项是状态值state，第二项是改变状态的函数setState。

1. 初始化的时候，返回的 state 和 initialState 相同。
2. setState 接收一个值或者一个函数，调用后，将一次更新任务加入队列。
3. 如果使用 setState 更新的 state 和之前的 state 相同，React 不会重新渲染组件。

*例子 函数式更新 计数器*
```jsx
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      数量: {count}
      <button onClick={() => setCount(initialCount)}>重置</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>减少</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>增加</button>
    </>
  );
}
```
*例子 初始化函数*
```jsx
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```
*用法*
```jsx
const [state, setState] = React.useState(initialState);
```

# fuseEffect
React.useEffect 接收一个create函数，以及一个 deps 依赖数组。当依赖数组中的任何一项改变时，React 会在组件更新完成后，异步执行 create 函数，并返回一个 destory 函数。
*要点*
1. create 函数会在 commit 阶段完成后异步执行(宏任务)，这时候浏览器已经完成了`布局`与`绘制`，可以获取到最新的 DOM 结点。 之所以设置成异步，是因为请求、订阅这种副作用操作，不应该阻塞浏览器的对屏幕的更新。
2. create 函数一般用来执行一些副作用，如设置定时器, 请求数据, 订阅数据 等，destory 函数用来作清除工作，如退订数据。
3. destory 函数会在组件卸载前执行，通常情况下组件会多次渲染，那么在执行下一个 effect 之前，上一个 effect 就已经被清除。
4. 如果想要执行只运行一次的 effect, 可以传递一个空数组。
*对比 useLayoutEffect*
并非所有的副作用都可以被延迟执行，例如，一个对用户可见的 DOM 操作就必须在浏览器执行下一次绘制之前被同步执行，这时候就应该用 useLayoutEffect，它会在 commit 阶段的 layout 阶段触发，对 DOM 的更新会被浏览器同步渲染。
*用法*
```jsx
useEffect(create, deps);
```
*例子*
```jsx
useEffect(() => {
    const subscription = props.source.subscribe();
    return () => {
      subscription.unsubscribe();
    };
  }, [props.source],
);
```

# fuseContext
React.useContext 接收一个 context 对象，返回该 context 对象的当前值。context 对象一般是 React.createContext(obj) 的返回值。
当前的 context 值由上层组件中距离当前组件最近的`Context.Provider`的`value`属性决定。
当组件上层最近的`Context.Provider`更新时，该`Hook`会触发重渲染，并使用最新传递给`Context.Provider`的`value`值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。

*例子 切换主题*
```jsx
import React, { useContext, useState } from 'react';
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee"
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222"
  }
};
const ThemeContext = React.createContext(themes.light);
function App() {
  const [theme, setTheme] = useState(themes.dark);
  const onChangeTheme = () => {
    setTheme(theme === themes.dark ? themes.light : themes.dark);
  }
  return (
    <ThemeContext.Provider value={theme}>
      <Toolbar />
      <button onClick={onChangeTheme}>change theme</button>
    </ThemeContext.Provider>
  );
}
function Toolbar(props) {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}
function ThemedButton() {
  const theme = useContext(ThemeContext);
  return (
    <button style={{ background: theme.background, color: theme.foreground }}>
      I am styled by theme context!
    </button>
  );
}
```

# fuseReducer
React.useReducer 接收三个参数，返回一个数组。

三个参数分别是:
1. reducer      一个调度函数，传入当前状态state和改变状态的方法action, 返回全新的状态。
2. initialArg   传递给第三个参数init函数的值，一般是state的初始值
3. init         初始值生成函数，接收第二个参数 initialArg，返回值作为 state 的初始值。

返回值是一个数组，包含两项:
1. state        当前的状态
2. dispatch     一个函数，代表改变状态的方法，接收 action，从 reducer 里得到相应的状态。

**注意**
1. 如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行，React 内部通过 Object.is 这个 API 来决定前后 state 是否相同。

*用法*
```jsx
const [state, dispatch] = useReducer(reducer, initialArg, init);
```
*例子*
```jsx
function init(initialCount) {
  return {count: initialCount};
}
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}
function Counter({initialCount}) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({type: 'reset', payload: initialCount})}>
        Reset
      </button>
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

# fcallback fuseCallback
React.useCallback 接收两个参数，第一个是`可能被缓存的函数`，第二个是`依赖数组`，返回一个`缓存函数`。
这个`缓存函数`仅在`依赖数组`的某一项改变时才会更新。
*用法*
```jsx
const memoizedCallback = useCallback(
  () => { doSomething(a, b) },
  [a, b],
);
```
它的作用主要是保持函数的引用不变，这样可以避免一些不必要的`重新渲染`。
比如子组件比较两个引用是否相等，如果父组件用了 useCallback 命中了缓存，那么更新前后传递给子组件的就是同一个引用，子组件就可以不必渲染，提高性能。

# fmemo fReact.memo [下一项是useMemo]
React.memo 接收两个参数，一个`函数组件`，以及一个`比较函数`，返回一个`缓存值`。
当`比较函数`返回 true 时，React 将跳过被 React.memo 包裹的组件的渲染，直接返回最近一次的渲染结果;
当`比较函数`返回 false 时，组件重新渲染，React.memo 返回重新渲染的结果。
*注意*
1. 比较函数默认情况下会`浅比较`更新前后的 props，如果一致返回 true, 不一致返回 false。
2. React.memo 默认仅检查 props。如果被包裹的函数组件使用了 useState，useReducer 或 useContext 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。
*用法*
```jsx
const MemoComponent = React.memo(MyComponent, areEqual);
```
*例子*
```jsx
function MyComponent(props) { /* 使用 props 渲染 */ }
function areEqual(prevProps, nextProps) { /* true: 跳过渲染，返回最近一次渲染结果。 false: 正常渲染。 */ }
export default React.memo(MyComponent, areEqual);
```

# fuseMemo [上一项是React.memo]
useMemo 接收两个参数，一个是`create函数`，一个是`依赖数组`，返回一个缓存值。
当函数组件重新渲染时，如果`依赖数组`中的任何一项发生了改变，`create函数`就会重新执行，返回新的缓存值。
这种优化有助于避免在每次渲染时都进行高开销的计算。
*用法*
```jsx
const memoizedValue = useMemo(create, deps);
```
*注意*
1. 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。
2. 如果传入 deps 一个空数组，那么 useMemo 将只保留第一次的缓存，不会刷新缓存。
3. 不要把副作用这类的操作放在 create 函数中，这属于 useEffect 的适用范畴。传入 useMemo 的函数会在渲染期间执行，而不是渲染完成后。

# f回调ref
给 React 原生DOM元素的 ref 属性传递一个回调函数，这个回调函数将会收到 DOM 实例。
```jsx
class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = null;
    this.setTextInputRef = (element) => { this.textInput = element };
  }
  componentDidMount() {
    // 获得 text 输入框 DOM 结点
    console.log(this.textInput);
  }
  render() {
    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React 实例上
    return (
      <div>
        <input type="text" ref={this.setTextInputRef}  />
      </div>
    );
  }
}
```

# fuseRef
React.useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为 useRef 接收的参数(initialValue)。
返回的 ref 对象在组件的整个生命周期内持续存在。

本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。

*例子 命令式地访问子组件*
```jsx
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // `current` 指向已挂载到 DOM 上的 input 元素
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}
```

# fuseImperativeHandle
一般情况下，我们不可以直接引用一个函数组件。但是 useImperativeHandle 可以让你使用 ref 调用一些子组件暴露的方法。
useImperativeHandle 应当与 forwardRef 一起使用。
*例子 父组件调用子组件暴露的方法doit*
```jsx
// 子组件
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () => ({
    doit: () => {
      // 这里完全可以换成一句 log 啥的，和 useRef 没有关系的那种。
      inputRef.current.focus();
    }
  }));
  return <input ref={inputRef} ... />;
}
FancyInput = forwardRef(FancyInput);

// 父组件
function Parent() {
  const ref = useRef();
  useEffect(() => {
    ref.current.doit();
  })
  return (
    <div>
      <FancyInput ref={ref}>
    <div>
  )
}
```
*用法*
```jsx
useImperativeHandle(ref, createHandle, [deps]);
```


# fuseLayoutEffect
1. 在 commit 阶段的 layout 阶段同步执行，也就是所有的 DOM 变更之后同步调用。
2. 使用方法和 useEffect 相同。
3. 可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。
注意: 尽可能使用标准的 useEffect 以避免阻塞视觉更新。
*用法*
```jsx
useLayoutEffect(create, deps);
```
*例子*
```jsx
function Demo() {
  React.useLayoutEffect(() => {
    console.log('commit阶段-layout阶段同步执行')
  }, []);
  return <div>Demo</div>
}
```


# fuseDebugValue
React.useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。
*例子*
```jsx
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);
  // 在开发者工具中的这个 Hook 旁边显示标签
  // e.g. "FriendStatus: Online"
  useDebugValue(isOnline ? 'Online' : 'Offline');
  return isOnline;
}
```
**延迟格式化 debug 值**
在某些情况下，格式化值的显示可能是一项开销很大的操作。除非需要检查 Hook，否则没有必要这么做。
因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 Hook 被检查时才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。
例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用:
```jsx
useDebugValue(date, date => date.toDateString());
```

# fuseDeferredValue
React.useDeferredValue 接受一个值，并返回该值的新副本，该副本将推迟到更紧急的更新之后。
如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。

该 hook 与使用防抖和节流去延迟更新的用户空间 hooks 类似。
使用 useDeferredValue 的好处是，React 将在其他工作完成后立即进行更新，而不是等待任意时间。并且像 startTransition 一样，延迟值可以暂停，而不会触发现有内容的意外降级。

useDeferredValue 仅延迟你传递给它的值。
如果你想要在紧急更新期间防止子组件重新渲染，则还必须使用 React.memo 或 React.useMemo 记忆该子组件:
*例子 延迟并防止子组件重渲染*
```jsx
function Typeahead() {
  const query = useSearchQuery('');
  const deferredQuery = useDeferredValue(query);
  // Memoizing 告诉 React 仅当 deferredQuery 改变，
  // 而不是 query 改变的时候才重新渲染
  const suggestions = useMemo(() =>
    <SearchSuggestions query={deferredQuery} />,
    [deferredQuery]
  );
  return (
    <>
      <SearchInput query={query} />
      <Suspense fallback="Loading results...">
        {suggestions}
      </Suspense>
    </>
  );
}
```
记忆该子组件告诉 React 它仅当 deferredQuery 改变而不是 query 改变的时候才需要去重新渲染。
这个限制不是 useDeferredValue 独有的，它和使用防抖或节流的 hooks 类似。


# fuseId
useId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。
注意: useId 生成一个包含 : 的字符串 token。这有助于确保 token 是唯一的，但在 CSS 选择器或 querySelectorAll 等 API 中不受支持。
*例子*
```jsx
import { useId } from 'react';

// 直接传递 id 给需要它的元素
function Checkbox() {
  const id = useId();
  return (
    <>
      <label htmlFor={id}>Do you like React?</label>
      <input id={id} type="checkbox" name="react"/>
    </>
  );
};

// 对于同一组件中的多个 ID，使用相同的 id 并添加后缀
function NameFields() {
  const id = useId();
  return (
    <div>
      <label htmlFor={id + '-firstName'}>First Name</label>
      <div>
        <input id={id + '-firstName'} type="text" />
      </div>
      <label htmlFor={id + '-lastName'}>Last Name</label>
      <div>
        <input id={id + '-lastName'} type="text" />
      </div>
    </div>
  );
}
```

# fComponent
React.Component 是使用 ES6 class 语法定义 React 组件的基类:
```jsx
class Greeting extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

# fPureComponent  fCompoennt和PureCompoennt的区别
1. React.PureComponent 与 React.Component 很相似。两者的区别在于 React.Component 并未实现 shouldComponentUpdate()，而 React.PureComponent 中以`浅层对比` prop 和 state 的方式来实现了该函数。
2. 如果 prop 或 state 中包含复杂的数据结构，则有可能因为无法检查深层的差别，产生错误的比对结果。
仅在你的 props 和 state 较为简单时，才使用 React.PureComponent，或者在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新。
3. React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新。因此，请确保所有子组件也都是“纯”的组件。
4. 你也可以考虑使用 immutable 对象加速嵌套数据的比较。

# fcreateElement
创建并返回指定类型的新 React 元素。其中的类型参数既可以是标签名字符串（如 'div' 或 'span'），也可以是 React 组件 类型 (类组件或函数组件)，或是 React.Fragment 类型。

*用法*
```js
React.createElement(type, [props], [...children])
```

使用 JSX 编写的代码将会被转换成使用 React.createElement() 的形式。
如果使用了 JSX 方式，那么一般来说就不需要直接调用 React.createElement()。
*JSX*
```jsx
<div>Hello {this.props.toWhat}</div>;
```
*React.createElement*
```js
React.createElement('div', null, `Hello ${ this.props.toWhat}`);
```

# fcreateFactory
此辅助函数已废弃，用 React.createElement 代替它。
返回用于生成指定类型 React 元素的函数，如 'div', 'span', React组件等。


# fcloneElement
以 element 元素为样板克隆并返回新的 React 元素。config 中应包含新的 props，key 或 ref。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。新的子元素将取代现有的子元素，如果在 config 中未出现 key 或 ref，那么原始元素的 key 和 ref 将被保留。
*用法*
```js
React.cloneElement(element,[config],[...children])
```
React.cloneElement() 几乎等同于:
```jsx
<element.type {...element.props} {...props}>{children}</element.type>
```
但是，这也保留了组件的 ref。这意味着当通过 ref 获取子节点时，你将不会意外地从你祖先节点上窃取它。相同的 ref 将添加到克隆后的新元素中。如果存在新的 ref 或 key 将覆盖之前的。
引入此 API 是为了替换已弃用的 React.addons.cloneWithProps()。


# fisValidElement
*用法*
```js
React.isValidElement(object);
```
*解释*
传入一个对象，验证对象是否为 React 元素，返回值为 true 或 false。


# fChildren
React.Children 提供了用于处理 this.props.children 的实用方法, 类似于数组的方法。
*React.Children.map*
```js
React.Children.map(children, function[(thisArg)])
```
在 children 里的每个直接子节点上调用一个函数，并将 this 设置为 thisArg，返回一个数组。
如果 children 是一个数组，它将被遍历并为数组中的每个子节点调用该函数。如果子节点为 null 或是 undefined，则此方法将返回 null 或是 undefined，而不会返回数组。
*React.Children.forEach*
```js
React.Children.forEach(children, function[(thisArg)])
```
与 React.Children.map() 类似，但它只会遍历，不会返回一个数组。
*React.Children.count*
```js
React.Children.count(children)
```
返回 children 中的组件总数量，等同于通过 map 或 forEach 调用回调函数的次数。
*React.Children.only*
```js
React.Children.only(children)
```
children 可能是个数组，这个 API 能验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。
*React.Children.toArray*
```js
React.Children.toArray(children)
```
将 children 这个复杂的数据结构以数组的方式扁平展开并返回，并为每个子节点分配一个 key。当你想要在渲染函数中操作子节点的集合时，它会非常实用，特别是当你想要在向下传递 this.props.children 之前对内容重新排序或获取子集时。


# fFragment
*讲概念*
函数组件(或类组件render方法)不能直接返回多个元素，必须由一个元素包裹着这多个元素。而 React.Fragment 组件能够在不额外创建 DOM 元素的情况下，让函数组件(或类组件render方法)返回多个元素。
*🔥注意*
1. 我们也可以使用其简写语法 <></>。
2. 使用 React.Fragement 语法声明的片段可能具有 key。key 是唯一可以传递给 Fragment 的属性。一个使用场景是将一个集合映射到一个 Fragments 数组。
*例子1*
```jsx
class Columns extends React.Component {
  render() {
    return (
      <React.Fragment>
        <td>Hello</td>
        <td>World</td>
      </React.Fragment>
    );
  }
}
// 正确渲染 table
class Table extends React.Component {
  render() {
    return (
      <table>
        <tr>
          <Columns />
        </tr>
      </table>
    );
  }
}
```
*例子2*
```jsx
function Glossary(props) {
  return (
    <dl>
      {props.items.map(item => (
        // 没有`key`，React 会发出一个关键警告
        <React.Fragment key={item.id}>
          <dt>{item.term}</dt>
          <dd>{item.description}</dd>
        </React.Fragment>
      ))}
    </dl>
  );
}
```


# flazy
React.lazy() 允许你定义一个动态加载的组件。这有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。
*动态加载一个组件*
```js
const SomeComponent = React.lazy(() => import('./SomeComponent'));
```
注意: 渲染 lazy 组件依赖该组件渲染树上层的 <React.Suspense> 组件。这是指定加载指示器（loading indicator）的方式。


# fSuspense
React.Suspense 使得组件可以“等待”某些操作结束后，再进行渲染, 它通过 fallback 属性指定 Loading 状态展示的组件。
*显示 Spinner 直至 OtherComponent 加载完成*
```js
const OtherComponent = React.lazy(() => import('./OtherComponent'));
function MyComponent() {
  return (
    <React.Suspense fallback={<Spinner />}>
      <div>
        <OtherComponent />
      </div>
    </React.Suspense>
  );
}
```
注意: lazy 组件可以位于 Suspense 组件树的深处——它不必包装树中的每一个延迟加载组件。
最佳实践是将 <Suspense> 置于你想展示 Loading 的位置，而 lazy() 则可被放置于任何你想要做代码分割的地方。


# fstartTransition
配合 React.useTransition 使用。React.startTransition 让你把提供的 fallback 里面的更新标记为 transitions。
*用法*
```js
React.startTransition(callback)
```
*注意*
* 过渡期的更新会被更紧急的更新取代，如点击操作。
* 过渡期的更新不会显示重新挂起内容的 fallback，允许用户在渲染更新时继续进行交互。 (TODO: 查看掘金小册)

# fuseTransition
返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。
*用法*
```js
function App() {
  const [isPending, startTransition] = React.useTransition();
  const [count, setCount] = React.useState(0);
  function handleClick() {
    React.startTransition(() => {
      setCount(c => c + 1);
    })
  }
  return (
    <div>
      {isPending && <Spinner />}
      <button onClick={handleClick}>{count}</button>
    </div>
  );
}
```
*注意*
* startTransition 允许你通过标记更新将提供的回调函数作为一个过渡任务
* isPending 指示过渡任务何时活跃以显示一个等待状态
* 过渡任务中触发的更新会让更紧急地更新先进行，比如点击。
* 过渡任务中的更新将不会展示由于再次挂起而导致降级的内容。这个机制允许用户在 React 渲染更新的时候继续与当前内容进行交互。


# fuseSyncExternalStore
**为库作者提供的，用于将库深入集成到 React 模型中，通常不会在应用程序代码中使用**
useSyncExternalStore 是一个推荐用于读取和订阅外部数据源的 hook，其方式与选择性的 hydration 和时间切片等并发渲染功能兼容。

此方法返回存储的值并接受三个参数：
* subscribe：用于注册一个回调函数，当存储值发生更改时被调用。
* getSnapshot： 返回当前存储值的函数。
* getServerSnapshot：返回服务端渲染期间使用的存储值的函数
*用法*
```jsx
const state = useSyncExternalStore(subscribe, getSnapshot[, getServerSnapshot]);
```

# fuseInsertionEffect
**为库作者提供的，用于将库深入集成到 React 模型中，通常不会在应用程序代码中使用**
1. useInsertionEffect 在所有 DOM 突变之前同步触发。也就是在 commit 阶段的 beforeMutation 阶段触发。
2. 使用它在读取 useLayoutEffect 中的布局之前将样式注入 DOM。
3. 由于这个 hook 的作用域有限，所以这个 hook 不能访问 refs，也不能安排更新。
*注意*
useInsertionEffect 应仅限于 css-in-js 库作者使用。优先考虑使用 useEffect 或 useLayoutEffect 来替代。
*用法*
```jsx
useInsertionEffect(didUpdate);
```


# fsetState是同步还是异步  fthis.setState是同步还是异步
在`React`的不同模式下，`this.setState`有不同的表现:
1. 在 legacy 模式下，如果命中了 batchedUpdate 逻辑，就是异步，如果没有命中 batchedUpdate 逻辑就是同步。
2. 在 concurrent 模式下，this.setState 始终表现为异步。


# fhooks
## 讲概念
Hook 是 React 16.8.0 的新增特性。它让函数组件也能做类组件能做的大部分的事，通过hooks函数组件有了自己的状态，可以处理副作用，能获取 ref 等。
## 说用途 (f解决了什么问题 f问题)
1. 在组件之间复用状态逻辑
2. 组合复杂组件的相关逻辑
3. 拥抱函数式编程

* 在组件之间复用状态逻辑
使用 Hook 可以从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。这使得在组件间或社区内共享 Hook 变得更便捷。
* 组合复杂组件的相关逻辑
在 hook 之前我们常常在组件的生命周期中编写一些不相关的代码，比如在 componentDidMount 中获取数据，同时又设置事件监听，然后在 componentWillUnmount 中清除，这样就把不相关的代码组合在一起，而相关的代码又分在了不同地方，这种写法很容易引起 bug。
为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。
* 拥抱函数式编程
根据官网的描述, 编写 class 的方式使得代码不能很好地压缩，并且会使热重载出现不稳定的情况。为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性, 比如维护状态，处理副作用，获取ref等。这样就能用函数组件替代大部分类组件，拥抱函数式编程。
`官网: 我们准备让 Hook 覆盖所有 class 组件的使用场景，但是我们将继续为 class 组件提供支持。`
## 优缺点

## f原理 fhooks原理 f你来聊一下hooks的原理是什么
hooks 本质上是一条单向链表，存在于fiber.memoizedState，当然这个fiber得是函数组件的fiber，通过 next 指针将本函数组件的所有 hook 顺序连接到一起:`fiber.memoizedState: hook1 -> hook2 -> ...`。

函数组件 render 时，分为 首次执行 和 更新 两种情况。以 useState 为例, `首次执行`做的是生成 hook 加入到 fiber.memoizedState, 返回初始值和更新函数也就是dispatchAction; 而`更新`是执行 dispathAction，本质上就是创建 update 对象，加入到 hook.queue.pending;

两种情况都会依次执行 hook, 计算每个 hook 的状态，放到 hook.memoizedState 中。状态计算是基于 hook.queue.pending 这条环状链表，链表上的每个结构都是一个 Update 对象，update 上保存着用户传入的action, 比如 setCount(c => c + 1), 其中的 c => c + 1 这个箭头函数就是 action。 Hook 会基于 hook 原有的 memoizedState，然后执行一圈的环状链表上的 Update 对象，最终得到新的 memoizedState 返回。
```ts
interface Hook {
  baseQueue: null;
  baseState: unknown;  // 基于某个状态，计算本次 memoizedState
  memoizedState: unknown;   // 本 hook 的状态值
  next: Hook;  // 下一个 hook
  queue: Update;  // hook 上的 Update 对象
}
interface Update {
  action: Function | unknown;  // 如 c=>c+1
  next: Update;  // 指向下一个 update 对象
}
```
## f使用hooks的注意事项
1. 约定命名以useXX开头
2. 必须在函数组件内使用，不能在类组件里使用
3. 必须在函数组件作用域顶部使用
4. 每次组件render不能打乱hooks的执行顺序，比如放到条件语句、或循环语句中是不行的。
## 为什么hook不能放在条件语句中
每次App更新的时候，hooks都必须遵照完全一样的顺序，因为它们是保存在一条链表中的，更新的时候只会按链表顺序更新。如果打乱了顺序，链表结点和组件hook的对应关系就会出错。
## f自定义hooks fReact如何封装自定义hooks
自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。
自定义 hook 的 state 是完全独立的，hook 的每次调用都有一个完全独立的 state，因为在同一个组件中多次调用同一个自定义hook，它们的状态也互不影响。
### f自定义hooks必须以"use"开头吗？
必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。
### f自定义hooks的用途
自定义 Hook 解决了以前在 React 组件中无法灵活共享逻辑的问题。
*定义自定义hooks*
```js
import { useState, useEffect } from 'react';
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });
  return isOnline;
}
```
*使用自定义hooks*
```js
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);
  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}
```

## fhook相关属性
fiber.memoizedState是 hook
hook.memoizedState 是当前 hook 的状态
hook.next 是下一个hook
hook.queue.pending 是最后一个 update，下一个就是第一个 update。
update.next是下一个update
update.action是待更新的操作，如 num => num+1
## fuseEffect feffect
React 在完成对 DOM 的更改后运行“副作用”函数。原理是在 commit 阶段结束后异步执行。
## fuseLayoutEffect
在 commit 阶段结束时同步执行。
## fuseState发生了什么
基于这个useState代表的hook的hook.memoizedState，遍历 hook 的 update 环: hook.queue.pending，顺序执行所有的update，上一个的输出作为下一个的输入，一直计算到最后，得到最终的state，作为新的hook.memoizedState，清空本hook的update环，返回一个数组，数组的第0项是更新后的状态，第1项是dispatch, 然后更新函数组件。
## fsetNum发生了什么
setNum -> 放置update对象到hook上(多次setNum就有多个update对象，形成一个环)App重新render -> 执行 useState -> 得到新状态num -> 基于新状态得到新的ReactElement -> 渲染新视图


# ffiber fReact为什么需要fiber?
## f什么是Fiber
Fiber 包含三层含义: 协调器的架构、静态的数据结构、动态的工作单元。
1. 架构
作为协调器的架构来说，之前 React15 的协调器采用递归的方式执行，数据保存在递归调用栈中，所以被称为 stack reconciler。
而 React16 的协调器基于 Fiber 结点实现，被成为 fiber reconciler。
2. 数据结构
作为静态数据结构来说，每个 fiber 结点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
3. 工作单元
作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

## f纤程
Fiber 并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。

Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。

React Fiber可以理解为:
React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。其中每个任务更新单元为React Element对应的Fiber节点。

## f为什么需要fiber
React 在 16 版本之前，用的是`递归`的方式更新组件，这是一个同步的更新，一旦开始就无法中断，如果这一次更新超过了浏览器一帧的时间，一般是 16 ms，用户交互就会卡顿。显然这不满足 React 快速响应的理念，所以 16 版本以后 React 提出了新的 fiber 架构，用`异步可中断的更新`替代`同步的更新`。

## ffiber解决了哪些问题
1. 解决了 React15 同步更新造成的用户卡顿问题
2. 支持高优先级任务插队低优先级任务
3. 任务中断以后可以恢复，复用之前的中间状态

## f架构 fReact的架构 16之前是什么架构？16之后是什么架构？为什么这么演变？
16 之前，React 只有 协调器 和 渲染器; 16 之后，React 有 调度器、协调器、渲染器。
各模块功能如下:
* 调度器: 调度任务的优先级，高优任务优先进入协调器。
* 协调器: 负责找出变化的组件。
* 渲染器: 负责将变化的组件渲染到页面上。
### Scheduler
Scheduler 是 React 团队为 requestIdleCallback 做的 polyfill,  因为 rIC 有以下缺点:
1. 浏览器兼容性不好;
2. 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低。
### Reconciler
Reconciler 从递归的方式，变为可中断的循环方式，每次循环都会调用 shouldYield(), 如果当前有剩余时间才继续，没有就中断循环。
* 那么React16是如何解决中断更新时DOM渲染不完全的问题呢？
在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记。整个Scheduler与Reconciler的工作都在内存中进行，不展示到视图上。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer，渲染视图。
### Renderer
Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。


# f虚拟DOM fvdom fVirtual DOM
虚拟DOM本质上就是一个对象，该对象描述了一个UI结点所对应的一些必要信息。React 的虚拟DOM 可以理解为 ReactElement 和 Fiber，因为 DIFF 是比较这两者。
## 为什么需要虚拟DOM?
1. 真实DOM的属性太多了，如果直接对真实DOM进diff，消耗性能非常大。
比如，可以在控制台写 document.createElement('div') 得到一个结点，打开这个结点，会看到上面的属性非常多，如果直接做 diff，要对比这么多属性，消耗的性能就非常大。而虚拟 dom 一般就是 { type: 'div', props: {} }, 只需要对比这几个属性，性能损耗大幅降低。
2. 对真实DOM进行curd很消耗性能，可以用虚拟DOM代替。
## 说用途
1. 渲染
2. 比对 dom diff

# fDomDiff fDiff fReactDomDiff fdiff算法
Diff算法的本质是`更新前虚拟dom树`和`更新后虚拟dom树`，找出两者之间的差异。React 原理中，是在对比`当前结点的大儿子`和`JSX返回的 React 元素(数组)`, 从而产生`workInProgress的大儿子`。[ current.child vs ReactElements => workInProgress.child ]
## 说用途 f为什么需要diff算法？
为了提高渲染性能，每次更新应该只渲染有变化的部分，而`diff算法`的目的就是要找出这个变化的部分。
## 制定规则
为了提高对比的性能，React 在 Dom Diff 时制定了三个规则:
1. 只比较同级元素，不跨层级对比。
   如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。
2. 两个不同类型的元素会产生出不同的树。
   React 不会尝试复用不同类型的元素，如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。
3. 通过 key 来标识更新前后是同一个结点。
## 时间复杂度
时间复杂度 O(N)，N 是这一层的结点个数。因为算法本质就是遍历一次老结点，遍历一次新结点。
这个问题实际上是: 同一层上的编辑距离问题。
## 具体过程  fDomDiff的过程
React 的 Dom Diff 分为 单结点diff 和 多结点diff。这里的`单结点`或`多结点`指的是新结点，新结点只有单个就是单结点diff，新结点有多个就是多结点diff。
### 单结点diff
因为只有一个新结点，所以通过 sibling 指针遍历老结点即可，遍历过程比较新老结点的 type 和 key, 有三种情况:
1. 如果 type 和 key 都相同，说明这个老结点可以复用，标记剩余的老结点为`删除`，返回这个可复用的老结点。
2. 如果 key 相同，但是 type 不同，自己和弟弟都标记为删除，跳出遍历，直接新建一个结点，标记`插入`。
3. 如果 key 不同，删除这个老结点，继续遍历下一个老结点。如果遍历完了还是没有结点可复用，那就新建一个结点，标记`插入`。
🌰例子
比如: liA,liB,liC => liB
DIFF过程就是:  
liA => liB ❌ Deletion
liB => liB ✅ 复用
liC        ❌ Deletion
### 多结点diff
分为四步:
1. 同时遍历新老结点，处理更新 (新结点用索引:newIdx++, 老结点用指针: oldFiber = oldFiber.sibling)
2. 如果有剩余的老结点，删除多余的老结点 (deleteRemainingChildren)
3. 如果有剩余的新结点，增加新结点 
4. 处理移动的情况

* 处理移动的情况
在第一步处理更新时，可能因 key 不同而直接跳出循环，这样也跳过了二、三步，直接来到第四步处理移动。
处理移动的步骤:
1. 将剩余的老结点都放入一个 Map 中，以 oldFiber.key 或 oldFiber.index 为键，以 oldFiber本身为值。
2. 设置一个 lastPlacedIndex 变量，代表最后一个可复用的结点在 oldFibers 中的位置索引。
3. 遍历剩余的新结点，通过 newChild.key 查找 Map 中是否有可复用的老结点，可复用是指 key 和 type 都相同:
  
  * 如果有，复用老结点，然后比较 lastPlacedIndex 和 oldFiber.index，由于结点是从左往右遍历的，在没有移动的情况下，新老 index 应该同步变大，
    本次复用的 oldFiber 应该在最后一个可复用的 oldFiber 右边，也就是说 oldFiber.index 应该 >= lastPlacedIndex，但是比较结果有两种情况:

    - oldFiber.index < lastPlacedIndex, 说明 `本次复用的oldFiber` 在`最后一个可复用的oldFiber`左边，也就说明`本次复用的oldFiber`在更新后向右移动了，所以 newFiber 标记为`移动`(移动也就是Placement，在老结点存在的情况下，插入就是移动), lastPlacedIndex 不变。

    - oldFiber.index >= lastPlacedIndex, 说明 `本次复用的oldFiber` 在`最后一个可复用的oldFiber`右边，这说明 `本次复用的oldFiber` 没有移动, 本次复用的oldFiber`要作为`最后一个可复用的oldFiber`给下一轮循环的 oldFiber 作参照物，所以更新 lastPlacedIndex 为 oldFiber.index。

  * 如果没有，创建新的 fiber。

### 多结点diff的例子
liA,liB,liC,liD,liE,liF  => liA,liC,liE,liB,liG,liD
 0   1   2   3   4   5       0   1   2   3   4   5

1. 同时遍历新老结点，liA=>liA 复用，liB=>liC key 不同跳出，进入`处理移动`的环节。
2. 将老 liB 以后的所有老结点放入 Map, 遍历剩余的新结点。
3. lastPlacedIndex 设置为0，在 Map 中查找新结点 liC，发现有可以复用的结点，于是复用，同时更新 lastPlacedIndex 为 oldLiC.index = 2。
4. 继续遍历新结点，liE 可复用，而且 oldLiE.index >= lastPlacedIndex，没有移动，无需标记，更新 lastPlacedIndex 为 oldLiE.index = 4。
5. 继续遍历新结点，liB 可复用，但此时 oldLiB.index < lastPlacedIndex，说明 liB 移动了，标记 `Placement`。
6. 继续遍历新结点，liG 不在老结点中，标记`Placement`。
7. 继续遍历新结点，liD 可复用，oldLiD.index < lastPlacedIndex, 标记 `Placement`。 

                 A        B       C              D                 E               F   
                 A        C       E              B                 G               D
                复用     复用     复用         复用(移动)          不可复用(插入)    复用(移动)
lastPlaceIndex   0        2       4              4                 4               4
                >=       >=      >=    oldIndex < lastPlacedIndex       oldIndex < lastPlacedIndex

## 细节
1. 如果用户没有写 key, 那么 React 认为 key 是 null, 在更新前后对比时，就会得出 key 相同的结论。
2. 检查出 key, type 都相同, 会复用 current 的属性，如 flags, childLanes, lanes, child, memoizedProps, memoizedState, updateQueue, sibling, index, ref。
3. 当 key, type 都不变，只有常规属性改变时，React 会复用 current.alternate 作为 workInProgress，把 pendingProps 放到 workInProgress.pendingProps 上，进行后续状态更新。

### 资料
前端与黑客安全  01:24:52
Electron+游戏引擎+前端黑客与安全 00:10:41  Dom Diff: vue vs react

# fuseEffect 和 fcomponentDidMount 有什么不同？
useEffect 的回调函数 create 会在 commit 阶段结束后，异步执行。
componentDidMount 会在mutation阶段完成视图更新后，在layout阶段同步执行。

这道题在探讨的其实是 useEffect 的 create 函数 fn 与 cDM 的执行时机有什么不同，而 fn 的执行依赖于 useEffect 的第二个参数 deps。所以这道题可以概括为2个问题：
1 deps 如何影响 fn 的执行？
2 fn 和 cDM 的执行时机？

* 第1个问题
useEfffect的标记是 Passive。
useEffect(fn)      每次组件更新，都会打标记
useEffect(fn,[])   只有mount 会打标记
useEffect(fn, deps) 只有mount时，或deps里的元素改了才会打标记

class 组件会在 mount时标记 Placement。

- Placement结点
在 mutation阶段调用 appendChild方法，然后在 layout 阶段调用 cDM方法。
- Passive 结点
在 layout 阶段结束后，异步调用 useEffect的create函数。

* 第2个问题
useEffect的回调函数create 会在commit 阶段结束后异步执行
cDM会在mutation阶段完成视图更新后，在layout阶段同步执行。

useLayoutEffect 和 cDM 的调用时机一致。


==============================fWebpack==============================
# fwebpack生命周期 f工作流程 f构建流程
1. 初始化参数
从配置文件和 shell 语句中读取与合并参数，得出最终的参数。
2. 开始编译
用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始编译。
3. 寻找入口
根据 entry 找到所有 入口文件。
4. 编译模块
从每个入口文件出发，调用所有配置的 loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。
5. 输出资源
根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk，再把每个 chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会。
6. 写入磁盘
在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
在以上过程中，webapck 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，从而可以改变 webpack 的运行结果。

# fchunk
1. chunk 是 webpack 打包过程中，一系列关联 module 的集合。比如有 3 种方式可以产生 chunk:
*入口 chunk*
webpack 从入口模块开始打包，入口模块引用其他模块，模块再引用模块，从入口开始的一系列模块，就形成了一个 chunk，多个入口就有多个 chunk。
*按需加载*
按需加载的模块，比如 import(..), 也会产生 chunk。
*代码分割*
在 webpack 中配置代码分割，会产生 chunk。
2. chunk 在构建完成时，就呈现为 bundle，一般来说，一个 chunk 对应一个 bundle。但是也有例外，比如 devtool 设置为 source-map 时，一个 chunk 会打包出 2 个 bundle，一个是 main.js，一个是 main.js.map, chunk 是过程中的代码块，bundle 是结果的代码块。
## f入口chunk
下面的例子会生成 2 个 chunk, 使用 entry 的 key 命名，所以一个叫 pageA, 一个叫 pageB。
```js
module.exports = {
  entry: {
    pageA: ...,
    pageB: ...,
  },
  output: {
    filename: '[name].bundle.js'
  }
}
```
## f按需加载
在代码中使用 import(...)按需加载代码，在 webpack 配置中使用 output.chunkFilename 为异步加载的 chunk 命名。
```js
module.exports = {
  entry: ...,
  output: {
    ...,
    chunkFilename: '[name].async.bundle.js'
  }
}
```
## f代码分割 fwebpack代码分割
配置 splitChunks 可以将 entry, 异步 chunk 等 chunk 进一步分割，产生更多 chunk。
```js
module.exports = {
  optimization: {
    splitChunks: {
      ....
    }
  }
}
```

# fTreeShaking f摇树优化
Tree-Shaking 是一种基于 ES Module 规范的 无用代码清除(Dead Code Elimination) 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。
## f开启TreeShaking  f在 webpack 中开启 TreeShaking
1. 使用 ESM 规范编写模块代码。
2. 配置 optimization.usedExports 为 true，启动标记功能。
3. 启动代码优化功能，可以通过如下方式的任意一种实现:
  - 配置 mode = production
  - 配置 optimization.minimize = true
  - 提供 optimization.minimizer 数组
例如, 在 webpack.config.js 中:
```js
module.exports = {
  entry: "./src/index",
  mode: "production",
  devtool: false,
  optimization: {
    usedExports: true,
  },
};
```
## fES6模块特点 fESM规范
1. 只能作为模块顶层的语句出现。
2. 导入导出的模块名只能是字符串常量。
3. 导入的值是不可变的。
以上三点，决定了 ESM 是完全静态的，跟运行时无关，所以可以在编译时，从代码字面量中就推断出哪些模块值未被使用，这是实现 Tree Shaking 技术的必要条件。
```js
// index.js 主模块
import {bar} from './bar';
console.log(bar);  // 仅使用了 bar, 没有使用 foo
// bar.js 模块
export const bar = 'bar';
export const foo = 'foo';   // foo 未被使用, 会被视作无用代码而删除。
```
## f原理 fTreeShaking原理
Webpack 中，Tree-shaking 分为两步:
1. 第一步、先标记出模块导出值中哪些没有被用过。
2. 第二步、使用 Terser或UglifyJS 等 DCE工具 删掉这些没被用到的导出语句。
标记过程大致可划分为三个步骤:
  - Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中。
  - Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用。
  - 生成产物时，若变量没有被其它模块使用则删除对应的导出语句。

🌰例子
```js
{
  // bar 模块
  "./src/bar.js":  ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.d(__webpack_exports__, {
      "bar": () => (/* binding */ bar)
      // 这里就没有导出 foo，因为根本没用到。
      // 后面 Terser 插件的 DCE 功能，会把 const foo = 'foo' 摇掉。
    });
    /* unused harmony export foo */
    const bar = 'bar';
    const foo = 'foo';
  })
}
```

# f缓存 fwebpack缓存
1. cache-loader
2. hard-source-webpack-plugin
3. babel-loader
## hard-source-webpack-plugin
模块解析的阶段，用于中间的缓存。
第一次是正常的构建速度，但是会保存缓存数据到 xxx 里。
第二次使用缓存来构建，速度提升。
## babel-loader
运行以后，会增加 node_modules/.cache/babel-loader 这个文件夹，存放缓存的文件
```js
{
  loader: 'babel-loader',
  options: {
    cacheDirectory: true // 开启缓存
  }
}
```

# f热更新🔥 fdevServer
安装 webpack-dev-server, 然后在开发环境下配置:
```js
devServer: {
  contentBase: join(__dirname, '../dist'),
  hot: true,
  port: 3000
}
```
TODO: 原理

## f系统级通知
按下 Ctrl+S, 无需查看 terminal, 系统会通知你成功/失败。只需安装 webpack-build-notifier, 配置插件:
```js
plugins: [
  new WebpackBuildNotifierPlugin({
    title: "My Webpack Project",
    logo: path.resolve("./img/favicon.png"),
    suppressSuccess: true,
  })
]
```


============================================ fNode.js ====================================================
# node-gyp
gyp 的含义是 generate your project

node-gyp install 下载 Node.js 头文件
node-gyp configure 针对某个 C++ 项目生成 构建配置 (Makefile)
node-gyp build 将 C++ 代码编译成二进制文件 (xx.node)
node-gyp clean 清理掉 Release 目录
node-gyp rebuild 等于 clean + configure + build

# 为什么要写C++模块
C++ 比 JavaScript 解释器高效。在 JavaScript 解释器中执行 JS 代码的效率，通常比直接执行一个 C++ 编译好的二进制文件要低。

# 为什么 require 不用写后缀
Node.js 运行时会一次枚举后缀名进行寻径，其中就包含后缀名为 .node 的模块，这是一个 C++ 模块的二进制文件。

# C++ 模块本质
一个编译好的 C++模块，以 *.node 为扩展名，其实就是一个系统的动态链接库，相当于 windows 下的 *.dll。
在 Node.js 中引入一个 C++ 模块的过程，实际上就是 Node.js 在运行时引入了一个动态链接库的过程。
运行时接受 JavaScript 代码中的调用，解析出来具体是扩展中的哪个函数需要被调用，在调用完获得结果之后，再通过运行时返回给 JavaScript 代码。

# C++原生 vs C++扩展
调用 Node.js 的原生 C++ 函数和调用 C++ 扩展函数的区别就在于，前者的代码会直接编译进 Node.js 可执行文件中，而后者的代码则位于一个动态链接库中。

# Node.js模块加载原理
## 用户源码模块
Node.js 用户源码模块载入流程:
1. 开发者调用 require() 这在某种意义上等同于调用 Module._load
2. 闭包化对应文件的源码，并传入相关参数执行（若有缓存，则直接返回）
3. 通常在执行过程中 module.exports 或者 exports 会被赋值
4. Module.prototype._load 在最后返回这个模块的 exports 给上游

*用户调用`require`的步骤 Module._load: *
1. 生成文件路径
2. 从 Module._cache 中检查是否有缓存:
   2.1 有缓存，直接返回 cacheModule.exports
   2.2 无缓存，检查是否是内置模块:
     2.2.1 是内置模块，返回 NativeModule.require(filename) 的调用结果
     2.2.2 非内置模块，调用 new Module(..) 实例化一个模块，标记是否入口模块，存入缓存 Module._cache[filename] = module,
           尝试加载模块(调用tryModuleLoaded()，本质还是执行 module.load)，返回 module.exports, 也就是用户写的 module.exports = xxx。

*闭包化源码*
```js
(function(exports, require, module, __filename, __dirname) {
   // `用户源码`
   // 这里的 require 就是经包装后的 Module.prototype.require, 在某种意义上等同于调用 Module._load。
   const a = require('./a');
   // 这里的 module 是 Module 类的对象实例，所以对 module.exports 赋值实际上是对这个传入的 module 对象赋值。
  module.exports = { id: 1, name: 'v8' };
});
```

## Node.js 内置模块， 如 fs
1. C++ 层初始化 (位于 src/node.cc 的 Start 函数)
2. 逐层深入 Start, 最后 node::LoadEnvironment 载入 bootstrap_node.js 的入口函数 (~/lib/internal/bootstrap_node.js)
3. 传入 process 对象执行 bootstrap_node.js 函数
4. 传给 bootstrap_node.js 的是 env->process_object(), 也就是 process 对象，这个 process 对象就是我们常用的 process 对象。

**源码 传递 process 对象给 bootstrap_node.js**
```c++
// src/node.cc::Start -> .. -> LoadEnvironment
Local<Value> arg = env->process_object();
f->Call(Null(env->isolate()), 1, &arg);
```


============================================ f计算机底层知识 ================================================
# CPU的制作
一堆沙子是怎么变成一颗CPU的?
1. 沙子脱氧、提纯，做出硅锭
2. 切片，切出圆片，最后CPU就是在一个个圆片上诞生的
3. 镀膜
4. 光刻, 在圆片上分出一颗一颗的小芯片
5. 每一颗芯片的详细制作工艺
6. 形成复杂电路
7. 切割出一颗一颗的芯片
8. 封装，测试

# CPU的原理
CPU最主要的控件是晶体管。

# CPU的组成
*概览*
PC, Registers, ALU, CU, MMU, cache
*详解*
1. PC Program Counter 指令寄存器, 记录当前指令地址。 [指令]
内存就是一个特别大的字节数组，数组的某个地址存放了下一条等待执行的指令，这个地址就存在 PC 中。执行完这一条指令后，下一条指令的地址，通过指令长度等条件算出，再存到 PC 中。
2. Registers 寄存器, 暂时存储 CPU 计算需要用到的数据。[数据]
寄存器存在于 CPU 内部，计算速度非常快，现在一颗 CPU 里寄存器数量非常多，有的 CPU 会达到上百个寄存器。
寄存器的作用是: 读一个数字进来，放到寄存器里，也就是 CPU 内部，而不是放内存，因为对于 CPU 来说，内存太远了, 导致计算速度太慢了。
3. ALU Arithmetic & Logic Unit 算术逻辑单元
CPU 内部负责运算的单元。
举一个例子，对 2 和 3 执行加法:
  1. MOV 2 AX                     ;把 2 移动到 CPU 的寄存器 AX 里
  2. MOV 3 BX                     ;把 3 移动到 CPU 的寄存器 BX 里
  3. PC 取出下一条指令, 发现是 ADD
  4. 从 AX 取出 2, 从 BX 取出 3，经过 ALU 运算，再输出给另一个寄存器 DX
  5. 把 DX 的值写到内存中
这就完成了一次运算。
4. CU, Control Unit 控制单元
响应中断信号用的。
5. MMU, Memory Management Unit 内存管理单元
硬件+操作系统 实现 内存管理。
6. cache

*杂记*
1. CPU 的数据存放在`寄存器`(Registers), CPU 的指令存放在`指令寄存器`(PC)。
2. CPU -> Register(<1ns) -> L1缓存(1ns) -> L2缓存(3ns) -> L3缓存(15ns) -> 内存(80ns)

# f进程 f线程 f纤程
0. 进程是一个程序运行起来的状态，线程是一个进程中的不同的执行路径。 
1. 进程是操作系统分配资源的基本单位，线程是操作系统执行调度的基本单位。 (进程和线程有什么区别, 专业回答)
2. 进程在 linux 中也被称为 task, OS 会分配`独立的地址空间、内核数据结构(进程描述符号,PCB Process Control Block)、全局变量、数据段..`给一个进程。其中，进程最重要的是分配到了独立的内存空间。
3. 在 linux 中，用一个进程描述符 PCB (Process Control Block) 来跟踪/维护一个进程。
4. 在 linux 中，一个线程也是一个普通的进程，只不过这个`普通进程`和其他进程共享资源，所以每个线程也有一个PCB。
5. 在 linux 中，用`系统调用`来创建/启动一个进程，如 fork(创建一个进程,本质上是调用clone这个函数), exec(让进程跑起来)


3. 线程共享进程的内存空间，没有自己独立的内存空间。
4. 线程是一个进程中的某个执行路径。一个进程起来以后，它里面可能会有多个执行路径，比如 QQ 进程会有 UI线程负责更新界面，socket线程负责网络连接等。 
5. 线程在不同的操作系统中的实现不太一样。在 linux 中, 线程就是一个普通的进程，只不过这个普通的进程和其他进程共享资源，如内存空间、全局数据等。
6. 纤程是用户态的线程，是线程中的线程，切换和调度纤程不需要经过 OS。
7. 纤程的优点有: 1.占用资源很少，线程需要 1MB, 纤程只需要 4KB;  2.切换比较简单;  3.轻松启动很多个(10W+)
*运行一个程序的流程*
1. 双击 QQ.exe
2. 调用磁盘控制器，把 QQ 从磁盘中读取出来，通过 IO 总线放到内存里
3. 数据放到内存以后，形成一个进程。(如果再双击一次 QQ.exe, 那内存里就会再来一个进程)
4. OS 会给 QQ 这个进程分配资源(内存空间、文件、寄存器)，最重要的资源就是内存空间，不同的进程有自己独立的内存空间。
5. CPU 读取内存中 QQ 进程: 读取指令放到 PC 寄存器里，读取数据放到 Register 里，开始执行。
6. 开始执行以后就有了线程的概念，QQ 进程里的 main 就是主线程。

# 高并发调优
10线程 * 1000纤程，充分利用了CPU调度线程的能力，以及JVM切换纤程的能力， 优于 1线程*10000纤程。

# 乱序执行
CPU 的乱序执行指的是: CPU 在进行`读等待`的同时执行指令，这本质上不是乱，而是提高执行效率。

# 系统启动

