# f会议管理平台
这是一个面向会议管理人员的项目，是一个老项目，我们原来是有一个桌面软件提供了这套会议管理流程，但是现在要跨平台，所以做了一套 web 端的管理平台，提供会前、会中、会后数据的集中管理，分为四个模块，分别是会议、代表、用户、设置。我负责的是项目的性能优化，开发代表模块中的代表管理功能、以及会议模块中的会议日志功能。

# 项目细节
## 代表模块
* 代表管理
* 权限管理
* IC卡管理
* 密码管理
* 指纹管理
### f代表管理
代表信息的增删改查(姓名、类型、代表团...)、代表资料上传、代表名单下载。
#### 难点
代表资料上传（上传大文件）
这是一份 .zip 文件，解压以后有
  - 一张存放代表名单的表格 (.xls)
  - 一个存放所有代表照片的文件夹
一般代表数量会达到1000以上，.zip文件大小会达到 200 MB。

## f会议模块
* 会议管理
* 与会代表
* 人员排位
* 阅看管理
* 会议日志
### f会议管理
#### 会议的层级
- 会议
    - 日程1
      - 议程 1-1
        - 议题 1-1-1
        - 议题 1-1-2
      - 议程 1-2
    - 日程2
    - 日程3
会议-日程-议程-议题 增删改查
#### 议题细节
- 议题名称
- 会议主持人
- 议题选项
  - 议题模式 表决模式/普通模式
  - 表决模式 同意/反对、表决方式、选举方式、评议方式
  - 记名方式 记名/不记名投票
  - 控制方式 操作员控制/预设表决时间 表决时间(1分钟)
  - 计票方式 最后一次按键有效/第一次按键有效
  - 评议方式 满意/称职/合格

### f会议日志
渲染一个会议日志长列表，每次会议数据量在 5w~10w。
* 可以筛选会议日志类型, 如只显示: 签到、议程、议题、表决、话筒、设备、译员间
* 可以导出会议日志
* 可以检索会议日志

数据结构，左边是时间，右边是一行标题，然后下面一行内容，像:
2022-08-29 17:06:13  开始会议
2022-08-29 17:07:13  开始签到
2022-08-29 17:16:13  结束签到
                     签到结果: 应到人数 1000, 实到人数 998, 未到人数 2
2022-08-29 17:36:13  开始表决
2022-08-29 17:40:00  结束表决
2022-08-29 17:45:00  xx代表开始发言
2022-08-29 17:47:13  xx代表结束发言
2022-08-29 17:50:13  xx代表开始发言
2022-08-29 18:06:13  xx代表结束发言
2022-08-29 18:36:13  结束会议

## f用户模块
* 用户管理
* 角色管理
* 个人信息
### f用户管理
用户增删改查
### f角色管理
SY(system)
SA(super administrator)
FA(file administrator)
DEVICE(taidenDevice)
PA(edu platform administrator)
USER(edu platform user)
MA(media user)
### f个人信息
修改密码
修改手机号/邮箱
修改名称/头像

## f设置模块
* 布局管理
会场设计器
* 会议类型
会议类型增删改查
* 服务器设置
重启、关机、第三方配置用户接口、下载阅看app

# f项目难点
## 难点一 减少首屏加载时间  f优化首屏
首屏时间 FCP 从 5s (测试100次，在4.8s ~ 5.3s之前) 优化到 1.5s 以内 (测试100次，在1.0s ~ 1.4s之前)。

### 分析构建产物
使用 webpack-bundle-analyzer 分析项目体积
```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

* vendor.js 占用过大 (分包)
* css 体积过大 (压缩CSS, 去除无用CSS)
* 图片过大
* 一些冗余的依赖没有清除，如 mock.js (修改代码移除冗余依赖)

### 体积优化
* 压缩CSS、摇树优化CSS
使用 mini-css-extract-plugin+css + minimizer-webpack-plugin 配合 css-loader/less-loader，提取、压缩 css 文件。
使用 purgecss-webpack-plugin 去除无用的 css 样式。

* 优化图片
使用 image-webpack-loader
- pngquant: 是一款PNG压缩器，通过将图像转换为具有alpha通道（通常比24/32位PNG 文件小60-80％）的更高效的8位PNG格式，可显著减小文件大小。 
- pngcrush:其主要目的是通过尝试不同的压缩级别和PNG过滤方法来降低PNG IDAT数据 流的大小。 
- optipng:其设计灵感来自于pngcrush。optipng可将图像文件重新压缩为更小尺寸，而不 会丢失任何信息。 
- tinypng:也是将24位png文件转化为更小有索引的8位图片，同时所有非必要的metadata 也会被剥离掉。
```js
{
  test: '/\.(png|jpe?g|gif|blob)$/',
  use: [
    {
      loader: 'file-loader',
    },
    {
      loader: 'image-webpack-loader',
      options: {
        pngquant: {
          quality: '65-90',
          speed: 4
        },
        webp: {
          quality: 75
        }
      }
    }
  ]
}
```

* 按需加载 Antd 组件及其样式
1. 安装 babel-plugin-import
2. 配置 .babelrc
```js
{
  "presets": [
    ...
  ],
  "plugins": [
    ...
    [
      "import",
      {
        "libraryName": "antd",
        "style": true
      }
    ]
  ]
}
```

* 优化分包策略
```js
splitChunks: {
  chunks: 'all',
  maxInitialRequests: Infinity, // 默认为3，调整为允许无限入口资源
  minSize: 20000, // 20K以下的依赖不做拆分
  cacheGroups: {
    vendors: {
      // 拆分依赖，避免单文件过大拖慢页面展示
      // 得益于HTTP2多路复用，不用太担心资源请求太多的问题
      name(module) {
        // 拆包
        const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1]
        return `npm.${packageName.replace('@', '')}` // 部分服务器不允许URL带@
      },
      test: /[\\/]node_modules[\\/]/,
      priority: -10,
      chunks: 'initial'
    }
  }
}
```



### 传输优化
* 开启 http2
1. HTTP2是HTTP协议的第二个版本，相较于HTTP1 速度更快、延迟更低，功能更多。
2. 目前来看兼容性方面也算过得去，在国内有超过50%的覆盖率。
3. 通常浏览器在传输时并发请求数是有限制的，超过限制的请求需要排队，以往我们通过域名分片、资源合并来避开这一限制，而使用HTTP2协议后，其可以在一个TCP连接分帧处理多个请求（多路复用），不受此限制。（其余的头部压缩等等也带来了一定性能提升）
```js
/** 配置 nginx: nginx.conf */
// 开启 http2
listen 443 http2;
// 重启 nginx
nginx -s stop && nginx
```

* 开启 gzip
Gzip压缩是一种强力压缩手段，针对文本文件时通常能减少2/3的体积。
HTTP协议中用头部字段Accept-Encoding 和 Content-Encoding对「采用何种编码格式传输正文」进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式。当响应头的 Content-Encoding指定了gzip时，浏览器则会进行对应解压
一般浏览器都支持gzip，所以Accept-Encoding也会自动带上gzip，所以我们需要让资源服务器在Content-Encoding指定gzip，并返回gzip文件。

- 后端  nginx 开启 gzip
```shell
#开启和关闭gzip模式
gzip on;
#gizp压缩起点，文件大于1k才进行压缩
gzip_min_length 1k;
# gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间
gzip_comp_level 6;
# 进行压缩的文件类型。
gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript ;
# nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩
gzip_static on
# 是否在http header中添加Vary: Accept-Encoding，建议开启
gzip_vary on;
# 设置gzip压缩针对的HTTP协议版本
gzip_http_version 1.1;
```

- 前端 构建 gzip 文件
虽然上面配置后Nginx已经会在响应请求时进行压缩并返回Gzip了，但是压缩操作本身是会占用服务器的CPU和时间的，压缩等级越高开销越大，所以我们通常会一并上传gzip文件(使用 compression-webpack-plugin 压缩前端文件)，让服务器直接返回压缩后文件。
```js
const CompressionPlugin = require("compression-webpack-plugin");
module.exports = {
  plugins: [new CompressionPlugin()],
};
```
压缩前 2012 KB, 压缩后 388 KB，缩小至原体积的 19%。

### fFCP
首次内容绘制 (FCP) 指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，"内容"指的是文本、图像（包括背景图像）、<svg>元素或非白色的<canvas>元素。

## 难点二 渲染会议日志长列表 f虚拟列表 f长列表
### 背景
会议管理平台中，需要渲染 5w~10w 条会议日志，每条会议日志是一个标题加下面一行备注的形式，不能使用表格，属于长列表，为了提高渲染性能，我使用了虚拟列表渲染。用的是一个`react-window`库，使用了里面的`FixedSizeList`组件实现。
### 原理
虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到比较高的渲染性能。
在可视列表外部包裹一个容器元素`container`，同时添加一个和原数据同等高度的元素`phantom`撑开滚动条。监听容器元素的`scroll`事件，滚动时，根据 scrollTop 计算当前需要截取的可视区域列表的起始索引和结束索引，从长列表中截取这部分列表，适当做些位移操作，渲染到DOM中。
这样就能做到: 在视觉上有一个长列表在页面中滚动，但实际上只有部分列表渲染。
### 会议日志长列表例子
开始会议
开始签到
代表1签到
代表2签到
...
结束签到
xx议题1开始
xx主席发言
xx代表发言
...
结束会议
