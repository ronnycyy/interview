# f会议管理平台
这是一个面向会议管理人员的项目，是一个老项目，我们原来是有一个 DCS 软件，提供了这套会议管理流程，但是现在要跨平台，所以做了一套 web 端的管理平台，提供表决、签到、与会人员等数据的集中管理。

# f项目难点
## 难点一 减少首屏加载时间  f优化首屏
首屏时间 FCP 从 5s (测试100次，在4.8s ~ 5.3s之前) 优化到 1.5s 以内 (测试100次，在1.0s ~ 1.4s之前)。

## fFCP
首次内容绘制 (FCP) 指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，"内容"指的是文本、图像（包括背景图像）、<svg>元素或非白色的<canvas>元素。

### 分析构建产物
使用 webpack-bundle-analyzer 分析项目体积
```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

* vendor.js 占用过大 (分包)
* css 体积过大 (压缩CSS, 去除无用CSS)
* 图片过大
* 一些冗余的依赖没有清除，如 mock.js (修改代码移除冗余依赖)

### 体积优化
* 压缩CSS、摇树优化CSS
使用 mini-css-extract-plugin+css + minimizer-webpack-plugin 配合 css-loader/less-loader，提取、压缩 css 文件。
使用 purgecss-webpack-plugin 去除无用的 css 样式。

* 优化图片
使用 image-webpack-loader
- pngquant: 是一款PNG压缩器，通过将图像转换为具有alpha通道（通常比24/32位PNG 文件小60-80％）的更高效的8位PNG格式，可显著减小文件大小。 
- pngcrush:其主要目的是通过尝试不同的压缩级别和PNG过滤方法来降低PNG IDAT数据 流的大小。 
- optipng:其设计灵感来自于pngcrush。optipng可将图像文件重新压缩为更小尺寸，而不 会丢失任何信息。 
- tinypng:也是将24位png文件转化为更小有索引的8位图片，同时所有非必要的metadata 也会被剥离掉。
```js
{
  test: '/\.(png|jpe?g|gif|blob)$/',
  use: [
    {
      loader: 'file-loader',
    },
    {
      loader: 'image-webpack-loader',
      options: {
        pngquant: {
          quality: '65-90',
          speed: 4
        },
        webp: {
          quality: 75
        }
      }
    }
  ]
}
```

* 按需加载 Antd 组件及其样式
1. 安装 babel-plugin-import
2. 配置 .babelrc
```js
{
  "presets": [
    ...
  ],
  "plugins": [
    ...
    [
      "import",
      {
        "libraryName": "antd",
        "style": true
      }
    ]
  ]
}
```

* 优化分包策略
```js
splitChunks: {
  chunks: 'all',
  maxInitialRequests: Infinity, // 默认为3，调整为允许无限入口资源
  minSize: 20000, // 20K以下的依赖不做拆分
  cacheGroups: {
    vendors: {
      // 拆分依赖，避免单文件过大拖慢页面展示
      // 得益于HTTP2多路复用，不用太担心资源请求太多的问题
      name(module) {
        // 拆包
        const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1]
        return `npm.${packageName.replace('@', '')}` // 部分服务器不允许URL带@
      },
      test: /[\\/]node_modules[\\/]/,
      priority: -10,
      chunks: 'initial'
    }
  }
}
```



### 传输优化
* 开启 http2
1. HTTP2是HTTP协议的第二个版本，相较于HTTP1 速度更快、延迟更低，功能更多。
2. 目前来看兼容性方面也算过得去，在国内有超过50%的覆盖率。
3. 通常浏览器在传输时并发请求数是有限制的，超过限制的请求需要排队，以往我们通过域名分片、资源合并来避开这一限制，而使用HTTP2协议后，其可以在一个TCP连接分帧处理多个请求（多路复用），不受此限制。（其余的头部压缩等等也带来了一定性能提升）
```js
/** 配置 nginx: nginx.conf */
// 开启 http2
listen 443 http2;
// 重启 nginx
nginx -s stop && nginx
```

* 开启 gzip
Gzip压缩是一种强力压缩手段，针对文本文件时通常能减少2/3的体积。
HTTP协议中用头部字段Accept-Encoding 和 Content-Encoding对「采用何种编码格式传输正文」进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式。当响应头的 Content-Encoding指定了gzip时，浏览器则会进行对应解压
一般浏览器都支持gzip，所以Accept-Encoding也会自动带上gzip，所以我们需要让资源服务器在Content-Encoding指定gzip，并返回gzip文件。

- 后端  nginx 开启 gzip
```shell
#开启和关闭gzip模式
gzip on;
#gizp压缩起点，文件大于1k才进行压缩
gzip_min_length 1k;
# gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间
gzip_comp_level 6;
# 进行压缩的文件类型。
gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript ;
# nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩
gzip_static on
# 是否在http header中添加Vary: Accept-Encoding，建议开启
gzip_vary on;
# 设置gzip压缩针对的HTTP协议版本
gzip_http_version 1.1;
```

- 前端 构建 gzip 文件
虽然上面配置后Nginx已经会在响应请求时进行压缩并返回Gzip了，但是压缩操作本身是会占用服务器的CPU和时间的，压缩等级越高开销越大，所以我们通常会一并上传gzip文件(使用 compression-webpack-plugin 压缩前端文件)，让服务器直接返回压缩后文件。
```js
const CompressionPlugin = require("compression-webpack-plugin");
module.exports = {
  plugins: [new CompressionPlugin()],
};
```
压缩前 2012 KB, 压缩后 388 KB，缩小至原体积的 19%。




 
## 难点二 渲染会议日志长列表 f虚拟列表 f长列表
### 背景
会议管理平台中，需要渲染 5w~10w 条会议日志，每条会议日志是一个标题加下面一行备注的形式，不能使用表格，属于长列表，为了提高渲染性能，我使用了虚拟列表渲染。用的是一个`react-window`库，使用了里面的`FixedSizeList`组件实现。
### 原理
虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到比较高的渲染性能。
在可视列表外部包裹一个容器元素`container`，同时添加一个和原数据同等高度的元素`phantom`撑开滚动条。监听容器元素的`scroll`事件，滚动时，根据 scrollTop 计算当前需要截取的可视区域列表的起始索引和结束索引，从长列表中截取这部分列表，适当做些位移操作，渲染到DOM中。
这样就能做到: 在视觉上有一个长列表在页面中滚动，但实际上只有部分列表渲染。
## 会议日志长列表例子
开始会议
开始签到
代表1签到
代表2签到
...
结束签到
xx议题1开始
xx主席发言
xx代表发言
...
结束会议
