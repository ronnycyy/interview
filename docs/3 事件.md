# f事件 f事件系统 React事件系统
*讲概念*
TODO: 什么是 React 事件系统？ ???润色一下????React模拟浏览器事件机制实现的一套，有自己的合成事件源、事件传播机制、事件委托的系统。
React 事件系统可分为三个部分:
1. 事件合成系统，初始化会注册不同的事件插件。
2. 在一次渲染过程中，对事件标签中事件的收集，向 container 注册事件。
3. 一次用户交互，事件触发，到事件执行一系列过程。
*说用途*
*优缺点*

# f事件绑定
*讲概念*
在 React 处理 props 时候，如果遇到事件比如 onClick ，就会通过 addEventListener 增加事件监听，然后把开发者传递的回调函数绑定到事件上。
*给元素绑定的事件 handleClick ，handleChange ，最后去了哪里呢*
1. 保存到fiber
在组件中传递给元素的事件回调，会保存到对应 fiber 结点的 memoizedProps 上。[查看] f保存到fiber
2. 增加事件监听
判断 props 是不是合成事件，如果是，取得依赖的原生事件列表，逐一增加事件监听。[查看] f增加事件监听


**源码 f增加事件监听**
React18

1. 编译时
源码定义了许多事件插件，位于 ~/react/packages/react-dom/src/events/plugins 下，比如 ChangeEventPlugin.js 就是 onChange 这个合成事件的插件。

每个插件都暴露出一个同样名称的方法 ———— registerEvents, 这个方法里定义了一个原生事件映射到的所有原生事件。

编译时，把`React合成事件 -- 原生事件列表`这个映射关系存到 registrationNameDependencies 这个对象上，把所有原生事件存到 allNativeEvents 这个数组上。

2. 运行时(绑定)
开始执行 React.createRoot 后，把所有用到的原生事件注册到 container 上。

1. React.creatRoot(root)
2. listenToAllSupportedEvents(root)
3. allNativeEvents.forEach(e => listenToNativeEvent(domEventName, isCapturePhaseListener, target))
4. addTrappedEventListener
5. addEventBubbleListener 或 addEventCaptureListener (再加 2 个 passive 的事件 [查看] faddEventListener的passive)
6. addEventListener
 

3. 触发事件
以触发 onClick 事件为例:

1. 收集 listeners
~/react/packages/react-dom/src/events/DOMPluginEventSystem.js: [accumulateSinglePhaseListeners]
从 button fiber 往上窜，收集沿途所有监听了 onClick 这个 React合成事件的 fiber，把它们的信息收集到一个 listener 对象中，再依次 push 进一个数组里。
2. 触发 listeners
~/react/packages/react-dom/src/events/DOMPluginEventSystem.js: [processDispatchQueueItemsInOrder]
点击 button, 通过 dispatchEvent 方法开始执行，调用栈中的某个函数，会遍历所有的 listeners，取出其中的回调函数，依次执行。注意这里会按照冒泡/捕获的规则来遍历。


首先，会得到一个派发队列:
```js
const dispatchQueue = [
  {
    event: SyntheticBaseEvent,  // React合成事件实例
    listeners: [   // 从 触发事件的fiber 到 rootFiber，有监听该 合成事件 的所有 fiber, 封装而成的监听器列表
      {
        currentTarget: button dom,
        instance:  button fiber,
        listener: handleClick1,  // 组件中编写的 onClick 的回调函数
      },
      // 父组件、祖先组件.. 同样的结构
    ]
  }
]
```

在 processDispatchQueue 方法中，遍历这个派发队列




1. dispatchDiscreteEvent  [派发离散事件]
  - domEventName: 原生事件名，值为 click
  - container: 应用根结点
  - nativeEvent: 原生 click 事件对象 e ———— PointerEvent，e.target是button, e.currentTarget是div#root

2. dispatchEvent 派发事件
3. dispatchEventForPluginEventSystem 
4. dispatchEventsForPlugins
5. 



**例子 f保存到fiber**
```jsx
function EventDemo() {
  const handleClick = () => console.log('点击事件')
  const handleChange =() => console.log('change事件)
  return (
    <div>
     <input onChange={ handleChange }  />
     <button onClick={ handleClick } >点击</button>
    </div>
  )
}
// React内部的处理结果
input fiber: { memoizedProps: { onChange: handleChange } }
button fiber: { memoizedProps: { onClick: handleClick } }
```

**例子 ffaddEventListener的passive** 
addEventListener 的 options.passive 配置含义:
可选。一个布尔值。设置为 true 时，表示 listener 永远不会调用 preventDefault()。
如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。

将 passive 设为 true 可以启用性能优化，并可大幅改善应用性能。

根据规范，addEventListener() 的 passive 默认值始终为 false。
然而，这引入了触摸事件和滚轮事件的事件监听器在浏览器尝试滚动页面时阻塞浏览器主线程的可能性 —— 这可能会大大降低浏览器处理页面滚动时的性能。

为了避免这一问题，大部分浏览器（Safari 和 Internet Explorer 除外）将文档级节点 Window、Document 和 Document.body 上的 wheel、mousewheel、touchstart 和 touchmove 事件的 passive 默认值更改为 true。如此，事件监听器便不能取消事件，也不会在用户滚动页面时阻止页面呈现。
```js
/* 检测浏览器是否支持该特性 */
let passiveIfSupported = false;
try {
  window.addEventListener("test", null,
    Object.defineProperty(
      {},
      "passive",
      {
        get() { passiveIfSupported = { passive: true }; }
      }
    )
  );
} catch (err) {}
window.addEventListener('scroll', (event) => {
  /* do something */
  // 不能使用 event.preventDefault();
}, passiveIfSupported );
```


# f事件插件
*registrationNameModules*
这个对象记录了 React 事件（比如 onBlur ）和与之对应的处理插件的映射。
比如 onClick 会用 SimpleEventPlugin 插件处理，onChange 会用 ChangeEventPlugin 处理。
应用于事件触发阶段，根据不同事件使用不同的插件。
```js
const registrationNameModules = {
    onBlur: SimpleEventPlugin,
    onClick: SimpleEventPlugin,
    onClickCapture: SimpleEventPlugin,
    onChange: ChangeEventPlugin,
    onChangeCapture: ChangeEventPlugin,
    onMouseEnter: EnterLeaveEventPlugin,
    onMouseLeave: EnterLeaveEventPlugin,
    ...
}
```
*registrationNameDependencies*
这个对象保存了 React 事件和原生事件对应关系，比如一个 onChange 会有 blur, change, click, focus 等很多原生事件绑定在 container 上。
在事件绑定阶段，如果发现有 React 事件，就会找到对应的原生事件数组，逐一绑定。
```js
{
    onBlur: ['blur'],
    onClick: ['click'],
    onClickCapture: ['click'],
    onChange: ['blur', 'change', 'click', 'focus', 'input', 'keydown', 'keyup', 'selectionchange'],
    onMouseEnter: ['mouseout', 'mouseover'],
    onMouseLeave: ['mouseout', 'mouseover'],
    ...
}
```

# f事件合成
*讲概念*
1. 在React应用中，元素绑定的事件不是原生的事件，而是React合成的事件。比如 onClick 是由 click 合成，而 onChange 是由 blur, change, focus 等多个事件合成的。
2. 合成的事件是注册在React应用的容器上，也就是 ReactDOM.createRoot 接收的根结点上，而不是编写事件绑定的元素上。
TODO: 事件插件机制
*说用途*
*优缺点*

*事件处理的注意点*
1. React 事件的命名必须采用`小驼峰`式，如 onClick, onChange, onBlur 等。
2. 使用 JSX 语法时，开发者需要传入一个函数作为事件处理函数，而不是一个字符串。
3. 谨慎处理回调函数的 this, 通常使用 this.handleClick = this.handleClick.bind(this) 来绑定 this, 同时保证每次 render 是同一个函数，不会影响性能优化策略。
4. 原生事件可以通过 return false 和 e.preventDefault() 来阻止默认行为，而 React 只能通过 e.preventDefault()。
5. 没有加 Capture 后缀的事件都是在 React 事件系统的`冒泡阶段`触发，如 onClick, onChange, onBlur, onKeyDown, onKeyUp 等。
6. 加了 Capture 后缀的事件在 React事件系统的`捕获阶段`触发，如 onClickCapture, onChangeCapture 等。
7. 通过 e.stopPropagation() 阻止冒泡行为。
**例子**
```jsx
// 原生DOM
<button onclick="handle()">点击</button>
// React元素
<button onClick={this.handleClick}>点击</button>
```

*React为什么有自己的事件系统?*
1. 提供兼容性。
对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架 (e.xx都可以用)，为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。
2. 事件委托在 container 上
v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。造成一些不可控的情况。由于不是绑定在真实的 DOM 上，所以 React 需要模拟一套事件流：事件捕获 -> 事件源 -> 事件冒泡，也包括重写一下事件源对象 event 。
3. 支持 SSR 和 跨端
这种事件系统，大部分处理逻辑都在底层处理了，这对后期的 ssr 和跨端支持度很高。

*什么是事件合成*
*如何实现的批量更新*

*事件系统如何模拟冒泡和捕获阶段*


*如何通过dom元素找到与之匹配的fiber*
*为什么不能用 return false 来阻止事件的默认行为*
1. 通过 e.preventDefault() 阻止默认行为

*事件是绑定在真实的dom上吗？如何不是绑定在哪里*
*V17 对事件系统有哪些改变*

*知识点*
1. 给元素绑定的事件，不是真正的事件处理函数。
2. 在冒泡/捕获阶段绑定的事件，也不是在冒泡/捕获阶段执行的。
3. 甚至在事件处理函数中拿到的事件源 e ，也不是真正的事件源 e 。

*数据结构*
```ts
interface BaseSyntheticEvent<E = object, C = any, T = any> {
  // 浏览器的原生事件
  nativeEvent: E;
  // 是一个引用，指向注册事件监听器的 DOM 元素
  currentTarget: C;
  // 是一个引用，指向触发事件的 DOM 元素
  target: T;
  // 阻止默认行为
  preventDefault(): void;
  // 停止冒泡
  stopPropagation(): void;
  // ...
}
```

**参考**
# f事件机制 fReact事件机制
1. React并不是将事件回调绑定到真实的DOM上，而是在根结点处监听所有的事件。在 v17 之前，React 事件是绑定在 document 上的，v17 以后事件绑定到了应用对应的容器结点上(#root)。
2. React 实现了自己的一套事件捕获和事件冒泡机制，当事件发生并且冒泡到根结点t处的时候，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂载销毁时统一订阅和移除事件。
3. React 的事件并不是原生事件，而是 React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。
## f为什么要有事件系统
有两点原因，一是兼容不同浏览器，二是为了统一管理。
1. 对于不同的浏览器，对事件存在不同的兼容性，React 想实现一个兼容全浏览器的框架， 为了实现这个目标就需要创建一个兼容全浏览器的事件系统，以此抹平不同浏览器的差异。
2. v17 之前 React 事件都是绑定在 document 上，v17 之后 React 把事件绑定在应用对应的容器 container 上，将事件绑定在同一容器统一管理，防止很多事件直接绑定在原生的 DOM 元素上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。
## f合成事件
React 应用中，元素绑定的事件并不是原生事件，而是 React 合成的事件，比如 onClick 是由 click 合成，onChange 是由 blur ，change ，focus 等多个事件合成。
### 优点
- 兼容所有浏览器，更好的跨平台；
- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。
- 方便 react 统一管理和事务机制。
## fReact事件 vs f原生事件
1. 对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；
2. 对于事件函数处理语法，原生事件为字符串，react 事件为函数；
3. react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用`preventDefault()`来阻止默认行为。
## f事件捕获 f事件冒泡 fReact是如何模拟事件捕获和事件冒泡的
当事件触发时，React会从当前fiber向上遍历，遇到绑定了事件的fiber时，就会用一个数组收集事件，把冒泡阶段的事件回调用push放进去，也就是插入到数组尾，而把捕获阶段的事件回调用unshift放进去，也就是插入到数组头。直到遍历到根结点。然后依次执行数组里的事件回调。
## f阻止默认行为
在React应用中，可以用`e.preventDefault()`阻止事件默认行为，但不能用类似原生事件的`return false`来阻止。
这是因为在 React 中给元素的事件并不是真正的事件处理函数，导致`return false`方法在 React 应用中失去了作用，preventDefault 也是单独处理的。