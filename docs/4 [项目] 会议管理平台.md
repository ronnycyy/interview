# f会议管理平台
这是一个面向会议管理人员的项目，是一个老项目，我们原来是有一个桌面软件提供了这套会议管理流程，但是现在要跨平台，所以做了一套 web 端的管理平台，提供会前、会中、会后数据的集中管理，分为四个模块，分别是会议、代表、用户、设置。我负责的是项目的性能优化，开发代表模块中的代表管理功能、以及会议模块中的会议日志功能。

# f项目难点
## 1. f首屏性能 f优化首屏 f性能优化
首屏时间 FCP 从 5s (测试100次，在4.8s ~ 5.3s之前) 优化到 1.5s 以内 (测试100次，在1.0s ~ 1.4s之前)。

### 分析构建产物
使用 webpack-bundle-analyzer 分析项目体积
```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

* vendor.js 占用过大 (分包)
* css 体积过大 (压缩CSS, 去除无用CSS)
* 图片过大
* 一些冗余的依赖没有清除，如 mock.js (修改代码移除冗余依赖)

### 体积优化
* 压缩CSS、摇树优化CSS
使用 mini-css-extract-plugin+css + minimizer-webpack-plugin 配合 css-loader/less-loader，提取、压缩 css 文件。
使用 purgecss-webpack-plugin 去除无用的 css 样式。

* 优化图片
使用 image-webpack-loader
- pngquant: 是一款PNG压缩器，通过将图像转换为具有alpha通道（通常比24/32位PNG 文件小60-80％）的更高效的8位PNG格式，可显著减小文件大小。 
- pngcrush:其主要目的是通过尝试不同的压缩级别和PNG过滤方法来降低PNG IDAT数据 流的大小。 
- optipng:其设计灵感来自于pngcrush。optipng可将图像文件重新压缩为更小尺寸，而不 会丢失任何信息。 
- tinypng:也是将24位png文件转化为更小有索引的8位图片，同时所有非必要的metadata 也会被剥离掉。
```js
{
  test: '/\.(png|jpe?g|gif|blob)$/',
  use: [
    {
      loader: 'file-loader',
    },
    {
      loader: 'image-webpack-loader',
      options: {
        pngquant: {
          quality: '65-90',
          speed: 4
        },
        webp: {
          quality: 75
        }
      }
    }
  ]
}
```

* 按需加载 Antd 组件及其样式
1. 安装 babel-plugin-import
2. 配置 .babelrc
```js
{
  "presets": [
    ...
  ],
  "plugins": [
    ...
    [
      "import",
      {
        "libraryName": "antd",
        "style": true
      }
    ]
  ]
}
```

* 优化分包策略
```js
splitChunks: {
  chunks: 'all',
  maxInitialRequests: Infinity, // 默认为3，调整为允许无限入口资源
  minSize: 20000, // 20K以下的依赖不做拆分
  cacheGroups: {
    vendors: {
      // 拆分依赖，避免单文件过大拖慢页面展示
      // 得益于HTTP2多路复用，不用太担心资源请求太多的问题
      name(module) {
        // 拆包
        const packageName = module.context.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/)[1]
        return `npm.${packageName.replace('@', '')}` // 部分服务器不允许URL带@
      },
      test: /[\\/]node_modules[\\/]/,
      priority: -10,
      chunks: 'initial'
    }
  }
}
```



### 传输优化
* 开启 http2
1. HTTP2是HTTP协议的第二个版本，相较于HTTP1 速度更快、延迟更低，功能更多。
2. 目前来看兼容性方面也算过得去，在国内有超过50%的覆盖率。
3. 通常浏览器在传输时并发请求数是有限制的，超过限制的请求需要排队，以往我们通过域名分片、资源合并来避开这一限制，而使用HTTP2协议后，其可以在一个TCP连接分帧处理多个请求（多路复用），不受此限制。（其余的头部压缩等等也带来了一定性能提升）
```js
/** 配置 nginx: nginx.conf */
// 开启 http2
listen 443 http2;
// 重启 nginx
nginx -s stop && nginx
```

* 开启 gzip
Gzip压缩是一种强力压缩手段，针对文本文件时通常能减少2/3的体积。
HTTP协议中用头部字段Accept-Encoding 和 Content-Encoding对「采用何种编码格式传输正文」进行了协定，请求头的Accept-Encoding会列出客户端支持的编码格式。当响应头的 Content-Encoding指定了gzip时，浏览器则会进行对应解压
一般浏览器都支持gzip，所以Accept-Encoding也会自动带上gzip，所以我们需要让资源服务器在Content-Encoding指定gzip，并返回gzip文件。

- 后端  nginx 开启 gzip
```shell
#开启和关闭gzip模式
gzip on;
#gizp压缩起点，文件大于1k才进行压缩
gzip_min_length 1k;
# gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间
gzip_comp_level 6;
# 进行压缩的文件类型。
gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript ;
# nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩
gzip_static on
# 是否在http header中添加Vary: Accept-Encoding，建议开启
gzip_vary on;
# 设置gzip压缩针对的HTTP协议版本
gzip_http_version 1.1;
```

- 前端 构建 gzip 文件
虽然上面配置后Nginx已经会在响应请求时进行压缩并返回Gzip了，但是压缩操作本身是会占用服务器的CPU和时间的，压缩等级越高开销越大，所以我们通常会一并上传gzip文件(使用 compression-webpack-plugin 压缩前端文件)，让服务器直接返回压缩后文件。
```js
const CompressionPlugin = require("compression-webpack-plugin");
module.exports = {
  plugins: [new CompressionPlugin()],
};
```
压缩前 2012 KB, 压缩后 388 KB，缩小至原体积的 19%。

### fFCP
首次内容绘制 (FCP) 指标测量页面从开始加载到页面内容的任何部分在屏幕上完成渲染的时间。对于该指标，"内容"指的是文本、图像（包括背景图像）、<svg>元素或非白色的<canvas>元素。

## 2. f虚拟列表 f长列表 f渲染会议日志长列表 f渲染列表
### 背景
会议管理平台中，需要渲染 5w~10w 条会议日志，每条会议日志是一个标题加下面一行备注的形式，不能使用表格，属于长列表，为了提高渲染性能，我使用了虚拟列表渲染。用的是一个`react-window`库，使用了里面的`FixedSizeList`组件实现。
### 原理
虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到比较高的渲染性能。
在可视列表外部包裹一个容器元素`container`，同时添加一个和原数据同等高度的元素`phantom`撑开滚动条。监听容器元素的`scroll`事件，滚动时，根据 scrollTop 计算当前需要截取的可视区域列表的起始索引和结束索引，从长列表中截取这部分列表，适当做些位移操作，渲染到DOM中。
这样就能做到: 在视觉上有一个长列表在页面中滚动，但实际上只有部分列表渲染。
### 例子
开始会议
开始签到
代表1签到
代表2签到
...
结束签到
xx议题1开始
xx主席发言
xx代表发言
...
结束会议

## 3. f大文件上传 f上传 f文件
代表管理中，需要上传本次会议所有与会代表的资料，这个资料是一个`压缩包`, 里面是每个代表的档案、照片等数据，有些会议代表数量在 10000 以上，此时文件可达到 10GB~100GB，属于大文件。

### f大文件上传 
1. 询问。发送 already 请求，询问服务器已经收到哪些分片。
2. 切片。通过 Blob.prototype.slice 方法将大文件切片，每个片都用 `哈希_编号.后缀` 生成名字。
3. 传输。通过检查分片名，找到还没上传的分片，通过 http 上传给服务。
4. 合并。全部发送完毕后，发送 merge 请求，将分片全部合并起来，形成完整的大文件。

#### f询问
通过 SparkMD5 得到文件的内容哈希，带上这个哈希值请求服务，查找已上传哪些分片，返回给前端, 保存到 already 数组中。
```js
const { HASH, suffix } = await fileToBuffer(file);  // 通过内容哈希请求服务器查找
let already = [];
try {
const data = await instance.post('/upload_already', {
  params: {
    HASH
  }
});
if (+data.code === 0) {
  already = data.fileList;
  return;
}
throw data.codeText;
} catch (err) { }
```

#### f切片
1. 因为 File 对象继承自 Blob 对象，所以可以使用 Blob.prototype.slice，也就是 file.slice(start, end) 得到原始对象的某一个段的数据，实现分片。(包含 start, 不包含 end)
2. 使用 `哈希_编号.后缀` 生成每个片的名字，发送到服务器中。
```js
let max = 100 * 1024;
let count = Math.ceil(file.size / max);
let index = 0;
const chunks = [];
if (count > 100) {
  count = 100;
  max = file.size / count;
}
while (index < count) {
  chunks.push({
    file: file.slice(index * max, (index + 1) * max),
    filename: `${HASH}_${index + 1}.${suffix}`
  })
  index++;
}
```

#### f传输
遍历分片，找出没有上传过的分片，上传到服务上。
```js
chunks.forEach(c => {
  if (already.includes(c.filename)) {
    oneChunkDone();  // 已上传过，认为完成✅
    return;
  }
  const fd = new FormData();
  fd.append('file', c.file);
  fd.append('filename', c.filename);
  instance
    .post('/upload_chunk', fd)
    .then(data => {
      if (+data.code === 0) {
        oneChunkDone();   // 分片上传成功
        return;
      }
      return Promise.reject(data.codeText);
    })
    .catch(reason => {
      console.error(reason);  // 某个分片上传失败
      clear();   // 移除进度条等DOM
    })
})
```

#### f合并
判断切片全部上传完成后，发送合并请求，让服务将收到的所有分片合并起来。
```js
async function merge() {
  // 向服务器发送合并请求
  try {
    const data = await instance.post('/upload_merge', {
      HASH,   // 完整大文件的 HASH 
      count   // 总分片数量
    }, {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'   // key1=value1&key2=value2
      }
    });
    if (+data.code === 0) {
      console.log('合并成功:', data.servicePath);
      return;
    }
    throw data.codeText;
  } catch (err) {
    alert('合并失败!');
  } finally {
    clear();
  }
}
```


#### f服务端逻辑
1. 合并请求里需带上文件的内容哈希，以及分片的数量。
2. 收到合并请求后，通过 fs.readdirSync 读取分片文件夹，获取分片列表。
  - 如果分片列表还没到达总体分片的数量，说明大文件还没上传完毕，直接返回，不处理。
  - 如果已经传完了:
    1. 遍历分片列表，fs.readFileSync 读取每个分片的内容，通过 fs.appendFileSync 追加内容到最后合并的大文件中。
    2. 通过 fs.unlinkSync 删除已经合并的分片。
    3. 通过 fs.rmdirSync 删除存放分片的文件夹。


### f多文件上传
1. input 标签增加 multiple 属性
2. 取到的多文件是一个类数组集合，需要转成真正的数组，才能使用数组的 forEach,map,filter 等方法。
3. 上传多文件，展示每个文件的上传进度

#### f多文件上传 多文件上传进度
每个文件上传都返回一个 Promise 对象，全部放到一个数组中。
使用 Promise.all 取得所有文件的上传结果。使用 onUploadProgress 监听进度。

#### f转数组 f类数组转真实数组
```js
const _files = Array.from(uploadInput.files);
```
#### f允许选择多个文件 fmultiple 
input 标签增加 multiple 属性，开启多文件上传。
```html
<input type="file" class="upload_inp" multiple>
```

### f单文件上传 f单文件传递给服务器 f传递
#### f传输
两种方案，一种是 FormData, 一种是 Base64。
##### fFormData 
* 前端
利用 FormData 对象，把信息 append 进去，然后放到 body 里，增加一个 header 的字段 Content-Type 为 multipart/form-data, 通过 http 的 POST 方法传给服务器。
* 后端
通过 multiparty 插件，解析 FormData 的字段。
* 代码
```js
const fd = new FormData();
fd.append('file', _file);
fd.append('filename', _file.name);
instance
  .post('/upload_single', fd)
  .then(data => {
    // 成功
    return Promise.reject(data.codeText);  // 收到 200 但是没有成功的话, 跳到 catch 里。
  })
  .catch(reason => {
    // 失败
  })
  .finally(() => {
    // 无论成功还是失败，都要做的是: 清除已选文件
    clearFile();
  })
```
```js
const multiparty_upload = function multiparty_upload(req, auto) {
  typeof auto !== "boolean" ? auto = false : null;
  let config = {
      maxFieldsSize: 200 * 1024 * 1024,
  };
  if (auto) config.uploadDir = uploadDir;
  return new Promise(async (resolve, reject) => {
      new multiparty.Form(config)
          .parse(req, (err, fields, files) => {
              if (err) {
                  reject(err);
                  return;
              }
              resolve({
                  fields,
                  files
              });
          });
  });
};
```
##### fBase64
* 前端
1. 通过 FileReader 把 File 对象变成 base64 编码
2. 把 base64 编码经过 encodeURLComponent 转义，转掉一些特殊字符(如"&")防止服务器收到不可预知的请求
3. 通过 file=[base64Url]&filename=[name] 的形式把数据放到 body 里，通过 Content-Type: application/x-www-form-urlencoded 的格式传给服务器。
* 后端
1. 拿到 base64, decodeURIComponent 出来得到原始编码
2. 通过 Buffer.from 把 base64原始编码 转成正常的文件数据，通过 SparkMD5 根据二进制数据生成文件名
3. 检测文件是否存在  (如果两张图片名字不同，但是内容一样，最后检测就是已存在)
  - 如果已存在就通知前端已存在
  - 如果不存在，通过 fs.writeFile 将 二进制数据 写入到指定位置。
* 代码
```js
// 前端
try {
  const base64Url = await fileToBase64(file);
  const data = await instance.post('/upload_single_base64', {
    file: encodeURIComponent(base64Url),
    filename: file.name
  }, {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    }
  });
  if (+data.code === 0) {
    console.log('base64上传成功!', data.servicePath);
  }
  else {
    throw new Error(data.codeText);
  }
}
catch (e) {
  console.error(e);
}
finally {
  uploadSelect.classList.remove('loading');
}
```
```js
// 后端
app.post('/upload_single_base64', async (req, res) => {
  let file = req.body.file,
      filename = req.body.filename,
      spark = new SparkMD5.ArrayBuffer(),   // 根据文件内容生成 hash 的文件名
      suffix = /\.([0-9a-zA-Z]+)$/.exec(filename)[1],
      isExists = false,
      path;
  file = decodeURIComponent(file);
  file = file.replace(/^data:image\/\w+;base64,/, "");
  file = Buffer.from(file, 'base64');  // 变成正常文件对象
  spark.append(file);
  path = `${uploadDir}/${spark.end()}.${suffix}`;  // spark.end 生成 hash 文件名
  // 检测是否存在
  isExists = await exists(path);
  if (isExists) {
      res.send({
          code: 0,
          codeText: 'file is exists',
          originalFilename: filename,
          servicePath: path.replace(__dirname, HOSTNAME)
      });
      return;
  }
  writeFile(res, path, file, filename, false);
});
```

### f拖拽上传
1. 监听DOM元素的 dragover 和 drop 事件，使用 ev.preventDefault() 阻止浏览器默认行为，防止拖进来文件后打开了新标签加载图片等。
2. 在 drop 事件回调中，通过 ev.dataTransfer.files[0] 取得放置的文件。
3. Jiang 将文件上传到服务器。
#### f拖拽事件
* dragenter: 进入
* dragleave: 离开
*  dragover: 区域内移动
*      drop: 放置到容器
#### 代码
```js
uploadDrag.addEventListener('dragover', function(ev) {
  ev.preventDefault();
});
uploadDrag.addEventListener('drop', function(ev) {
  ev.preventDefault();
  const file = ev.dataTransfer.files[0];
  if (!file) {
    return;
  }
  uploadFile(file);
})
```

### f展示缩略图 f缩略图
把 base64 赋值给 img 的 src 属性。 

### f内容哈希 f处理文件名 f检测文件是否存在 f哈希 fhash f文件名
使用 SparkMD5, 根据文件内容，生成 hash 的文件名。
* 前端
```js
function fileToHash(file) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = function (ev) {
      const buffer = ev.target.result;
      const spark = new SparkMD5.ArrayBuffer();
      spark.append(buffer);
      resolve(spark.end());
    }
    fr.onerror = function (err) {
      reject(err);
    }
    fr.readAsArrayBuffer(file);
  });
}
```
* 后端
```js
const buffer = Buffer.from(file, 'base64');
const spark = new SparkMD5.ArrayBuffer(),
spark.append(buffer);
const hash = spark.end();
```

### f进度管控 f进度
利用 axios 的 onUploadProgress 配置获取上传进度。实际上也是用了 XMLHttpRequest 的 xhr.upload.onprogress 这个 API。
```js
// instance.post = axios.create(); ...
const data = await instance.post('/upload_single', fd, {
  onUploadProgress(ev) {
    const { loaded, total } = ev;
    uploadProgress.style.display = 'block';
    uploadProgressValue.style.width = `${loaded/total*100}%`;
  }
});
```
```js
const xhr = new XMLHttpRequest();
xhr.upload.onprogresss = function() {...}
```

### f限制文件格式 f格式
- 方案1  
在 js 中处理。
```js
const file = uploadInput.files[0];
// 限制文件上传的格式
if (!/png|jpg|jpeg/i.test(file.type)) {
    alert('上传格式不对!');
    return;
}
```
- 方案2 
使用 accept 在 input 标签中限制。
<input type="file" class="upload_inp" accept=".png,.jpg,.jpeg">
- 方案3
读取文件的二进制数据，判断数据头部。


### f限制文件大小 
检查 File 对象的 size 属性，单位: Byte
```js
// 限制文件的大小, 单位: Byte
if (file.size > 2 * 1024 * 1024) {
    alert('文件不能超过 2MB!');
    return;
}
```


# f项目细节 f细节
## f代表模块
* 代表管理
* 权限管理
* IC卡管理
* 密码管理
* 指纹管理
### f代表管理
代表信息的增删改查(姓名、类型、代表团...)、代表资料上传、代表名单下载。
#### 难点
代表资料上传（上传大文件）
这是一份 .zip 文件，解压以后有
  - 一张存放代表名单的表格 (.xls)
  - 一个存放所有代表照片的文件夹
一般代表数量会达到1000以上，.zip文件大小会达到 200 MB。

## f会议模块
* 会议管理
* 与会代表
* 人员排位
* 阅看管理
* 会议日志
### f会议管理
#### 会议的层级
- 会议
    - 日程1
      - 议程 1-1
        - 议题 1-1-1
        - 议题 1-1-2
      - 议程 1-2
    - 日程2
    - 日程3
会议-日程-议程-议题 增删改查
#### 议题细节
- 议题名称
- 会议主持人
- 议题选项
  - 议题模式 表决模式/普通模式
  - 表决模式 同意/反对、表决方式、选举方式、评议方式
  - 记名方式 记名/不记名投票
  - 控制方式 操作员控制/预设表决时间 表决时间(1分钟)
  - 计票方式 最后一次按键有效/第一次按键有效
  - 评议方式 满意/称职/合格

### f会议日志
渲染一个会议日志长列表，每次会议数据量在 5w~10w。
* 可以筛选会议日志类型, 如只显示: 签到、议程、议题、表决、话筒、设备、译员间
* 可以导出会议日志
* 可以检索会议日志

数据结构，左边是时间，右边是一行标题，然后下面一行内容，像:
2022-08-29 17:06:13  开始会议
2022-08-29 17:07:13  开始签到
2022-08-29 17:16:13  结束签到
                     签到结果: 应到人数 1000, 实到人数 998, 未到人数 2
2022-08-29 17:36:13  开始表决
2022-08-29 17:40:00  结束表决
2022-08-29 17:45:00  xx代表开始发言
2022-08-29 17:47:13  xx代表结束发言
2022-08-29 17:50:13  xx代表开始发言
2022-08-29 18:06:13  xx代表结束发言
2022-08-29 18:36:13  结束会议

## f用户模块
* 用户管理
* 角色管理
* 个人信息
### f用户管理
用户增删改查
### f角色管理
SY(system)
SA(super administrator)
FA(file administrator)
DEVICE(taidenDevice)
PA(edu platform administrator)
USER(edu platform user)
MA(media user)
### f个人信息
修改密码
修改手机号/邮箱
修改名称/头像

## f设置模块
* 布局管理
会场设计器
* 会议类型
会议类型增删改查
* 服务器设置
重启、关机、第三方配置用户接口、下载阅看app
