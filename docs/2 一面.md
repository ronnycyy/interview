# 目录 
* JS
* CSS
* HTML
* 浏览器
* 手写题


============================================== fJS ==============================================
# f数据类型 fJS有哪些数据类型
一共有8中数据类型，分别是:
* Undefined
* Null
* Boolean
* String
* Number
* BigInt
* Symbol   (原始数据类型)
* Object   (引用数据类型)

其中，Symbol 和 BigInt 是 ES6 新增的数据类型。
Symbol: 代表创建后独一无二的数据，它主要是为了解决属性名冲突的问题。
BigInt: 是一种数字类型的数据，它可以超过 Number 能表示的最大范围，更加安全地存储和操作大整数。

这些数据可以分为原始数据类型和引用数据类型:
* 原始数据类型: Undefined、Null、Boolean、Number、String、Symbol、BigInt, 存放在栈中;
* 引用数据类型: 对象、数组和函数, 存放在堆中;


# fBigInt
BigInt 是一种内置对象，它提供了一种方法来表示大于 2^53 - 1 的整数。这原本是 Javascript 中可以用 Number 表示的最大安全数字(Number.MAX_SAFE_INTEGER)。BigInt 可以表示任意大的整数。
## fBigInt 和 fNumber 的区别
* BigInt 不能用于 Math 对象中的方法;
* BigInt 不能和任何 Number 实例混合运算;
## 为什么有 BigInt 的提案？
JS 超过 Number.MAX_SAFE_INTEGER 时 (2^53-1 [9007199254740991])，会出现计算不准确的情况，这使得 JavaScript 不适合进行科学和金融方面的精确计算。因此官⽅提出了BigInt来解决此问题。 

JS 的 Number 是 64位的，但前

## 使用
可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数 BigInt()（但不包含 new 运算符）并传递一个整数值或字符串值。
```js
const theBiggestInt = 9007199254740991n;
const alsoHuge = BigInt(9007199254740991);  // 9007199254740991n
const hugeString = BigInt("9007199254740991");  // 9007199254740991n
const hugeHex = BigInt("0x1fffffffffffff");  // 9007199254740991n
const hugeBin = BigInt("0b11111111111111111111111111111111111111111111111111111");  // 9007199254740991n
```

# fSymbol
ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。
ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它属于 JavaScript 语言的数据类型之一，其他数据类型是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、大整数（BigInt）、对象（Object）。

Symbol 值通过Symbol()函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
```js
let s1 = Symbol('foo');  // 不能使用new命令，否则会报错
s1 // Symbol(foo)
s1.toString() // "Symbol(foo)"
```

# f原型
### 原型
每个由构造函数创建的对象，都拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。
### 原型链
原型对象也可能拥有原型，并从中继承方法和属性，一层一层往上推导，这样的关系被称为原型链，它解释了为什么在 JS 中一个对象会拥有，定义在其他对象中的属性和方法。
## 注意点
一般来说，对象不应该能够获取到原型，不过现在浏览器中都实现了 __proto__ 属性来访问这个属性，但是最好不要使用这个属性，因为这个属性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。我们可以使用 Object.getPrototypeOf() 方法来获取对象的原型。
## 缺点
在原型链上查找属性会比较耗时，对性能有副作用，这在性能要求严苛的场景下影响很大。比如，用for...in 遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。
## 解决方案
要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，可以使用从 Object.prototype 继承的 hasOwnProperty 方法，这样避免了查找原型链，可以提升一些性能。

## f坑爹原型题 (聊完 原型 大概率会做这些坑爹题)
关键: 现在操作的是`函数`还是`对象`。
### 函数
1. `函数.__proto__ === Function.prototype`
2. `Foo.constructor === Function` => `Function.constructor === Function`  环
### 对象
1. `xx.prototype.__proto__ === Object.prototype`。
2. `Object.prototype.__proto === null`  单链表


## f继承 (聊完 原型 可能会让我手写)
### 寄生组合继承
这个是用 ES5 实现继承比较好的方式，优点:
1. 没有父类的实例属性。
2. 一个原型对象共享给多个实例。
```js
// 父类
function Father() {}
// 子类
function Son() {}
// 通过寄生方式，砍掉父类的实例属性，避免了组合继承生成两份实例的缺点
Son.prototype = Object.create(Father.prototype);
// 修复构造函数指向
Son.prototype.constructor = Son;
```
### class继承
ECMA-262 规范推荐的写法，注意两点:
1. 使用extends表明继承自哪个父类。
2. 在子类构造函数中必须调用super。
```js
class Son extends Father {
  constructor(name) {
    super(name);
    this.name = name || "son";
  }
}
```

# fthis f上下文
上下文是对"拥有当前执行代码的对象"的引用，它始终是this的值。
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

- 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
- 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
- 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
- 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

# f作用域
作用域是对变量可访问范围的限制，作用域分为全局作用域、函数作用域、以及 ES6 的块级作用域。内层作用域可以访问外层作用域，外层作用域不可以访问内层作用域。
### 作用域链
在当前作用域中查找变量，如果没有找到，就去父级作用域查找，找不到就再往上，一直找到全局作用域为止，这一层层关系形成了一条链，这就是作用域链。
### 预解析
预解析(Hoisting) 是伴随作用域的概念。在JS代码执行之前，也就是编译阶段，先把var变量的声明和函数的声明，提升到当前作用域的顶部。这样即使函数声明写在函数使用的后面，也可以正常执行。
注意: 当一个函数遇到一个同名的值为undefined的变量，会忽略掉这个undefined变量，所以同名的变量和函数都提升时，函数会覆盖掉这个变量。
## 说用途
作用域链的作用是保证对`执行环境有权访问的所有变量`和`函数`的`有序访问`，通过作用域链，可以一层层按顺序访问到外层环境的变量和函数。

# f执行上下文  (其实是作用域的概念..)
执行上下文是JS执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文。执行上下文分为全局执行上下文、函数执行上下文、eval执行上下文。
### 全局执行上下文
任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。
### 函数执行上下文
当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。
### eval上下文
执行在eval函数中的代码会有属于他自己的执行上下文。
## 说用途
JavaScript解释器开始执行代码时，首先会创建全局执行上下文，后面每次调用一个函数，都会创建一个新的执行上下文。
每次创建一个执行上下文时，该执行上下文就会被添加到调用栈的顶部。浏览器总是执行位于调用栈顶部的执行上下文，一旦执行完毕，该执行上下文就会从调用栈中弹出，然后控制权来到栈的下一个执行上下文中。

# f闭包
一个外层函数返回一个内层函数，这个内层函数和`对外层函数作用域的引用`捆绑在一起，这样的组合就是闭包。
## 说用途
闭包有两个用途，一个是创建私有变量，另外一个是延长变量的生命周期。
1. 创建私有变量
外层函数运行结束后，只有它返回的内层函数可以访问外层函数的作用域的变量，其他人不能访问，所以这些变量就成为内层函数的私有变量。(这些变量就好像内层函数的专属背包一样，所以形象地称为闭包)
2. 延长变量的生命周期
具体来说，是使已经运行结束的外层函数上下文中的变量对象继续留在内存中，因为内层函数保留了这个变量对象的引用，所以这个变量对象不会被回收。这样外层函数结束以后，闭包还能继续使用。
3. 业务中闭包的使用场景有: 防抖、节流、柯里化、回调等
## 优缺点
### 优点
就是上面说的用途: 1.创建私有变量 2.延长变量的生命周期
### 缺点
如果闭包使用不正确，很容易造成内存泄漏。

比如引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。
所以在使用闭包的时候，我们要尽量注意一个原则: 如果该闭包会一直使用，那么它可以作为全局变量而存在; 但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。
如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。
(一个很多人都有的误区: 闭包不会造成内存泄漏，代码写错了才会造成内存泄漏!)

# f垃圾回收
JavaScript在创建变量时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。
垃圾回收算法主要依赖于`引用`的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限，不管是隐式还是显式的，都叫做一个对象引用另一个对象。例如，一个 `Javascript`对象具有对它原型的引用，这是隐式引用，还有对它属性的引用，这是显式引用。
## 2.说用途
浏览器的垃圾回收算法主要有两种 ——  引用计数 和 标记清除。
### 2-1. f引用计数
这个是最初级的垃圾收集算法，它的理念是: 把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`。如果没有`引用`指向该对象，对象将被垃圾回收机制回收。
#### 引用计数的缺点
`引用计数`无法处理`循环引用`的情况。比如在一个函数中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
### 2-2. f标记清除
标记清除是现代浏览器常见的垃圾回收算法。这个算法把`对象是否不再需要`简化定义为`对象是否可以获得`。
算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……。从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象，`不能获取的对象`视为垃圾数据，它们所占的内存就可以回收了。
#### 标记清除的优点
`标记清除`可以有效解决`循环引用`的问题: 从全局对象触发，无法获取互相引用的两个对象，因此，他们将会被垃圾回收器回收。


## f防抖 f节流
防抖是 短时间内多次触发，只执行最后一次。
节流是 短时间内多次触发，每隔一段时间执行一次。
```js
// 防抖: 短时间内多次触发，只执行最后一次  (immediate参数控制首次是否触发)
function debounce(fn, time, immediate = false) {
  let timer = null;
  return function () {
    if (immediate) {
      fn();
      immediate = false;
      return;
    }
    if (timer !== null) {
      clearTimeout(timer);  // 清除上次延时任务，重新设置一次
    }
    timer = setTimeout(() => {
      fn();
      timer = null;
    }, time);
  }
}
// 节流: 持续触发，每隔一段时间执行一次
function throttle(fn, time) {
  let last = new Date();
  return function () {
    const now = new Date();
    if (now - last >= time) {  // 间隔时间后才触发
      fn();
      last = now;
    }
  }
}
```
### 防抖和节流的使用场景
TODO:


# f内存泄漏
## 1.讲概念
内存泄漏是指程序中已分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃。
## 2.特点
内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。
内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃。
## 3.如何防止内存泄漏
1. 检查是否有意外的全局变量没有清除。
2. 清除定时器内部的变量。比如设置了 setInterval 而忘记取消，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中无法被回收。
3. 在低版本的浏览器环境下，要防止循环引用。某些低版本浏览器的垃圾回收机制还在使用引用计数，循环引用的内存无法释放，会造成内存泄漏。


# fbind fcall fapply
## 讲概念
### bind
bind 方法创建一个新的函数，在 bind 被调用时，这个新函数的 this 被指定为 bind 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
### call
call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。
### apply
apply 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。
## 注意点
### 连续的 bind 以哪个为准？
第一个。我的理解是, 底层就是这么实现的。
TODO: 看一下
### 已经被 bind 的函数，再 call/apply 不会改变 this
已经被 bind 绑定 this 的函数，再通过 call或者 apply 传入 this 来执行，传入的 this 是不会生效的，生效的只有 bind 的 this。包括连续的 bind，也只有第一次 bind 会生效， this 永远指向第一次 bind 的参数。
## 手写 (大概率会写)
```js
Function.prototype.myApply = function () {
  // 要判断一下，因为有可能有这种情况:
  // const o = {};  Object.setPrototypeOf(o, Function.prototype);
  if (typeof this !== 'function') {
    throw new TypeError('this is not a function');
  }
  // 没传就是 window
  const ctx = arguments[0] || window;
  // arguments[1] 传的必须是数组
  const args = arguments[1] ? [...arguments[1]] : [];
  // 挂到 context 上，使 fn 以 context 为 this 执行。
  // 担心 context 会有重复变量名，为了不覆盖它，用 Symbol 生成一个唯一的属性名
  // 这样既不影响原对象，又能达到 apply 的目的
  const fnName = Symbol('fnName');
  ctx[fnName] = this;
  // 执行
  const result = ctx[fnName](...args);
  // 删掉挂上去的属性
  delete ctx[fnName];
  // 返回结果
  return result;
}
Function.prototype.myCall = function () {
  // 要判断一下，因为有可能有这种情况:
  // const o = {};  Object.setPrototypeOf(o, Function.prototype);
  if (typeof this !== 'function') {
    throw new TypeError('this is not a function');
  }
  // 没传就是 window
  const ctx = arguments[0] || window;
  // 传的必须是数组，没传就是空数组
  // arguments 不是数组，没有 slice 方法，所以要借用空数组
  const args = [].slice.call(arguments, 1);
  // 挂到 context 上，使 fn 以 context 为 this 执行。
  // 担心 context 会有重复变量名，为了不覆盖它，用 Symbol 生成一个唯一的属性名
  // 这样既不影响原对象，又能达到 apply 的目的
  const fnName = Symbol('fnName');
  ctx[fnName] = this;
  // 执行
  const result = ctx[fnName](...args);
  // 删掉挂上去的属性
  delete ctx[fnName];
  // 返回结果
  return result;
}
// 注意 bind 的特性:
// 1. 当成普通函数使用，此时 bind 生效。
// 2. 当成构造函数使用，此时 bind 无效。
Function.prototype.myBind = function (context) {
  // 要判断一下，因为有可能有这种情况:
  // const o = {};  Object.setPrototypeOf(o, Function.prototype);
  if (typeof this !== 'function') {
    throw new TypeError('this is not a function');
  }
  // 待绑定的函数
  const fToBind = this;
  // 用于绑定原型链
  const fNop = function () { };
  // 转成数组
  const outerArgs = [].slice.call(arguments, 1);
  // 返回新的绑定函数
  function fBound() {
    // 将 arguments 转成 真正的数组
    const innerArgs = [].slice.call(arguments);
    // 如果是 new，this 是以 fBound 为构造函数，创建的实例（类比于 [] instanceof Array）
    // 如果不是 new，this 一般是 window
    // 检查是不是 new，从而决定用不用外来 this (context)
    return fToBind.apply(this instanceof fBound ? this : context, outerArgs.concat(innerArgs));
  }
  // 将"待绑定函数"视为构造函数，保存它的原型链，以防后续的 new 操作
  if (fToBind.prototype) {
    fNop.prototype = fToBind.prototype;
  }
  fBound.prototype = new fNop();

  return fBound;
}
```

# fNew
## 1. 讲概念 --  new 的时候发生了什么
1. 以 构造函数的原型对象为原型，创建一个对象。
2. 以该对象为上下文，执行构造函数，同时传递实参。
3. 判断执行构造函数返回的值:
  a. 如果是一个引用类型，就返回这个引用。
  b. 如果不是引用类型，返回创建的对象。
## 手写new
```js
// constructor: new的目标函数，也就是构造函数
function _new(constructor, ...args) {
  // 注意健壮性
  if (Object.prototype.toString.call(constructor) !== '[object Function]') {
    console.error('第一个参数请传入函数');
    return;
  }
	// 创建一个继承构造函数原型的对象，即将把它作为构造函数的执行背景。
  const context = Object.create(constructor.prototype);
  // 以该对象为this，执行构造函数
  // 构造函数往往会有this.name = name之类的语句，也就是说这一步在填充对象。
  const result = constructor.apply(context, args);
  // 如果有执行结果，返回执行结果；如果没有，返回该对象。
  return (typeof result === 'object' && result !== null) ? result : context;
}
```
### 手写以后的追问
1. 为什么不用 Object.setPrototypeOf 来修改原型？
mdn上介绍过，由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的原型在各个浏览器和 JavaScript 引擎上都是一个很慢的操作，如果开发者关心性能，应该避免设置一个对象的原型。相反，应该使用 Object.create() 来创建带有您想要的原型的新对象。
2. 为什么源码里有很多 const o = Object.create(null) ，不能直接 const o = {} 吗？
Object.create(null)可以创建一个纯净的对象，对象上没有从 Object.prototype 继承来的属性。


# f箭头函数
箭头函数表达式的语法比`函数表达式`更简洁，并且没有自己的this, 没有arguments, 没有 constructor, 也没有prototype。
## 用途
箭头函数表达式更适用于那些本来需要匿名函数的地方，比如 并且它不能用作构造函数。 (因为它没有 constructor，也就是构造器)
## 箭头函数的this指向哪里
箭头函数没有属于⾃⼰的this，它只会从自己的作用域链的上一层继承`this`，这个this也不会被改变。
## 箭头函数和普通函数的区别
1. 箭头函数比普通函数写法更简洁。
2. 箭头函数没有自己的this。
3. 箭头函数继承来的this永远不会改变。(call/apply/bind 都不能改)
4. 箭头函数不能作为构造函数使用，强行new会报错。
5. 箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。
6. 箭头函数没有prototype。
7. 箭头函数不能用作Generator函数，不能使用yeild关键字。
## new一个箭头函数会怎么样 (箭头函数能作为构造函数/构造器吗)
new 一个箭头函数会报错，因为箭头函数没有自己的prototype，也就没有constructor, 所以不能用作构造函数。 
```js
const Foo = () => {};
const foo = new Foo(); // TypeError: Foo is not a constructor
```
## 特点
* 没有自己的 this，只有继承的 this
* 没有 arguments
* 没有 constructor
* 没有 prototype
### 没有自己的 this，只有继承的 this
箭头函数不会创建自己的`this`,它只会从自己的作用域链的上一层继承`this`。
由于箭头函数没有自己的`this`指针，通过 call 或 apply 方法调用一个函数时，第一个参数会被忽略，第二个往后的参数才会生效。
```js
function Person(){
  this.age = 0;
  setInterval(() => {
    this.age++; // |this| 正确地指向 p 实例
  }, 1000);
}
var p = new Person();
```
### 没有 constructor
new 一个箭头函数会报错，因为箭头函数不能用作构造器，和 new一起用会抛出错误。 为啥？它没有 prototype，也就没有 constructor。
```js
var Foo = () => {};
var foo = new Foo(); // TypeError: Foo is not a constructor
```
### 没有 prototype
箭头函数没有prototype属性。
```js
var Foo = () => {};
console.log(Foo.prototype); // undefined
```

# f数据类型
JavaScript 语言中数据类型集合由原始值和对象组成。
## 原始值（直接表示在语言底层的不可变数据）
布尔类型
Null 类型
Undefined 类型
Number 类型
BigInt 类型
String 类型
Symbol 类型
## 对象（一组属性的集合）
函数、对象

# f判断数据类型
## 方法一: ftypeof
typeof 操作符返回一个字符串，表示操作数的类型。
### typeof 缺点
1. 对 Object/Array/Map/Set/Null 都是返回 "object"，无法进一步细分类型。
2. `typeof null` 是 "object"，让人疑惑，这是一个历史原因:
在 JavaScript 最初的实现中，JavaScript 中的`值`是用`表示类型的标签`和`实际数据值`表示的。它用一个`32bit`的数据存储，其中用了 `3个bit` 来存储类型，`对象`的类型是 `000`。而由于`null`代表的是空指针，值为`0x00`，所以 `null`的类型标签也是`000`，所以 `null` 也被认为是一个 `对象`，`typeof null` 也就返回 "object"。
## 方法二: Object.prototype.toString.call
这个比较准确。可以使用 Object.prototype.toString.call 做细分判断，它同样返回一个字符串，值为 "[object Constructor]"
## 方法三: finstanceof
instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
### instanceof 缺点
1. 如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 true，因为 Foo.prototype 属性的值有可能会改变，改变之后的值很有可能不存在于 obj 的原型链上，这时原表达式的值就会成为 false。
2. 另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 __proto__ 伪属性，是可以实现的。比如执行 obj.__proto__ = {} 之后，obj instanceof Foo 就会返回 false 了。
3. 在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回 false，因为 Array.prototype !== window.frames[0].Array.prototype，并且数组从前者继承。
### instanceof 的坑爹题
instanceof 检查`右边这个构造函数的prototype`也就是原型，是否在`左边这个对象`的原型链上，是就返`true`，不是就返回`false`。
```js
// 目标:  检查 Function.prototype 是否在 Object 的原型链上。
// 思路:  把 Object 看成一个对象，它是由 Function 构造的，于是 Object.__proto__ === Function.prototype。
// 答案:  true;
Object instanceof Function  // true;

// 目标:  检查 Object.prototype 是否在 Function 的原型链上。
// 思路:  把 Function 看成一个对象，它是由 Function 构造的，于是 Function.__proto__ === Function.prototype，
//    然后 Function.prototype 是一个普通的对象，它是由 Object 构造的，所以 Function.prototype.__proto__ === Object.prototype。
//    所以 Function.__proto__.__proto___ === Object.prototype。
// 答案: true;
Function instanceof Object  // true;  
```

# ffor..in  fforin  遍历key
`for...in`语句迭代一个对象的除`Symbol`以外的`可枚举属性`，包括`继承`的可枚举属性。
(
  1. 通过 `Object.prototype.hasOwnProperty` 只遍历自身属性
  2. Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
)
## 用途
`for...in`是为遍历对象属性而构建的，不建议与数组一起使用，数组可以用`Array.prototype.forEach`和`for...of`。
`for...in`最常用的地方应该是用于调试，可以更方便的去检查对象属性（通过输出到控制台或其他方式）。尽管对于处理存储数据，数组更实用些，但是你在处理有key-value数据（比如属性用作“键”），需要检查其中的任何键是否为某值的情况时，还是推荐用`for...in`。
## 代码
```js
var prototypeObject = {a: 1, b: 2, c: 3};
function ColoredTriangle() {
  this.color = 'red';
}
ColoredTriangle.prototype = prototypeObject;
var obj = new ColoredTriangle();
for (var prop in obj) {
  // 只拿自己本身的属性，不要原型对象上的属性。
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}
// Output:
// "obj.color = red"
```
## 不要遍历初原型对象上的某个属性，除了 hasOwnProperty, 还有什么方案?
1. Obejct.keys(obj)
2. 把原型对象该属性描述符的 enumerable 设置为 false, 前提是该属性描述符的 configurable 为 true。
```js
var o = {};
// 初始化 prop1 属性是可枚举的
Object.defineProperty(o, 'prop1', {
  value: 6,   // 属性值
  configurable: true,  // 该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。
  enumerable: true,  // 该属性会出现在对象的枚举属性中，可用于 for..in 和 Object.keys
  writable: true,   // 值能被赋值运算符改变
});
// 修改 prop1 属性为不可枚举, 这样就不会被遍历出来了
Object.defineProperty(o, 'prop1', {
  enumerable: false,
});
```

# ffor..of  遍历value
`for...of`语句在`可迭代对象`上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的`值`执行语句.
`可迭代对象`包括 Array，Map，Set，String，TypedArray，arguments 对象等。
```js
// 迭代map例子
const map = new Map([["a", 1], ["b", 2], ["c", 3]]);
for (const entry of map) {
  console.log(entry);
}
// ["a", 1]
// ["b", 2]
// ["c", 3]
```
## 用途
实现迭代接口[Symbol.iterator]，自定义被迭代的数据。
```js
const iterable = {
  [Symbol.iterator]() {
    return {
      i: 0,
      next() {
        return  this.i < 3 ? { value: this.i++, done: false } : { value: undefined, done: true };
      }
    };
  }
};
for (const value of iterable) {
  console.log(value);
}
// 0
// 1
// 2
```

# ffor..in 和 for..of 的区别
无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
1. 一个是 `key`，一个是 `value`。
* for...in 语句迭代对象除`Symbol`外的可`枚举属性`。
* for...of 语句遍历可迭代对象定义要迭代的数据。
2. 访问原型链
* `for..in` 会把从原型链上继承的`可枚举属性`也遍历出来
* `for..of` 是按对象`实现的/内置的`迭代接口来遍历，一般不会遍历到原型链上的值。


# fdefineProperty  fObject.defineProperty
Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。
## 用法
接收三个参数
1. 对象本身  obj
2. 属性名   'propKey'
3. 描述对象  查看下面的例子
## 例子: 创建属性
```js
var o = {}; // 创建一个新对象
var aValue = 38;
Object.defineProperty(o, "a", {
  value : 37,   // 属性值
  writable : true,  // 值能被赋值运算符改变
  enumerable : true,  // 该属性会出现在对象的枚举属性中，可用于 for..in 和 Object.keys
  configurable : true,  // 该属性的描述符能够被改变，同时该属性也能从对应的对象上被删除。
  get: function() { return aValue; },  // 当访问该属性时，会调用此函数。该函数的返回值会被用作属性的值。
  set: function(data) { aValue = data; },  // 当属性值被修改时，会调用此函数。
});
```
## 例子: 修改属性
```js
Object.defineProperty(o, 'a', {
  value: 37,
  writable: false  // 该属性被称为“不可写的”。它不能被重新赋值。
});
```

# fmap  这是数组的map方法, 不是 Map 数据结构
## 1.讲概念
map 方法`创建一个新数组`，这个新数组由原数组中的`每个元素都调用一次提供的函数`后的返回值组成。
map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在`有值的索引`上被调用；那些`从来没被赋过值`或者`使用 delete 删除的索引`则不会被调用。
## 2.说用途
因为map`生成一个新数组`，当你不打算使用返回的新数组却使用map是违背设计初衷的，请用`forEach`或者`for-of`替代。
## 3.注意点
map 方法`处理数组元素的范围是在 callback 方法第一次调用之前就已经确定了`。调用map方法之后追加的数组元素`不会被callback访问`。如果存在的数组元素改变了，那么传给callback的值是map访问该元素时的值。在map函数调用后但在访问该元素前，该元素被删除的话，则无法被访问到。

# fforEach
## 1.讲概念
forEach 方法对数组的每个元素执行一次给定的函数。
forEach 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。
forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。
已删除的项不会被遍历到，如果已访问的元素在迭代时被删除了，比如使用 shift，之后的元素将被跳过。
## 2.注意点
除了抛出异常以外，没有办法中止或跳出 forEach循环。如果你需要中止或跳出循环，forEach() 方法不是应当使用的工具。
若你需要提前终止循环，你可以使用：every/some/find/findIndex。
## 3.手写forEach
```js
// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback, thisArg) {

    var T, k;

    if (this == null) {
      throw new TypeError(' this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== "function") {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}

```

# 如何跳出 map 或 forEach 循环
map 和 forEach 不能被中断: 一旦开始就不能 break，如果想中途跳出循环，可以在遍历的外层加一个 try...catch，然后中途 throw 一个 Error。
```js
const a = [1,2,3,4,5,6];
try {
  a.forEach(v => {
    if (v === 3) {
      throw new Error('break');
      // break;  // Uncaught SyntaxError: Illegal break statement
    }
    console.log(v);
  })
} catch(e) {
  console.error(e);
}
```

# f拷贝  fcopy  fdeepClone fclone
拷贝对象分为两种情况，一种是`浅拷贝`，一种是`深拷贝`。
## f浅拷贝
`浅拷贝`指的是简单地将一个对象的属性值复制到另一个对象，如果有的属性的值为`引用`类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。
### 实现
浅拷贝可以使用 `Object.assign` 和 `展开语法` 来实现。
### 缺点
如果拷贝的属性是引用，无法新建一个引用，还是用的旧引用，所以拷贝之后的引用如果修改了属性，会影响到原始对象。
```js
const obj = {
  inObj: {a: 1, b: 2}
}
const clone = {...obj}   // 或  Object.assign({}, obj);
clone.inObj.a = 2;   // 原始对象也变了
console.log(obj) // {inObj: {a: 2, b: 2}}
```
## f深拷贝
为了解决`浅拷贝对象的引用影响原始对象`的问题，我们可以使用`深拷贝`的方式。
深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它`新建一个引用类型`并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引
用。
### 实现
1. 可以用 JSON 的两个 api: `JSON.parse(JSON.stringify())` 实现深拷贝，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现`函数`或者`Symbol类型`的值时，会转换失败。
```js
const o = { fn: function() {}, [Symbol.for('react')]: "我是Symbol值" };
const clone = JSON.parse(JSON.stringify(o));
console.log(clone);  // {}
```
2. 递归。针对 `JSON` 的问题，可以用 `递归` 实现深拷贝，具体的思路是:
遍历原始对象自身的属性，如果是原始类型直接复制，如果是引用类型，则递归地调用`深拷贝`函数，区分不同类型的对象进行处理，然后进行拷贝。
#### 简单版
```js
function deepCopy(object) {
  if (!object || typeof object !== "object") return object;

  const newObject = Array.isArray(object) ? [] : {};
  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      newObject[key] =
        typeof object[key] === "object" ? deepCopy(object[key]) : object[key];
    }
  }
  return newObject;
}
```
#### 全面版
拷贝对象的所有属性
遍历属性，根据属性值:
1. 对象: 递归(根据构造函数，新建不同对象、处理，返回)
2. 非对象: 拷贝原对象的属性值
```js
function isObject(obj) {
  return typeof obj === "object" && obj !== null;
}
function cloneDeep(data, hash = new WeakMap()) {
  if (!isObject(data) || !data || !data.constructor) {
    return data
  }
  let copyData   // 存储各种类型的对象
  const Constructor = data.constructor
  switch (Constructor) {
    case RegExp:
      // 正则表达式: 用原数据新建一个正则对象  new RegExp(...原正则数据) 
      copyData = new Constructor(data)
      break
    case Date:
      // Date: 用时间戳新建一个 Date 对象
      copyData = new Constructor(data.getTime())
      break
    default:
      // 解决循环引用  (obj.circle = obj)
      // 如果遇到过这个引用，返回之前拷贝好的引用s
      // 最原始对象的引用，也在 hash 里
      if (hash.has(data)) {
        return hash.get(data)
      }
      copyData = new Constructor()
      if (Constructor === Map) {
        data.forEach((value, key) => {
          // 原始 Map 的元素，一个一个加入到 拷贝的 Map 中
          copyData.set(key, isObject(value) ? cloneDeep(value) : value)
        })
      }
      if (Constructor === Set) {
        data.forEach(value => {
          // 原始 Set 的元素，一个一个加入到 拷贝的 Set 中
          copyData.add(isObject(value) ? cloneDeep(value) : value)
        })
      }
      // 拷贝过的引用都记录一下
      // WeakMap弱引用，不计入GC的引用中，不干扰垃圾回收的判断
      hash.set(data, copyData)
  }
  // 解决 for..in 不能遍历 Symbol 属性的问题
  const symbols = Object.getOwnPropertySymbols(data)
  if (symbols && symbols.length) {
    symbols.forEach(symkey => {
      copyData[symkey] = isObject(data[symkey]) ? cloneDeep(data[symkey], hash) : data[symkey]
    })
  }
  // 遍历基本属性
  for (var key in data) {
    copyData[key] = isObject(data[key]) ? cloneDeep(data[key], hash) : data[key]
  }
  // 拷贝完成✅
  return copyData
}
```

# f== vs f===  f双等号和f三等号的区别
双等号会尝试类型转换，三等号不会尝试类型转换。

# f==
等于运算符（==）检查其两个操作数是否相等，它会尝试强制类型转换并且比较不同类型的操作数，并返回Boolean结果。
## 实现
根据 ECMA-262规范，相等运算符（`==`和`!=`）使用`抽象相等比较算法`比较两个操作数。
概括如下:
1. 如果两个操作数`都是对象`，则仅当两个操作数都`引用同一个对象`时才返回`true`。
2. 如果一个操作数是`null`，另一个操作数是`undefined`，则返回`true`。
3. 如果两个操作数是`不同类型的`，就会尝试在比较之前将它们转换为`相同类型`：
  * 当数字与字符串进行比较时，会尝试将字符串转换为数字值。
  * 如果操作数之一是`Boolean`，则将布尔操作数转换为`数字1`或`数字0`。如果是true，则转换为1。如果是 false，则转换为0。
  * 如果操作数之一是`对象`，另一个是`数字或字符串`，会先尝试使用对象的`valueOf`方法, 再尝试使用`toString`方法，将对象转换为`原始值`。
4. 如果操作数具有`相同的类型`，执行全等比较。

总结: 尽量转成数字来比较，如果不能转成数字，就转成字符串。

# f===
全等运算符`===`会检查它的两个操作数是否相等，并且返回一个布尔值结果。与相等运算符`==`不同，全等运算符总是认为`不同类型的操作数是不同的`。
## 实现
全等运算符（===和 !==）使用全等比较算法来比较两个操作数。
1. 如果操作数的类型不同，则返回 false。
2. 如果两个操作数都是对象，只有当它们指向同一个对象时才返回 true。
3. 如果两个操作数都为 null，或者两个操作数都为 undefined，返回 true。
4. 如果两个操作数有任意一个为 NaN，返回 false。
5. 否则，比较两个操作数的值：
  * 数字类型必须拥有相同的数值。+0 和 -0 会被认为是相同的值。
  * 字符串类型必须拥有相同顺序的相同字符。
  * 布尔运算符必须同时为 true 或同时为 false。
### 例子
```js
NaN === NaN;  // false (NaN这家伙急眼了连自己都不认识)
+0 === -0;    // true  (全等认为正负零是一样的)
```

# fObject.is
## 1.讲概念
Object.is() 方法判断两个值是否为同一个值。
## 2.说用途
`Object.is`与全等运算符`===`不相同。差别是它们对待`有符号的零`和`NaN`不同。
全等运算符`===`将数字`-0`和`+0`视为`相等`，而将`NaN`与`NaN` 视为不相等。`Object.is`刚好相反。
## 3.说实现
Object.is() 方法判断两个值是否为同一个值，如果满足以下任意条件则两个值相等：
1. 都是 undefined
2. 都是 null
3. 都是 true 或都是 false
4. 都是相同长度、相同字符、按相同顺序排列的字符串
5. 都是相同对象（意味着都是同一个对象的值引用）
6. 都是数字且
  * 都是 +0
  * 都是 -0
  * 都是 NaN
  * 都是同一个值，非零且都不是 NaN
## 4.例子
```js
// 有符号的0
Object.is(+0, -0);    // false
Object.is(0, -0);     // false
Object.is(-0, -0);    // true
Object.is(0n, -0n);   // true
// NaN
Object.is(NaN, NaN)    // true
Object.is(NaN, 0/0);   // true
```
## 4.polyfill
```js
if (!Object.is) {
  Object.defineProperty(Object, "is", {
    value: function (x, y) {
      if (x === y) {
        // 同类型并且同值
        // true: ”不等于0“ 或 "等于0但必须相同符号“
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // 不同类型或不同值
        // 返回true:  x,y 都是 NaN  (Number.NaN, 0/0, NaN)
        // 返回false: 剩余所有情况
        return x !== x && y !== y;
      }
    }
  });
}
```

# fquerySelector
只返回第一个匹配的对象。
文档对象模型Document引用的**querySelector()**方法返回文档中与指定选择器或选择器组匹配的第一个 Element对象。 如果找不到匹配项，则返回 null。
```js
element = document.querySelector(selectors);
```

# fconst f常量
const 会创建一个常量，其作用域可以是全局或本地声明的块。与var变量不同，全局常量不会变为 window 对象的属性。 
const 的值是无法通过重新赋值改变的，也不能被重新声明，但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，可以改变对象的属性。一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。

# flet f变量
let 允许你声明一个作用域被限制在块作用域中的变量、语句或者表达式。与 var 关键字不同的是，var 声明的变量作用域是全局或者整个函数块的。 var 和 let 的另一个重要区别，let 声明的变量不会在作用域中被提升，它是在编译时才初始化。
就像 const 一样，let 不会在全局声明时（在最顶层的作用域）创建 window 对象的属性。
与 var 不同的是，let 只是开始声明，而非一个完整的表达式。这意味着你不能将单独的 let 声明作为一个代码块的主体, 这是有道理的，因为声明的变量无法被访问:
```js
if (true) let a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

# f暂时性死区 fTDZ fTemporal dead zone
从一个代码块的开始直到代码执行到声明变量的行之前，let 或 const 声明的变量都处于“暂时性死区”（Temporal dead zone，TDZ）中。

当变量处于暂时性死区之中时，其尚未被初始化，尝试访问变量将抛出 ReferenceError。当代码执行到声明变量所在的行时，变量被初始化为一个值。如果声明中未指定初始值，则变量将被初始化为 undefined。

与 var 声明的变量不同，如果在声明前访问了变量，变量将会返回 undefined。


# f变量的解构赋值 f解构赋值
解构赋值语法是一种 Javascript 表达式。通过解构赋值，可以将属性/值从对象/数组中取出，赋值给其他变量。
## 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
* 数组:
`let [a, b, c] = [1, 2, 3];`
* Set:
`let [x, y, z] = new Set(['a', 'b', 'c']);`
如果解构不成功，变量的值就等于undefined。
### 将剩余数组赋值给一个变量
当解构一个数组时，可以使用剩余模式，将数组剩余部分赋值给一个变量。
```js
var [a, ...rest] = [1, 2, 3];
console.log(a); // 1
console.log(rest); // [2, 3]
```
注意：如果剩余元素右侧有逗号，会抛出 SyntaxError，因为剩余元素必须是数组的最后一个元素。
## 解构赋值允许指定默认值
`let [foo = true] = [];`
如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
```js
function f() {
  console.log('aaa');
}
let [x = f()] = [1];
```
# 对象的解构赋值
`let { foo, bar } = { foo: 'aaa', bar: 'bbb' };`
对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
## 对象的解构也可以指定默认值
`var {x, y = 5} = {x: 1};`
# 字符串的解构赋值
```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```
# 数值和布尔值的解构赋值
```js
let {toString: s} = 123;
s === Number.prototype.toString // true
```

# fSet
Set 类似于数组，但是成员的值都是唯一的，没有重复的值。
Set对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。
因为 Set 中的值总是唯一的，所以需要判断两个值是否相等。在 ECMAScript 规范的早期版本中，这不是基于和===操作符中使用的算法相同的算法。具体来说，对于 Set，+0（+0 严格相等于 -0）和 -0 是不同的值。然而，在 ECMAScript 2015 规范中这点已被更改。有关详细信息，请参阅浏览器兼容性表中的 “Key equality for -0 and 0”。
另外，NaN 和 undefined 都可以被存储在 Set 中，NaN 之间被视为相同的值（NaN 被认为是相同的，尽管 NaN !== NaN）。
```js
const set = new Set([1, 2, 3, 4, 4]);  // Set(3) {1, 2, 3}
[...set]  // [1, 2, 3, 4]
```
## 用途
### 数组去重
```js
const array = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]
console.log([...new Set(array)])  // [2, 3, 4, 5, 6, 7, 32]
console.log(Array.from(new Set(array)))  // [2, 3, 4, 5, 6, 7, 32]
```
## API
size       返回Set实例的成员总数。
add(v)     添加某个值，返回 Set 结构本身。
delete(v)  删除某个值，返回一个布尔值，表示删除是否成功。
has(v)     返回一个布尔值，表示该值是否为Set的成员。
clear()    清除所有成员，没有返回值。
keys       返回键名的遍历器 (keys和valus方法完全一致)
values     返回键值的遍历器
entries    返回键值对的遍历器
forEach    使用回调函数遍历每个成员

# fWeakSet
WeakSet 对象允许我们将`弱引用对象`存储在一个集合中。
WeakSet 对象是一些对象值的集合，并且其中的每个对象值都只能出现一次。在WeakSet的集合中是唯一的。
## 它和 Set 对象的区别有两点：
1. 与Set相比，WeakSet 只能是`对象`的集合，而不能是任何类型的任意值。
2. WeakSet持弱引用：集合中对象的引用为弱引用。 如果没有其他的对WeakSet中对象的引用，那么这些对象会被当成垃圾回收掉。 这也意味着 WeakSet 中没有存储当前对象的列表。 正因为这样，WeakSet 是不可枚举的。 (弱引用:垃圾回收机制不会考虑WeakSet对该对象的引用)
## 用途
### 检测循环引用
递归调用自身的函数需要一种通过跟踪哪些对象已被处理，来应对循环数据结构的方法。
为此，WeakSet 非常适合处理这种情况：
```js
// 对 传入的 subject 对象 内部存储的所有内容执行回调
function execRecursively(fn, subject, _refs = null){
	if(!_refs)
		_refs = new WeakSet();
	// 避免无限递归
	if(_refs.has(subject))
		return;
	fn(subject);
	if("object" === typeof subject){
		_refs.add(subject);
		for(let key in subject)
			execRecursively(fn, subject[key], _refs);
	}
}
const foo = {
	foo: "Foo",
	bar: {
		bar: "Bar"
	}
};
foo.bar.baz = foo; // 循环引用！
execRecursively(obj => console.log(obj), foo);
```
在第一次运行时创建WeakSet，并将其与每个后续函数调用一起传递（使用内部参数_refs）。 对象的数量或它们的遍历顺序无关紧要，因此，WeakSet 比Set更适合（和执行）跟踪对象引用，尤其是在涉及大量对象时。

# fMap
Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。
一个 Map 对象在迭代时会根据对象中元素的插入顺序来进行——一个 for...of 循环在每次迭代后会返回一个形式为 [key，value] 的数组。
## 用途
1. 用于算法，提供高性能的增删改查。
2. 方便迭代，Map 本身就实现了迭代接口，而且 Map 的键是有序的。
## 键的相等
* 键的比较基于零值相等算法。
与同值相等类似，不过会认为 +0 与 -0 相等。
* NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。
## Objects 和 maps 的比较
### 共性
Object 和 Map 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。
因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Map 使用。
### 区别
不过 Map 和 Object 有一些重要的区别，在下列情况中使用 Map 会是更好的选择:
1. 排除意外的键
Map 默认情况不包含任何键。只包含显式插入的键。
一个 Object 有一个原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。
2. 键的类型
一个 Map 的键可以是任意值，包括函数、对象或任意基本类型。
一个 Object 的键必须是一个 String 或是 Symbol。
3. 键的顺序
Map 中的键是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。
虽然 Object 的键目前是有序的，但并不总是这样，而且这个顺序是复杂的。因此，最好不要依赖属性的顺序。
4. Size	
Size	Map 的键值对个数可以轻易地通过 size 属性获取。
Object 的键值对个数只能手动计算.
5. 迭代
Map 是 可迭代的 的，所以可以直接被迭代。
Object 没有实现 迭代协议，所以使用 JavaSctipt 的 for...of 表达式并不能直接迭代对象。
6. 性能
Map 在频繁增删键值对的场景下表现更好。
Object 在频繁添加和删除键值对的场景下未作出优化。
## 缺点
Map通过使其四个 API 方法共用两个数组（一个存放键，一个存放值）来实现。这样会有2个缺点:
1. 赋值和搜索操作都是 O(n) 的时间复杂度（n 是键值对的个数），因为这两个操作都需要遍历全部整个数组来进行匹配。
2. 可能会导致内存泄漏，因为数组会一直引用着每个键和值。这种引用使得垃圾回收算法不能回收处理他们，即使没有其他任何引用存在了。

# fWeakMap
WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。
## 为什么要使用 WeakMap？ (用途)
在 JavaScript 里，map API 可以 通过使其四个 API 方法共用两个数组（一个存放键，一个存放值）来实现。给这种 map 设置值时会同时将键和值添加到这两个数组的末尾。从而使得键和值的索引在两个数组中相对应。当从该 map 取值的时候，需要遍历所有的键，然后使用索引从存储值的数组中检索出相应的值。

但这样的实现会有两个很大的缺点：
1. 赋值和搜索操作都是 O(n) 的时间复杂度（n 是键值对的个数），因为这两个操作都需要遍历全部整个数组来进行匹配。
2. 可能会导致内存泄漏，因为数组会一直引用着每个键和值。这种引用使得垃圾回收算法不能回收处理他们，即使没有其他任何引用存在了。

相比之下，原生的 WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。原生 WeakMap 的结构是特殊且有效的，其用于映射的 key _只有_在其没有被回收时才是有效的。正由于这样的弱引用，WeakMap 的 key 是不可枚举的（没有方法能给出所有的 key）。如果 key 是可枚举的话，其列表将会受垃圾回收机制的影响，从而得到不确定的结果。因此，如果你想要这种类型对象的 key 值的列表，我们应该使用 Map。
## 优点
1. 原生的 WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。
## 缺点
1. WeakMap 的 key 是不可枚举的, 如果 key 是可枚举的话，其列表将会受垃圾回收机制的影响。
## API
* delete(k)
* has(k)
* set(k,v)
* get(k)
## 实现 clear 方法
```js
class ClearableWeakMap {
  constructor(init) {
    this._wm = new WeakMap(init);
  }
  clear() {
    this._wm = new WeakMap();
  }
  delete(k) {
    return this._wm.delete(k);
  }
  get(k) {
    return this._wm.get(k);
  }
  has(k) {
    return this._wm.has(k);
  }
  set(k, v) {
    this._wm.set(k, v);
    return this;
  }
}
```

# fPromise   
Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。
Promise可以看成一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
## 特点
* 链式调用
连续执行两个或者多个异步操作，在上一个操作执行成功之后，开始下一个的操作，并带着上一步操作所返回的结果。
* 错误传递
通常，一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 onRejected 失败回调函数或者由 .catch() 指定的回调函数。
* 对象的状态不受外界影响  (fPromise状态)
Promise对象代表一个异步操作，有三种状态：
1. pending（进行中）
2. fulfilled（已成功）
3. rejected（已失败）。
只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
* 一旦状态改变，就不会再变，任何时候都可以得到这个结果
Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
## 为什么 ES6 要推出 Promise?
查看优点
## 优点
1. 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。
2. Promise 使得错误可以集中在一个地方处理。
3. Promise对象提供统一的接口，使得控制异步操作更加容易。
## 缺点
1. 无法取消Promise，一旦新建它就会立即执行，无法中途取消。
2. 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
3. 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

## fPromise.all fall  全部完成才完成，一个失败就失败
Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。
```js
const p = Promise.all([p1, p2, p3]);
```
p的状态由p1、p2、p3决定，分成两种情况:
（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。

## fPromise.race frace  一个成功就成功，一个失败就失败
Promise.race()方法是将多个 Promise 实例，包装成一个新的 Promise 实例。比如:
```js
const p = Promise.race([p1, p2, p3]);
```
只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。
### 使用 Promise.race 模拟HTTP请求超时报错  f超时报错
把原始请求的Promise和包裹定时器的Promise一起传给Promise.race，
如果指定时间内没有获得结果，就将 Promise 的状态变为rejected，否则变为 fulfilled。
```js
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
    // throw new Error('test'); 也行
  })
]);
p
.then(console.log)
.catch(console.error);
```

## fPromise.allSettled fallSettled   拿到全部成功失败的数组
Promise.allSetttled 用来确定一组异步操作是否都结束了（不管成功或失败）。所以，它的名字叫做”Settled“，包含了”fulfilled“和”rejected“两种情况。

它接受一个数组作为参数，数组的每个成员都是一个 Promise 对象，并返回一个新的 Promise 对象。返回的 Promise 对象一旦发生状态变更，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，它的回调函数会接收到一个数组作为参数，对应前面数组的每个 Promise 对象。

数组里每个成员是一个对象，对象的status属性的值只可能是字符串fulfilled或字符串rejected，用来区分异步操作是成功还是失败。如果是成功（fulfilled），对象会有value属性，如果是失败（rejected），会有reason属性，对应两种状态时前面异步操作的返回值。
```js
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);
const allSettledPromise = Promise.allSettled([resolved, rejected]);
allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
```

# f0.1+0.2 为什么不等于 0.3? 如何让其相等？ f浮点数
```js
console.log(0.1+0.2);  // 0.30000000000000004
console.log((0.1+0.2).toFixed(1))  // 0.3  四舍五入，取一位小数
```
小数在计算机中是用二进制表示的，具体到JS是用双精度浮点数, 它是64位。

以0.1为例，它转化为 JS 中 64 位二进制的过程是:

## 第一步 用二进制表达
1. 0.1的整数部分用二进制表达为0。
2. 0.1的小数部分 是进行一个循环：每次乘以 2，然后看看是否超过 1：
   2.1 如果超过 1，我们就记下二进制位 1，并把结果减去 1，然后进一步循环操作。
   2.2 如果没超过 1，就记下二进制位 0。

算式            是否超过1     二进制位     余数
0.1*2 = 0.2       否          0         0.2
0.2*2 = 0.4       否          0         0.4
0.4*2=0.8         否          0         0.8
0.8*2=1.6         是          1       1.6-1=0.6
0.6*2=1.2         是          1       1.2-1=0.2
0.2*2 = 0.4       否          0         0.4
0.4*2=0.8         否          0         0.8
0.8*2=1.6         是          1       1.6-1=0.6
0.6*2=1.2         是          1       1.2-1=0.2
…
把二进制位的结果取下来，得到的结果是  0.000110011…，后面的0011会无限循环下去。
拼接整数和小数部分，就得到 0.000110011… (0011无限循环)这样的结果。

## 第二步 改写为科学计数法，计算 s,e,f
1往前挪4位，得到
1.10011001100… x 10^-4

根据公式
(-1)^s * 1.f * 2^e

由于是正数，所以符号位 s=0   (1位)
指数位e=-4+1023(1023是IEEE定义的偏移量)=1019  (10位) (二进制 1111111011)
有效位f=10011001100… (100[1100循环], 53位)

## 第三步 最后的二进制表达 
根据s,f,e，得到最后的二进制表达:
0        1111111011   1001100110011001100110011001100110011001100110011001
s(1位)   e(10位)        f(53位)
此时0.1已经不是精确的0.1了，0.2也是一样的，所以最后相加的结果不是精确的0.3，而是一个近似值。

## 判断 0.1+0.2 和 0.3 相等
1. 可以用 Number.EPSILON 允许误差范围内的相等，如果 0.1+0.2-0.3小于这个范围，就认为是相等的
2. 可以用toFixed得到精确小数位的结果，比如(0.1+0.2).toFixed(1)

# fNumber.EPSILON
Number.EPSILON 表示 `Number可表示的大于 1 的最小的浮点数`和`1`的差值。它接近于 2^-52。
## 用途
测试浮点数是否相等
```js
function isEqual(x,y) {
  return Math.abs(x-y) < Number.EPSILON;
}
// isEqual(0.1+0.2, 0.3)  // true
```

# f判断一个对象是否是数组  fisArray  fArray.isArray  f判断数组的方式有哪些
五种。
## 1. Object.prototype.toString.call  准确✅
```js
Object.prototype.toString.call(obj) === '[object Array]';
```
## 2. 通过ES6的 Array.isArray  准确✅
```js
// 当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能检测 iframes。
Array.isArray(obj);
```
## 3. 通过 instanceof 做判断  不准确❌
```js
// instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
// 这种方法的缺点:
// 1. obj 是跨 iframe 取的值时，不是本 window 的 Array 构造的，会返回 false，造成误判。  
// 2. obj.__proto__ 可能被修改, 所以可能造成误判。
obj instanceof Array; 
```
## 4. 检查对象的__proto__  不准确❌
```js
obj.__proto__ === Array.prototype;  // obj.__proto__ 可能被修改, 所以可能造成误判。
```
## 5. Array.prototype.isPrototypeOf   不准确❌
```js
// isPrototypeOf() 方法用于测试一个对象 (Array.prototype) 是否存在于另一个对象 (obj) 的原型链上。
Array.prototype.isPrototypeOf(obj);   // obj.__proto__ 可能被修改, 所以可能造成误判。
```

# f操作数组的方法有哪些? f数组方法
## 增
* fpush     从尾插入
* funshift  从头插入
## 删
* fpop      从尾弹出
* fshift    从头弹出
## 改
* fsplice   index,deleteCount,...items  从index开始删deleteCount个，然后在index处插入各个item(items)
* fsort     改变原数组为有序。默认排序顺序是: 元素按照转换为字符串的各个字符的 Unicode 位点进行排序。(Beluga,Blue,Humpback)
* freverse  颠倒数组中元素的位置，改变原数组，并返回该数组的引用。
## 查
* find
* findIndex
* filter
* indexOf

# fArray.prototype.slice fslice
slice() 方法返回一个新的数组，这个数组是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。
## 注意浅拷贝
slice 不会修改原数组，只会返回一个`浅拷贝`了原数组中的元素的一个新数组。如果拷贝的元素是个对象引用（不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。
## 例子
```js
// slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。
// 只需将该方法绑定到这个对象上。 
// 函数中的 arguments 就是一个类数组对象。
function list() {
  return Array.prototype.slice.call(arguments);
}
var list1 = list(1, 2, 3); // [1, 2, 3]
```

# fArray.prototype.splice fsplice
splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。
## 参数
1. start
指定修改的开始位置（从 0 计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从 -1 计数，这意味着 -n 是倒数第 n 个元素并且等价于 array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第 0 位。
2. deleteCount (可选)
整数，表示要移除的数组元素的个数。
* 如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。
* 如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。
* 如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。
3. item1, item2, ... (可选)
要添加进数组的元素，从start 位置开始。如果不指定，则 splice() 将只删除数组元素。
## 返回值
由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。
## 例子
```js
// 删除数组的最后一个元素
var array = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = array.splice(array.length-1, 1);
// 运算后的 array: ["angel", "clown", "mandarin"]
// 被删除的元素: ["sturgeon"]
```
```js
// 从索引 2 的位置开始删除所有元素
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2);
// 运算后的 myFish: ["angel", "clown"]
// 被删除的元素: ["mandarin", "sturgeon"]
```
```js
// 从索引 0 的位置开始删除 2 个元素，插入"parrot"、"anemone"和"blue"
var myFish = ['angel', 'clown', 'trumpet', 'sturgeon'];
var removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue');
// 运算后的 myFish: ["parrot", "anemone", "blue", "trumpet", "sturgeon"]
// 被删除的元素: ["angel", "clown"]
```

# fArray的ES6扩展  fES6数组  fES6Array
* Array.prototype.sort()
* Array.of(...args)
* Array.prototype.includes(item)
* Array.prototype.flat(depth) / Array.prototype.flatMap()

## fArray.prototype.sort的稳定性 fsort
常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。
假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。
如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。
早先的 ECMAScript 没有规定`Array.prototype.sort()`的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。`ES2019`明确规定，`Array.prototype.sort()`的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。

## fArray.of 
Array.of()方法用于将一组值，转换为数组。
```js
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
```
### 用途
这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。
```js
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```
上面代码中，Array()方法没有参数、一个参数、三个参数时，返回的结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。
Array.of()基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。
```js
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```
Array.of()总是返回参数值组成的数组。如果没有参数，就返回一个空数组。
Array.of()方法可以用下面的代码模拟实现。
```js
function ArrayOf(){
  return [].slice.call(arguments);
}
```

# Array.prototype.includes fincludes
includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。
## 用法
接收2个参数。
第一个是需要查找的元素值。
第二个是fromIndex。从fromIndex 索引处开始查找 value。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜（即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。
```js
[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
[1, 2, NaN].includes(NaN); // true
```
## 用途
没有该方法之前，我们通常使用数组的 Array.prototype.indexOf 方法，检查是否包含某个值。
indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。includes使用的是不一样的判断算法，就没有这个问题。
```js
[NaN].indexOf(NaN) === -1);  // true  结果没有 NaN ❌
[NaN].includes(NaN);  // true 结果有 NaN ✅
```

# Array.prototype.flat fflat
flat(depth) 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。
不会改变原数组。
## 参数
* depth
指定要提取嵌套数组的结构深度，默认值为 1。
## 扁平化嵌套数组
```js
console.log([0, 1, 2, [3, 4]].flat());  // [0, 1, 2, 3, 4]
console.log([0, 1, 2, [[[3, 4]]]].flat(4));  // [0, 1, 2, [3, 4]]
[1, 2, [3, 4, [5, 6, [7, [9, 10]]]]];.flat(Infinity);  // 使用 Infinity，可展开任意深度的嵌套数组 [1, 2, 3, 4, 5, 6, 7, 9, 10]
```
## 扁平化移除了数组空项
```js
[1, 2, , 4, 5].flat();  // [1, 2, 4, 5]
```
## 实现 flat
### 展开一层
```js
// 1. reduce 与 concat
arr.flat(1);
arr.reduce((arr, cur) => arr.concat(cur), []);
```
```js
// 2. 扩展运算符
const flattened = arr => [].concat(...arr);
```
### 展开多层
```js
// reduce + concat + isArray + recursivity
// 使用 reduce、concat 和递归展开无限多层嵌套的数组
var arr1 = [1,2,3,[1,2,3,4, [2,3,4]]];
function flatDeep(arr, d = 1) {
   return d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])
                : arr.slice();
};
flatDeep(arr1, Infinity);
// [1, 2, 3, 1, 2, 3, 4, 2, 3, 4]
```

# Array.prototype.flatMap fflatMap
flatMap() 方法首先使用`map`映射每个元素，然后使用`flat`将结果压缩成一个新数组。如同 arr.map(...args).flat(1)，但是它比这种连续调两个API的方式效率高一些。
```js
const arr = ["it's Sunny in", "", "California"];
arr.flatMap();  // ["it's", 'Sunny', 'in', '', 'California']
// 相当于
arr.map(x => x.split(" ")).flat(1);  // ["it's", 'Sunny', 'in', '', 'California']
```

# f异步加载JS脚本 f脚本 fJS脚本
## JS脚本异步加载怎么做？
在 script 标签里加 async 或者 defer 属性。
### fasync
并行请求JS脚本，不阻塞浏览器解析页面，JS脚本下载完成后，立即执行。
### fdefer
并行请求JS脚本，不阻塞浏览器解析页面，`DOM完成解析`后，触发`DOMContentLoaded`事件前，执行JS脚本。

# 给 script 加 ftype=module 有什么作用？
将type属性设为module，告诉浏览器知道这是一个 ES6 模块。浏览器对于带有type="module"的`script`都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了`script`标签的defer属性。如果网页有多个`<script type="module">`，它们会按照在页面出现的顺序依次执行。
`script`标签的async属性也可以打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。
```html
<script type="module" src="./foo.js"></script>
<!-- 等同于 -->
<script type="module" src="./foo.js" defer></script>
```
### 特点
对于外部的模块脚本（上例是foo.js），有几点需要注意:
1. 代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
2. 模块脚本自动采用严格模式，不管有没有声明use strict。
3. 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。
4. 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。
5. 同一个模块如果加载多次，将只执行一次。

# f模块化 fJS模块化
JS 模块化主要分两种，一种是 ES6 Module, 一种是 CommonJS。
## fCommonJS
`CommonJS`以`require`为输入，以`module.exports`为输出，主要用在服务端nodejs使用, 它是`运行时`加载的，输出的是`对模块的拷贝`，这意味着两点:
1. 它不能 Tree-Shaking
2. 一旦输出一个值，模块内部的变化就影响不到这个输出值了
## fES6 Module
ES6 Module 是浏览器和服务器通用的模块解决方案。它以`import`为输入，以`export`为输出。
`ESM`是对模块的`引⽤`，即`ESM`只读，不能改变其值，也就是指针指向不能变，类似`const`。
`ESM``编译时`就能确定模块的依赖关系，以及输入和输出的变量，所以能够进行静态分析，使用 Tree-Shaking 进行摇树优化。
## fCommonJS 和 fESM 的异同
同: `CommonJS`和`ESM`都可以对引⼊的对象的属性进⾏赋值，即对对象内部属性的值进⾏改变。
异: 它们有三个重大差异:
1. CommonJS 模块输出的是一个值的拷贝，可以改变；ES6 模块输出的是值的引用，是只读的，不能改变。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3. CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。
## 扩展
其他还有一些用在浏览器端的模块化解决方案，如 AMD(require.js), CMD(sea.js, define语法), UMD(IIFE), 但不是很常用。

# fES6新特性
* let, const (查看 fconst)
* 变量的解构赋值 (查看 f解构赋值)
* Set, Map 新数据结构 (查看 fSet, fWeakSet, fMap, fWeakMap)
* Promise 对象 (查看 fPromise)
* 数组的扩展 (查看 fArray的ES6扩展)
* 箭头函数 (查看 f箭头函数)
* Symbol (查看 fSymbol)
## fES6 概念
ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。

==============================================f浏览器==============================================
# f重排(也就是f回流)  位置/宽高变了
## 讲概念
当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为`重排`。
### 导致`重排`的操作
- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 激活CSS伪类
- 查询某些属性或者调用某些方法
- 添加或者删除可见的DOM元素

在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：
- 全局范围：从根节点开始，对整个渲染树进行重新布局
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局

# f重绘  颜色/背景色变了
## 讲概念
当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是`重绘`。
### 导致`重绘`的操作
- color、background 相关属性：background-color、background-image 等
- outline 相关属性：outline-color、outline-width 、text-decoration
- border-radius、visibility、box-shadow

注意： **当触发重排时，一定会触发重绘，但是重绘不一定会引发重排。**

# f避免重排与重绘
- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
- 使用CSS的表达式
- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
- 避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- 将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于`浏览器的渲染队列机制`。浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。


# f事件机制  fDOM事件机制 f冒泡 f捕获
DOM的事件机制分为`事件捕获`和`事件冒泡`。
当一个事件发生在`具有父元素的元素`上时，现代浏览器运行两个不同的阶段-捕获阶段和冒泡阶段。 
### f捕获
浏览器检查元素的最外层祖先<html>，是否在捕获阶段中注册了一个事件处理程序，如果是，则运行它。
然后，它移动到<html>中`触发事件的元素`的下一个`祖先元素`，并执行相同的操作，然后是`触发事件的元素`再下一个祖先元素，依此类推，直到到达`触发事件的元素`。
### f冒泡
浏览器检查实际点击的元素是否在`冒泡阶段`中注册了一个`事件处理程序`，如果是，则运行它。
然后它移动到下一个`直接的祖先元素`，并做同样的事情，然后是下一个，等等，直到它到达<html>元素。

在现代浏览器中，默认情况下，所有事件处理程序都在`冒泡阶段`进行注册，如果想在`捕获阶段`注册，可以通过 addEventListener 注册事件处理程序，同时把可选的第三个参数设置为 true。
## 2.怎么停止冒泡
`标准事件对象`具有可用的名为`stopPropagation`的函数, 当在事件对象上调用该函数时，它只会让`当前事件处理程序运行`，但事件不会在冒泡链上进一步扩大，因此将不会有更多事件处理器被运行，也就是不会向上冒泡。
## 3.面试题
在一个DOM上绑定两个点击事件，一个冒泡，一个捕获，事件会执行几次？顺序如何？
答: `2次`。先执行捕获的事件处理程序，再执行冒泡的事件处理程序。

# f事件委托  f事件代理
## 1.讲概念
将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。
## 2.说用途
比如有一系列的列表项，如果想让每个列表项被点击时弹出一条信息，您可以将click单击事件监听器设置在父元素<ul>上，这样事件就会从列表项冒泡到其父元素<ul>上。
```html
<body>
  <ul id="parent-list">
    <li id="post-1">Item 1</li>
    <li id="post-2">Item 2</li>
    <li id="post-3">Item 3</li>
  </ul>
  <script>
    // 获取 ul，注册事件处理程序
    document.getElementById("parent-list").addEventListener("click", function (e) {
      // e.currentTarget 是"注册了事件处理程序的元素"，也就是 ul
      if (e.target && e.target.nodeName == "LI") {
        // e.target 是"实际点击的元素"，进入这个条件的，就是 li
        // 打印 li 的  id
        console.log("List item ", e.target.id.replace("post-", ""), " was clicked!");  // List item 1 was clicked!
      }
    });
  </script>
</body>
```
## 3.为什么要用 事件委托？
在日常开发中，li 经常是要从列表中添加和删除的。如果不用`事件委托`，直接把事件处理程序绑定在 li 上的话，每次 li 增加就要绑一次事件处理程序，每次 li 删除又要解绑一次事件处理程序，这样会增加`开发`和`维护`工程的负担，也容易出问题(比如，在 IE6 中不解绑事件处理程序就删除 DOM 的话，会造成内存泄漏)，而用`事件委托`就能很好地解决这些问题。


# f事件循环 浏览器
浏览器中 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。
任务队列可以分为`宏任务队列`和`微任务队列`，当执行栈中的任务执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。一个宏任务执行完以后，就去执行微任务队列中的所有任务，所有微任务执行完毕后，再去执行下一个宏任务。
## 用途
### 处理DOM事件回调
在浏览器里，每当一个事件发生并且有一个事件监听器绑定在该事件上时，一个消息就会被添加进消息队列。如果没有事件监听器，这个事件将会丢失。所以当一个带有点击事件处理器的元素被点击时，就会像其他事件一样产生一个类似的消息。
### 处理 setTimeout 等
函数 setTimeout 接受两个参数：待加入队列的消息和一个时间值（可选，默认为 0）。这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。
## 优缺点
### 优点
每一个消息完整地执行后，其它消息才会被执行。这为程序的分析提供了一些优秀的特性，包括: 当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。
### 缺点
这个模型的一个缺点在于当一个消息需要`太长时间`才能处理完毕时，Web应用程序就`无法处理与用户的交互`，例如点击或滚动。为了缓解这个问题，一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。
## 扩展
### 浏览器一帧中执行 JS 的全部时机
一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback
### 做事件循环题的技巧
写三个队列
同: 同1, 同2, 同3
宏: 宏1, 宏2, 宏3
微: 微1, 微2, 微3
按代码顺序填三个队列，按事件循环机制出队入队。

## fscrollTop
获取或设置一个元素的内容垂直滚动的像素数。
scrollTop = `内容顶` 到 `内容可见顶` 的距离。
### 例子
不可见      内容顶
不可见
不可见
不可见
不可见      
不可见  -----------------------
可见        内容可见顶
可见        
可见        
....


# ftarget vs fcurrentTarget
target 是触发事件的元素 (li)
currentTarget 是监听事件的元素 (ul)
当采用事件委托时，ul监听点击事件，li触发点击事件，此时 ul 收到的 e 中，e.target 是 li, e.currentTarget 是 ul。


# frequestAnimationFrame frequestIdleCallback
## 区别
requestAnimationFrame  在浏览器一帧中重绘之前执行回调      (cancelAnimationFrame(返回的ID), 取消回调)
requestIdleCallback    在浏览器一帧中有空闲时间时执行回调   (cancelIdleCallback(返回的ID), 取消回调)
**浏览器一帧执行的任务**
一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback

## frequestAnimationFrame
requestAnimationFrame  接收一个回调函数，浏览器会在下次重绘之前调用回调函数，通常用来更新动画。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数与浏览器屏幕刷新次数相匹配，requestAnimationFrame 运行在后台标签页时会被暂停，以提升性能和电池寿命。
## 用途
执行动画
## 优点
- **CPU 节能**  [关闭标签时停止刷新]
使用 setTinterval 实现的动画，当页面被隐藏或最小化时，setTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费 CPU 资源。而 RequestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的 RequestAnimationFrame 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。
- **函数节流**   [一帧只执行一次]
在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame 可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每 16.7ms 刷新一次，多次绘制并不会在屏幕上体现出来。
- **减少 DOM 操作**  [一次完成DOM操作]
requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒 60 帧。

## frequestIdleCallback
requestIdleCallback  接收一个回调函数，浏览器会在一帧的空闲时期调用这个回调函数。
### 用途
这使开发者能够在主事件循环上执行低优先级任务。
### 代码
```js
function runTaskQueue(deadline) {
  // ...
  if (taskList.length) {
    requestIdleCallback(runTaskQueue, { timeout: 1000} );
  }
}
```

# f缓存
缓存分为`强缓存`和`协商缓存`。

强缓存是指: 浏览器在请求资源前，先比较`当前时间`和`缓存的过期时间`, 如果缓存没有过期，则不需要向服务器发起请求，直接使用缓存，返回200。
浏览器检查缓存是否过期有两种方式:
一种是使用`Cache-Control`头字段的`max-age` 属性检查`相对时间`,
另外一种是，如果浏览器不支持HTTP/1.1，则使用`Expires`头字段检查`绝对时间`。

协商缓存是指: 没有命中强缓存，浏览器向服务器发送带有`If-None-Match`或`If-Modified-Since`头字段的请求。
- 服务器收到以后，优先对比`Etag`和`If-None-Math`判断被请求的文件是否改变，如果两者一致则没有改变，返回304, 如果不一致则说明文件已被改动，返回新的资源和新的`Etag`，状态码200。
- 如果没有`If-None-Match`，则对比`If-Modified-Since`和`Last-Modified`，如果一致则资源没有改变，返回304，如果不一致，返回新的资源和`Last-Modified`，状态码200。

## 流程
- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较`当前时间`与上一次返回 200 时的`时间差`，如果没有超过`Cache-Control`设置的`max-age`(相对过期时间)则没有过期，并命中`强缓存`，直接`从本地读取资源`。如果浏览器不支持HTTP1.1，则使用`Expires`头(一个绝对时间)判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

## 怎么设置强缓存  (不需要请求，直接200)
强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。
### Expires
服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。
### Cache-Control
Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，`Cache-Control`可设置的字段：
- `public`：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age=来精确控制；
- `private`：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
- `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
- `max-age=`：设置缓存的最大有效期，单位为秒；
- `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；
- `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。
一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。

## 怎么设置协商缓存  (需要请求，返回304就使用缓存)
协商缓存也可以通过两种方式来设置，分别是 http 头信息中的`Last-Modified`和`Etag`属性。
#### Last-Modified
服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 `If-Modified-Since` 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。
#### Etag
（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 `If-None-Match` 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。
当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。
### 总结
强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

#### no-cache和no-store很容易混淆
- no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
- no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。
#### 流程结构
1. 无缓存
向服务器发起请求;
2. 有缓存
在有缓存的情况下，检查缓存是否过期;
  * 没有过期  (强缓存)
  读取本地缓存，返回;
  * 已经过期  (协商缓存)
  查看缓存的头部中是否有 E-tag;
    * 有 E-tag
    发起 HTTP 请求，头部中携带 If-None-Match，返回304则使用缓存，返回200则用新的数据同时更新 E-tag;
    * 没有 E-tag
    检查是否有 Last-Modified
      * 有
      发起 HTTP 请求，头部中携带 If-Modified-Since，返回304则使用缓存，返回200则用新的数据同时更新Last-Modified;
      * 没有
      发起 HTTP 请求，返回响应，缓存协商。


# f缓存的位置
资源缓存的位置一共有 3 种，按优先级从高到低分别是: Service Worker, Memory Cache, Disk Cache。
## Service Worker
Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们`自由控制`缓存哪些文件、如何匹配缓存、如何读取缓存，并且`缓存是持续性的`。当 Service Worker 没有命中缓存的时候，需要去调用 `fetch` 函数获取 数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。
## Memory Cache
Memory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
## Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache`胜在容量和存储时效性上`。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。
  ### Disk Cache 的 Push Cache (这个可以不说)
  Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：
  - 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
  - 可以推送 `no-cache` 和 `no-store` 的资源
  - 一旦连接被关闭，Push Cache 就被释放
  - 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
  - Push Cache 中的缓存只能被使用一次
  - 浏览器可以拒绝接受已经存在的资源推送
  - 可以给其他域名推送资源

# fService Worker
## 1.讲概念
1. Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能（一般称之为 Offline First）。这是原生APP 本来就支持的功能，这也是相比于 web app，原生 app 更受青睐的主要原因。
2. 你的 service worker 函数像一个代理服务器一样，允许你修改请求和响应，用他们的缓存替代它们等等。
3. 你需要通过 HTTPS 来访问你的页面 — 出于安全原因，Service Workers 要求必须在 HTTPS 下才能运行。为了便于本地开发，localhost 也被浏览器认为是安全源。
## 2.如何使用
通常遵循以下基本步骤来使用 service workers：
1. service worker URL 通过 serviceWorkerContainer.register() 来获取和注册。
2. 如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 worker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。
3. service worker 现在可以处理事件了。
4. 受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件(在这个事件里可以开始进行填充 IndexDB和缓存站点资源)。这个流程同原生 APP 或者 Firefox OS APP 是一样的 — 让所有资源可离线访问。
5. 当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。
6. 下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。 onactivate 主要用途是清理先前版本的 service worker 脚本中使用的资源。
7. Service Worker 现在可以控制页面了，但仅是在 register()  成功后的打开的页面。也就是说，页面起始于有没有 service worker ，且在页面的接下来生命周期内维持这个状态。所以，页面不得不重新加载以让 service worker 获得完全的控制。
## 3.例子
### 3-1. 注册
```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw-test/sw.js', { scope: '/sw-test/' }).then(function(reg) {
    // registration worked
    console.log('Registration succeeded. Scope is ' + reg.scope);
  }).catch(function(error) {
    // registration failed
    console.log('Registration failed with ' + error);
  });
}
```
1. 外面的代码块做了一个特性检查，在注册之前确保 service worker 是支持的。
2. 接着，我们使用 ServiceWorkerContainer.register() 函数来注册站点的 service worker，service worker 只是一个驻留在我们的 app 内的一个 JavaScript 文件 (注意，这个文件的url 是相对于 origin， 而不是相对于引用它的那个 JS 文件)。
3. scope 参数是选填的，可以被用来指定你想让 service worker 控制的内容的子目录。在这个例子里，我们指定了 '/sw-test/'，表示 app 的 origin 下的所有内容。如果你留空的话，默认值也是这个值， 我们在指定只是作为例子。
4. .then() 函数链式调用我们的 promise，当 promise resolve 的时候，里面的代码就会执行。
5. 最后面我们链了一个 .catch() 函数，当 promise rejected 才会执行。

这就注册了一个 service worker，它工作在 worker context，所以没有访问 DOM 的权限。在正常的页面之外运行 service worker 的代码来控制它们的加载。
单个 service worker 可以控制很多页面。每个你的 scope 里的页面加载完的时候，安装在页面的 service worker 可以控制它。牢记你需要小心 service worker 脚本里的全局变量： 每个页面不会有自己独有的worker。
关于 service workers 一个很棒的事情就是，如果你用像上面一样的浏览器特性检测方式检测发现浏览器并不支持SW，你还是可以正常地在线使用页面。与此同时，如果你在一个页面上同时使用 AppCache 和 SW , 不支持 SW 但是支持 AppCache  的浏览器，可以使用 AppCache，如果都支持的话，则会采用 SW。

### 3-2. 安装和激活：填充你的缓存
在你的 service worker 注册之后，浏览器会尝试为你的页面或站点安装并激活它。 
install 事件会在注册完成之后触发。install 事件一般是被用来填充你的浏览器的离线缓存能力。为了达成这个目的，我们使用了 Service Worker 的新的标志性的存储 API — cache — 一个 service worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是特定你的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。
```js
this.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open('v1').then(function(cache) {
      return cache.addAll([
        '/sw-test/',
        '/sw-test/index.html',
        '/sw-test/style.css',
        '/sw-test/app.js',
        '/sw-test/image-list.js',
        '/sw-test/star-wars-logo.jpg',
        '/sw-test/gallery/',
        '/sw-test/gallery/bountyHunters.jpg',
        '/sw-test/gallery/myLittleVader.jpg',
        '/sw-test/gallery/snowTroopers.jpg'
      ]);
    })
  );
});
```
1. 这里我们 新增了一个 install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()  方法——这会确保Service Worker 不会在 waitUntil() 里面的代码执行完毕之前安装完成。
2. 在 waitUntil() 内，我们使用了 caches.open() 方法来创建了一个叫做 v1 的新的缓存，将会是我们的站点资源缓存的第一个版本。它返回了一个创建缓存的 promise，当它 resolved 的时候，我们接着会调用在创建的缓存示例上的一个方法  addAll()，这个方法的参数是一个由一组相对于 origin 的 URL 组成的数组，这些 URL 就是你想缓存的资源的列表。
3. 如果 promise 被 rejected，安装就会失败，这个 worker 不会做任何事情。这也是可以的，因为你可以修复你的代码，在下次注册发生的时候，又可以进行尝试。
4. 当安装成功完成之后， service worker 就会激活。在第一次你的 service worker 注册／激活时，这并不会有什么不同。但是当  service worker 更新 (稍后查看 更新你的 service worker 部分) 的时候 ，就不太一样了。

### 3-3. 自定义请求的响应
现在你已经将你的站点资源缓存了，你需要告诉 service worker 让它用这些缓存内容来做点什么。有了 fetch 事件，这是很容易做到的。

每次任何被 service worker 控制的资源被请求到时，都会触发 fetch 事件，这些资源包括了指定的 scope 内的文档，和这些文档内引用的其他任何资源（比如 index.html 发起了一个跨域的请求来嵌入一个图片，这个也会通过 service worker 。）

你可以给 service worker 添加一个 fetch 的事件监听器，接着调用 event 上的 respondWith() 方法来劫持我们的 HTTP 响应，然后你用可以用自己的方法来更新他们。

下面的例子是: 在任何情况下我们只是简单的响应这些缓存中的 url  和网络请求匹配的资源。
```js
this.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request)
  );
});
```
caches.match(event.request) 允许我们对网络请求的资源和 cache 里可获取的资源进行匹配，查看是否缓存中有相应的资源。这个匹配通过 url 和 vary header进行，就像正常的 http 请求一样。

在响应时可以有更多的选项:
1. 你可以在你的响应里选择性的传一系列 header，来模仿标准的 HTTP 响应 header。这里我们只告诉浏览器我们虚假的响应的 content type：
```js
new Response('<p>Hello from your friendly neighbourhood service worker!</p>', {
  headers: { 'Content-Type': 'text/html' }
})
```
2. 如果没有在缓存中找到匹配的资源，你可以告诉浏览器对着资源直接去 fetch 默认的网络请求:
```js
fetch(event.request)
```
3. 如果没有在缓存中找到匹配的资源，同时网络也不可用，你可以用 match() 把一些回退的页面作为响应来匹配这些资源，比如：
```js
caches.match('/fallback.html');
```
4. 你可以通过 FetchEvent 返回的 Request 对象检索到非常多有关请求的信息：
```js
event.request.url
event.request.method
event.request.headers
event.request.body
```

# fCookie
Cookie 是服务器发送到浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器发起请求时被自动携带。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。

Cookie是最早被提出来的本地存储方式，因当时并没有其它合适的存储办法而作为唯一的存储手段。但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 localStorage 或 sessionStorage。

## 用途
- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为跟踪（如跟踪分析用户行为等）

## HTTP报文设置Cookie
在响应头字段中加 Set-Cookie 字段，值是key=value形式的数据，后面跟上本条Cookie的属性。
如果有多对key,value要发送，应该再加多条 Set-Cookie 字段。
**例子**
Set-Cookie: Username=Ronny; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly; SameSite=Strict
Set-Cookie: age=26; HttpOnly

## HTTP报文携带Cookie
在请求头字段中加 Cookie 字段，值是`很多对key=value`的形式，用`分号+空格`分隔。
**例子**
Cookie: Username=Ronny; age=26;   // 注意这里不会有Cookie的属性!

## Cookie 有哪些属性
* Expires/Max-Age:  定义 Cookie 的有效期，Expires是绝对时间，Max-Age是相对时间。
* Secure:  该 Cookie 只能被 HTTPS 协议加密的请求发送给服务端。
* HttpOnly:  禁止 JavaScript 的 document.cookie API 访问本 Cookie，有效防止 XSS 攻击。
* Domain:  允许 Cookie 可以被发送给哪些域名
* Path:  允许 Cookie 可以被发送给哪些路径
* SameSite: 定义 cookie 在跨站请求时能不能被携带，它有三个属性: Strict, Lax, None。 Strict是完全禁止，Lax是某些情况可以带Cookie，None是任何跨站请求都可以带Cookie。 设置 SameSite 为 Strict/Lax 可以有效防止跨站请求伪造攻击（CSRF）。

## document.cookie 读写 cookie
- 读 cookie  
通过 document.cookie 得到一个字符串, 该字符串包含所有的 Cookie，每条 cookie 是一个 key=value 的键值对，以"分号和空格"分隔。
```js
console.log(document.cookie);  // PSTM=1647573278; BIDUPSID=F4B61F03E84F1F02E107963880EE607D; 
```
- 写 cookie
通过给 document.cookie 赋值来改变 cookie，赋的值是一个键值对形式的字符串。需要注意的是，用这个方法一次只能对一个 cookie 进行设置或更新，字符串后面可以加上属性配置。
**例子**
document.cookie = "cookieKey1=newValue1; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/";
document.cookie = "cookieKey2=newValue2; path=/; max-age=3600";


## fCookie可以跨域吗？
可以。服务器设置 Set-Cookie: SameSite=None。SameSite 可以控制 Cookie 在跨站请求时是否被发送。
SameSite 有三种值:
1. Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。比如你从 A域 访问 B域 的资源，而 A域 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 B域 的服务器上的。只有你从 A域 的站点去请求 A域 的资源时，才会带上这些 Cookie。
2. Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
3. 使用 None 的话，在任何情况下都会发送 Cookie 数据。
以前，如果 SameSite 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 None，Cookies 会被包含在任何请求中——包括跨站请求。
大多数主流浏览器正在将 SameSite 的默认值迁移至 Lax。如果想要指定 Cookies 在同站、跨站请求都被发送，现在需要明确指定 SameSite 为 None。

# flocalStorage vs fsessionStorage
## 共同点
1. 跨域的标签页之间，无论 localStorage 还是 SessionStorage， 都是不能共享数据的。
2. API:
  - key(n): 该方法接受一个数值 n 作为参数，并返回存储中的第 n 个键名。
  - getItem(k): 该方法接受一个键名作为参数，返回键名对应的值。
  - setItem(k,v): 把`键值对`添加到存储中，如果键名存在，则更新其对应的值。
  - removeItem(k): 把该键名对应的`键值对`从存储中删除。
  - clear(): 清空存储中的所有键名。
## 不同点
1. 存储在 localStorage 的数据可以长期保留；而对 sessionStorage 来说，当页面会话结束 —— 也就是说，当页面被关闭时，存储在 sessionStorage 的数据会被清除。
2. 同源的标签页, localStorage 可以共享数据，而 sessionStorage 不行。

# flocalStorage
1. `localStorage`为每一个给定的源维持一个独立的存储区域。
2. `localStorage` 中的键值对总是以字符串的形式存储。
3. 在浏览器关闭，然后重新打开，`localStorage`数据仍然存在。

# fsessionStorage
sessionStorage 属性允许你访问一个，对应当前源的 session Storage 对象。
## 用途
1. 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。
2. 在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同。
3. 打开多个标签页面，会创建各自的 sessionStorage。
4. 关闭对应浏览器标签或窗口，会清除对应的 sessionStorage。 


# f跨域资源共享
`跨源资源共享`是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它 origin（域，协议和端口），使得浏览器允许这些 origin 访问加载自己的资源。

跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的`预检请求`。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。

跨源资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME类型 的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。

## f简单请求
某些请求不会触发`CORS预检请求`，这样的请求被称为`简单请求`，`简单请求`应满足下列`所有条件`:
1. GET、HEAD、POST
2. 头部字段有范围限制，不能是`被用户代理自动设置`的字段，还有`fetch`规范定义的禁用字段
3. Content-Type 只能是 `text/plain`, `multipart/form-data`, `application/x-www-form-urlencode`

## f预检请求 (复杂请求)
## 1.讲概念
`预检请求`用于获取目的资源所`支持`的`通信选项`，一般用于检查服务器是否支持 CORS 即`跨域资源共享`。

它使用 HTTP 请求的`OPTIONS`方法，在`Headers`中携带 `Access-Control-Request-Method`, `Access-Control-Request-Headers`，以及一个`Origin`字段。

当有必要的时候，浏览器会`自动`发出一个预检请求；所以在正常情况下，前端开发者不需要自己去发这样的请求。

在对 `预检请求(OPTIONS)` 的应答中，`服务器`明确了`客户端`所要访问的资源允许使用的`源、方法、头部字段`等。
Access-Control-Allow-Origin 源
Access-Control-Allow-Methods 方法
Access-Control-Allow-Headers 头部字段
如果请求不满足 Acces-Control-Allow-*，响应报文将被浏览器拦截，并向页面抛出`CORS请求失败`的错误。

## 2.f干掉预检请求  (预检请求消耗了一定的性能，可能会影响用户体验)
1. 把`复杂请求`改为`简单请求`。
* 请求方法限制在 `GET`, `HEAD`, `POST`
* 去掉冗余的 `Headers`
* POST 的 body 改为 `text/plain` 等
2. 设置`Access-Control-Max-Age`，单位是秒
### Access-Control-Max-Age
The Access-Control-Max-Age 这个响应头表示`预检请求`的返回结果（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息） 可以被缓存多久。也就是告诉浏览器，在缓存期内，不要发出同样的预检请求。
#### 遇到的坑
Access-Control-Max-Age 必须写纯数字的字符串，后端用 java 很容易写出 long 类型的如 "18000L" 的值，这种浏览器是不识别的，应该改为 "18000"。
#### <delta-seconds>
返回结果可以被缓存的最长时间（秒）。
在 Firefox 中，上限是24小时 （即 86400 秒）。
在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。
从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。
Chromium 同时规定了一个默认值 5 秒。
如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。


# fHTTPS
HTTPS`(安全的HTTP)`是 HTTP 协议的加密版本。它通常使用`SSL`或者`TLS`来加密客户端和服务器之间所有的通信 。这安全的链接允许客户端与服务器安全地交换敏感的数据，例如网上银行或者在线商城等涉及金钱的操作。
TLS: Transport Layer Security，传输层安全协议，由 SSL 发展而来。
## f加密过程
`TLS1.2握手`的`握手过程`是: 

1. 客户端生成一个`随机数`，然后把 `这个随机数` 和 一个 `密码套件列表` 发送给服务端; (密码套件: ECDHE密钥交换+RSA计算公私钥+AES128对称加密+GCM分组模式+SHA256摘要算法)
2. 服务端也生成一个随机数，然后从`密码套机列表`中选择一个 `密码套件`, 然后根据里面的算法，生成公私钥, 将 随机数、`密码套件`, `公钥` 和 `证书` 一起发给 客户端;
3. 客户端验证 `证书`, 通过后根据收到的`密码套件`计算自己的`公私钥`，然后把`自己的公钥`发给`服务器`，
接下来，用`服务器公钥`、`自己的私钥`、`服务端的随机数`、`客户端的随机数`，生成`对称密钥`。
(
  客户端拿到证书后如何证实? 
    证书里有 `服务器信息+公钥+CA机构签名的摘要`，CA机构的公钥内置于浏览器中，
    第一步, 客户端取出`CA公钥`解密CA签名得到一份`摘要`，这份摘要是CA机构把`服务器信息`通过`公开的哈希算法`计算得到的。
    第二部, 客户端将`服务器信息`通过`同样的哈希算法`也得到一份摘要，对比两份摘要，如果一致，说明`服务端信息`确实`去CA认证过`，也就说明证书有效。
)
4. 服务端收到`客户端的公钥`，加上`自己的私钥`，再加上两端的随机数，生成`对称密钥`。
5. 由于两端用的是同一套算法，所以生成的`对称密钥`是相同的，且在握手的过程中，只有`公钥`会发布出去，`私钥`是保密的，所以最终生成的`对称密钥`是安全的，接下来就用这把生成的`对称密钥`进行`对称加密`通信。

## f对称加密
对称加密是指`加密`和`解密`都使用的是`相同的密钥`，目前常见的对称加密算法有 AES128/ AES256 对称加密算法。对称加密的最早的一个原理就是`异或`运算的性质: 比如一串数字作为原文，另一串数字作为密钥，原文和密钥`异或`一次，得到密文。这串密文再和刚才的密钥`异或`一次，又可以解出`原文`。

## f非对称加密
和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。
在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。

### 新浪的 TLSv1.2 握手过程
1. 客户端发送随机数C，以及它支持的密码套件列表
随机数 C 用于帮助对方产生最终的对称密钥 master_secret=f(随机数C,随机数S,pre_master)
client hello    				随机数C, 密码套件列表

2. 服务端发送随机数S, 帮助对方产生最终的对称密钥
服务端选择一个密码套件:
ECDHE密钥交换 + RSA计算公私钥 + AES128对称加密 + GCM分组模式 + SHA256摘要算法
server hello    		 	  随机数S, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
3. 服务器发送CA签名的证书，用于证实服务器身份
客户端拿到证书后如何证实? 
    证书里有"服务器信息+公钥+CA签名的摘要"，CA公钥内置于浏览器中，客户端取出公钥解密CA签名，
 得到一份摘要，将"服务器信息"通过哈希也得到一份摘要，对比，如果两份摘要一致，则说明确实是CA
 加密的，也就说明这份证书确实是CA认证的。
server certificate			certificate(证书)

4. 由于选择了ECDHE，所以服务端要 生成私钥Kb、计算公钥Qb=Kb.P，然后发送"椭圆曲线,P,Qb"
为啥还要发送签名？
	这里的签名是服务器自己的私钥签名，以证明这条数据是服务器发的，因为包含"公钥"这样敏感
的数据，加上签名防止 hacker 假冒，是很有必要的。
server key exchange			server params(曲线, 公钥, 签名)
server hello done				参数传递结束，等待对方公钥

5. 收到证书，验证证书
收到 "椭圆曲线,P,Qb"，生成私钥Ka，计算公钥Qa=Ka.P, 然后发送Qa
根据ECDHE，可以生成pre_master了:
		Qb.Ka = (X,Y)
其中 X 就是 pre_master
计算最终的会话密钥: master_secret=f(随机数C,随机数S,pre-master)
client key exchange			client params(公钥Qa)

6. 服务端收到 Qa，也生成 pre_master: Qa.Kb = (X,Y), 其中 X 就是 pre_master
服务端也计算最终的会话密钥: master_secret = f(随机数C,随机数S,pre-master)，计算结果与 client 相同

7. 经过`TLS`握手, 双方得到`完全相同`的会话密钥，下面进行`AES 对称加密通信`;


# f状态码 fStatus Code
1. 信息响应  100~199
2. 成功响应  200~299
3. 重定向响应  300~399
4. 客户端错误响应 400~499
5. 服务端错误响应 500~599

## f100 Continue
这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。

## f101 Switching Protocols
该代码是响应客户端的`Upgrade`请求头发送的, 指明服务器即将切换的协议。
例子: (使用`WebSockets`时切换协议)
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade

## f201 Created
该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。

## f202 Accepted
请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。

## f203 Non-Authoritative Information
服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回`200 OK`的情况下才是合适的。

## f204 No Content
服务器成功处理了请求，但不需要返回任何`实体内容`(Body)。
响应可能通过`实体头部`的形式，返回新的或更新后的`元信息`。如果存在这些头部信息，则应当与所请求的变量相呼应。
如果客户端是`浏览器`的话，那么用户浏览器应`保留发送了该请求的页面`，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。
由于`204`响应被`禁止包含任何消息体`，因此它始终以消息头后的`第一个空行结尾`。

## f205 Reset Content
告诉用户代理重置发送此请求的文档。

## f206 Partial Content
当从客户端发送`Range`范围标头以只请求资源的一部分时，将使用此响应代码。
如果只包含一个数据区间，那么整个响应的 Content-Type 首部的值为所请求的文件的类型，同时包含  Content-Range 首部。
如果包含多个数据区间，那么整个响应的  Content-Type  首部的值为 multipart/byteranges ，其中一个片段对应一个数据区间，并提供  Content-Range 和 Content-Type  描述信息。

## f301 Moved Permanently
`永久重定向` 说明请求的资源已经被移动到了由`Location`头部指定的`url`上，是固定的不会再改变。搜索引擎会根据该响应修正。
尽管标准要求浏览器在收到该响应并进行重定向时不应该修改 http method 和 body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用 301，其他情况使用 `308` 来替代 `301`。

# f302 Found
`临时重定向` 表明请求的资源被`暂时`的移动到了由该 HTTP 响应的响应头`Location`指定的`URL`上。
浏览器会重定向到这个`URL`，但是`搜索引擎`不会对该资源的链接进行更新。

# f304 Not Modified
`未改变` 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在请求中附带了头部信息`If-None-Match` 或 `If-Modified-Since`。

# f307 Temporary Redirect
HTTP 307 Temporary Redirect，临时重定向响应状态码，表示请求的资源`暂时地被移动到了`响应的`Location`首部所指向的 URL 上。
原始请求中的请求方法和消息主体会在重定向请求中被重用。在确实需要将重定向请求的方法转换为 GET 的场景下，可以考虑使用 303 See Other 状态码。例如，在使用 PUT 方法进行文件上传操作时，如果需要返回一条确认信息（例如“你已经成功上传了 XYZ”），而不是返回上传的资源本身，就可以使用这个状态码。
## 和 302 的区别  (请求方法不变)
当发送重定向请求的时候，307 状态码可以确保`请求方法和消息主体不会发生变化`。
如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET。也就是说，在 Web 中，如果使用了 GET 以外的请求方法:
* 返回 302 状态码，则重定向后的请求方法是不可预测的；
* 返回 307 状态码，之后的请求方法就是可预测的。
对于 GET 请求来说，两种情况没有区别。

# f308 Permanent Redirect
在 HTTP 协议中， 308 Permanent Redirect（永久重定向）是表示重定向的响应状态码，说明请求的资源已经被永久的移动到了由 Location 首部指定的 URL 上。浏览器会进行重定向，同时搜索引擎也会更新其链接（用 SEO 的行话来说，意思是“链接汁”（link juice）被传递到了新的 URL）。
## 和 301 的区别  (请求方法不变)
在重定向过程中，`请求方法和消息主体`不会发生改变，然而在返回 301 状态码的情况下，请求方法有时候会被客户端错误地修改为 GET 方法。

# f400 Bad Request  (万能客户端错误响应)
HTTP 400 `Bad Request` 响应状态码表示由于`语法无效`，服务器无法理解该请求。 客户端不应该在未经修改的情况下重复此请求。

# f401 Unauthorized
状态码 401 Unauthorized 没有权限，指的是由于`缺乏`目标资源要求的`身份验证凭证`，发送的请求未得到满足。比如没有 token。

# f403 Forbidden
状态码 403 Forbidden 代表客户端有携带凭证，但是该凭证没有权限访问本接口, 比如用户分普通用户和管理员，普通用户的token不能访问需要管理员权限的某些接口。

# f404 Not Found
状态码 404 Not Found 代表客户端错误，指的是服务器端无法找到所请求的资源。
返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理 (link rot) 页面。
404 状态码并不能说明请求的资源是`临时`还是`永久丢失`。如果服务器知道该资源是永久丢失，那么应该返回 410 (Gone) 而不是 404 。

# fHTTP2
HTTP/2.0 的核心是`提高性能`

## 特点
1. 在`语义`上兼容 HTTP/1
HTTP2 保留了请求方法、URI、状态码等概念，而且同样在 URI 中用 http 作为明文协议，https 作为加密协议。
这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。

2. f头部压缩
http2 使用 HPACK 算法来压缩头部数据。HPACK 算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”，压缩和解压缩就是查表和更新表的操作。
### f伪头字段
http2 为了方便管理和压缩，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，称呼为`伪头字段`。这些 `伪头字段`会在名字前加一个`:`，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。
### f静态表
HTTP/2 就为一些最常用的头字段定义了一个只读的“静态表”，比如数字`2`代表`:method: GET`，数字`8`代表`:status: 200`。
### f动态表
如果静态表里没有的，就要用到“动态表”，它添加在静态表后面，结构相同，但会在编码解码的时候随时更新。
比如说，第一次发送请求时的`user-agent`字段长是一百多个字节，发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号`65`。那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。
### 现象
随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。

3. f流与多路复用
`流`是`二进制帧`的`双向传输序列`。
### 特点
* 流是可并发的，一个 HTTP/2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；
* 客户端和服务器都可以创建流，双方互不干扰；
* 流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；
* 流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；
* 流可以设置优先级，让服务器优先处理，比如先传 HTML/CSS，后传图片，优化用户体验；
* 流 ID 不能重用，只能顺序递增，客户端发起的 ID 是奇数，服务器端发起的 ID 是偶数；
* 在流上发送“RST_STREAM”帧可以随时终止流，取消接收或发送；
* 第 0 号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制。
### 复用 tcp 连接
比如说，HTTP/2 在一个连接上使用多个流收发数据，那么它本身默认就会是长连接，所以永远不需要“Connection”头字段（keepalive 或 close）。
又比如，下载大文件的时候想取消接收，在 HTTP/1 里只能断开 TCP 连接重新“三次握手”，成本很高，而在 HTTP/2 里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持。
ID 用完了该怎么办呢？这个时候可以再发一个控制帧“GOAWAY”，真正关闭 TCP 连接。

4. f强化安全
HTTP/2 增强了安全性，要求下层的通信协议至少是`TLS1.2`，而且禁用了很多不安全的密码套件，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”。
HTTP/2 要求必须实现的密码套件是 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256，比 TLSv1.2 默认的套件安全强度高了很多。

5. 使用二进制帧
Frame Header(9 Bytes) + Frame Payload
## 帧头
HTTP/2 的帧头很小，只有 9 字节，非常地节省（可以对比一下 TCP 头，它最少是 20 个字节）。
### 帧长度 3Byte
帧开头是 3 个字节的长度（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。
### 帧类型 1Byte
长度后面的一个字节是帧类型，大致可以分成数据帧和控制帧两类，HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。
### 帧标志 1Byte
第 5 个字节是非常重要的帧标志信息，可以保存 8 个标志位，携带简单的控制信息。
常用的标志位有:
* `END_HEADERS`表示`头数据结束`，相当于 HTTP/1 里头后的空行（“\r\n”），
* `END_STREAM` 表示 `单方向数据发送结束`（即 EOS，End of Stream），相当于 HTTP/1 里 Chunked 分块结束标志（“0\r\n\r\n”）。
### 流ID
报文头里最后 4 个字节是流标识符，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。
流标识符虽然有 4 个字节，但最高位被保留不用，所以只有 31 位可以使用，也就是说，流标识符的上限是 2^31，大约是 21 亿。


# fHTTP3 
## f队头阻塞 -- tcp固有的问题
举个例子，客户端用 TCP 发送了三个包，但服务器所在的操作系统只收到了后两个包，第一个包丢了。那么内核里的 TCP 协议栈就只能把已经收到的包暂存起来，“停下”等着客户端重传那个丢失的包，这样就又出现了“队头阻塞”。由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。

Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。

HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。


# fXSS  盗取cookie (正常网页中的恶意脚本)
黑客往 HTML 文件中或者 DOM 中注入恶意脚本，当用户加载页面时，恶意脚本执行，对用户实施攻击。

## fXSS防御
有三种方法防御XSS:
1. 服务器对输入脚本进行过滤或转码;
2. 服务返回`Content-Security-Policy`HTTP头部设置内容安全策略;
3. 服务返回 Cookie 时加上 HttpOnly 属性;

### 1. 服务器对输入脚本进行过滤或转码
不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行`转码`，比如最典型的：
`code:<script>alert('你被xss攻击了')</script>`
转码后:
`code:&lt;script&gt;alert(&#39;你被xss攻击了&#39;)&lt;/script&gt;`
经过转码之后的内容，如`<script>标签被转换为&lt;script&gt;`，因此即使这段脚本返回给页面，页面也不会执行这段脚本。
### 2. 服务返回`Content-Security-Policy`HTTP头部设置内容安全策略
实施严格的 CSP 可以有效地防范 XSS 攻击:
1. 限制script脚本能够加载的域名，具体做法是设置 Content-Security-Policy: script-src canUseDomain。
2. 禁止向第三方域提交数据，这样用户数据也不会外泄，具体做法是设置 Content-Security-Policy: form-action canUseURL。
### 3. 服务返回 Cookie 时加上 HttpOnly 属性;
服务器在 HTTP 响应报文的头部字段中设置 `Set-Cookie: Username=Ronny; HttpOnly`
使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 document.cookie 来读取这段 Cookie。这样即使页面被注入了恶意 JavaScript 脚本，也无法获取到Cookie。

## 说原理
XSS靠的是往页面注入恶意脚本来实现攻击。通常情况下，主要有`存储型XSS`、`反射型XSS` 和 `基于DOM的XSS` 三种方式来注入恶意脚本。
### 存储型XSS  恶意专辑名
1. 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
2. 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
3. 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。
#### 案例
2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，比如
`<script>...attack.js....</script>`。当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段恶意脚本就会在用户的页面里执行，恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器。黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号，并利用用户账号进行一些恶意操作。
### 反射型XSS  恶意query
在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。
#### 案例
`http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>`
通过这个操作，我们会发现用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，黑客经常会通过 QQ 群或者邮件等渠道诱导用户去点击这些恶意链接，所以对于一些链接我们一定要慎之又慎。
### DOM型XSS  网络中修改页面
基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。
### 危害
1. 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
2. 可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
3. 可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
4. 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。


# fCSRF 陌生链接不要随便点 (恶意网站利用cookie等登录状态)
黑客引诱用户打开黑客的网站，浏览器执行黑客网站的恶意脚本时，恶意脚本利用用户的登录状态，如 Cookie 发起跨站请求，比如请求银行的转账接口，那如果没有防御措施，因为请求携带了Cookie，该接口会认为是一次正常的转账请求，于是用户的钱就被转走了，达到攻击的目的。

## fCSRF防御
有三种方法:
1. 验证 refer 或 origin;
2. 使用 token;
3. 启用 Cookie 的 SameSite=Strict;
### 1.验证 frefer 或 forigin
服务可以检查`HTTP请求报文`中的 refer 或 orgin 字段，如果不是同源的请求，就不予处理。
* Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，也就是 URL。 (https://time.geekbang.org/column/intro/216)
* Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。 (https://time.geekbang.org)
因此，服务器的可以优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。
### 2. 使用 token
在登录成功后给用户返回一个 token，下次用户请求时需要携带这个 token 才能通过验证，黑客的站点没有 token，自然没有权限调用接口。
### 3. 设置 Cookie 的 SameSite 属性。
比如在 HTTP 响应报文的头部字段中设置 `Set-Cookie: key=value; SameSite=Strict`, 那么浏览器会完全禁止第三方 Cookie。
如果你从`黑客的页面`中访问`银行接口`的资源，而 `银行` 的 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 `银行服务器` 上的。只有你从 `银行域名的站点` 去请求 `银行接口` 时，才会带上这些 Cookie。

SameSite 选项通常有 `Strict`、`Lax` 和 `None` 三个值。Strict 最为严格。
* 如果 SameSite 的值是 `Strict`，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从`黑客的页面`中访问`公司服务器`的资源，而 `公司服务器` 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 `公司的服务器` 上的。只有你从 `公司同个域名的站点` 去请求 `公司的资源` 时，才会带上这些 Cookie。
* Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。
* 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

## 说原理
三种方式发起 CSRF:
### 1. 自动发起 Get 请求   (关键在`自动`!!!!)
```html
<html>
  <body>
    <h1>黑客的站点：CSRF攻击演示</h1>
    <img src="https://time.geekbang.org/sendcoin?user=hacker&number=100">
  </body>
</html>
```
黑客将转账的请求接口隐藏在 img 标签内，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去了。
### 2. 自动发起 POST 请求
```html
<html>
<body>
  <h1>黑客的站点：CSRF攻击演示</h1>
  <form id='hacker-form' action="https://time.geekbang.org/sendcoin" method=POST>
    <input type="hidden" name="user" value="hacker" />
    <input type="hidden" name="number" value="100" />
  </form>
  <script> document.getElementById('hacker-form').submit(); </script>
</body>
</html>
```
黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。
### 3. 引诱用户点击链接
```html
<div>
  <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg> </img> </div> <div>
  <a href="https://time.geekbang.org/sendcoin?user=hacker&number=100" taget="_blank">
    点击下载美女照片
  </a>
</div>
```
黑客页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户上了。


## fCSRF vs fXSS
两种都利用了用户的登录信息(cookie)，XSS是访问本站=>(送cookie)黑站，CSRF是访问黑站=>(伪造请求)本站。
和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用`服务器的漏洞`和`用户的登录状态`来实施攻击。
XSS 是用户访问正常服务，返回的 html 里夹杂了 hacker 的脚本。
CSRF 是用户访问了 hacker 的服务，返回了恶意脚本。


==============================================fCSS==============================================
# f盒子模型 f盒模型
盒子模型分为 标准盒模型 和 IE盒模型。
**区别**
- 标准盒模型的 width/height 不包括 padding 和 border,
- IE盒模型的 width/height 包括 padding 和 border。
**共同点**
这两种模型由里到外都是 content, padding, border, margin。
**切换**
box-sizing: content-box 是标准盒模型;
box-sizing: border-box  是 IE盒模型;

# f权重 fCSS权重 f优先级 fCSS优先级
CSS优先级由高到低分别是:
1. !important             权重最大            !important 
2. 内联样式                权重1000           style=".."
3. id选择器                权重100            #elementId
4. 类/伪类/属性 选择器       权重10            .classname/:hover/a[title=“eee”]
5. 标签/伪元素 选择器        权重1             div/::before
6. 相邻兄弟/子/后代/通配符    权重0             h1+p, ul>li, li a, \*
注意:
- 如果优先级相同，则最后出现的样式生效；
- 样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式。 

# fposition
1. static     默认值，没有定位。top, right, bottom, left 和 z-index 属性无效。处于正常文档流。
2. fixed      绝对定位。相对于屏幕视口的位置来定位。元素的位置在屏幕滚动时不会改变。移出正常文档流。
3. relative   生成相对定位的元素，相对于其原来的位置进行定位。
4. absolute   绝对定位。相对于最近一个非 static 的父元素定位。
5. sticky     粘性定位。大于 10px 的时候滚动，到达 10px 的时候`粘`住:  `#one { position: sticky; top: 10px; }`
在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。

# fdisplay
1. none             元素不显示，并且会从文档流中移除。
2. block            块类型。默认宽度为父元素宽度，可设置宽高，独占一行。
3. inline           行内元素类型。默认宽度为内容宽度，不可设置宽高，不独占一行。
4. inline-block     默认宽度为内容宽度，可以设置宽高，不独占一行。
5. list-item        像块类型元素一样显示，并添加样式列表标记。
6. table            此元素会作为块级表格来显示。
7. inherit          规定应该从父元素继承 display 属性的值。 

# fdisply:none vs fvisibility:hidden
这两个属性都是让元素隐藏, 不可见, 区别如下:
1. 在渲染树中
- `display:none`会让元素完全从渲染树中消失，渲染时不会占据任何空间；
- `visibility:hidden`不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。
2. 是否是继承属性
- `display:none`是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；
- `visibility:hidden`是继承属性，子孙节点消失是由于继承了`hidden`，通过设置`visibility:visible`可以让子孙节点显示；
3. 是否重排重绘
修改正常文档流中元素的 `display` 会造成文档的重排，修改 `visibility` 属性只会造成本元素的重绘；
4. 读屏器
如果使用读屏器，设置为`display:none`的内容不会被读取，设置为`visibility:hidden`的内容会被读取。

# f隐藏元素 fhidden f隐藏元素的方法有哪些
- display: none：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
- visibility: hidden：元素在页面中仍占据空间，但是不会响应绑定的监听事件。
- opacity: 0：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
- position: absolute：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
- z-index: 负值**：来使其他元素遮盖住该元素，以此来实现隐藏。
- clip/clip-path：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
- transform: scale(0,0)：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。

# CSS3新特性
- 新增各种 CSS 选择器 （`: not(.input)`：所有 class 不是“input”的节点）
- 圆角 （border-radius:8px）
- 多列布局 （multi-column layout）
- 阴影和反射 （Shadoweflect）
- 文字特效 （text-shadow）
- 文字渲染 （Text-decoration）
- 线性渐变 （gradient）
- 旋转 （transform）
- 增加了旋转,缩放,定位,倾斜,动画,多背景

# ftransform
## 为什么有时候⽤ transform:translate 来改变位置⽽不是定位？
translate 是 transform 属性的⼀个值。改变 transform 或 opacity 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform 使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此 translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽ translate 改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。

# fli 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？
浏览器会把 inline 内联元素间的空白字符（空格、换行、Tab 等）渲染成一个空格。为了美观，通常是一个`<li>`放在一行，这导致`<li>`换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。
**解决办法**
1. 为`<li>`设置 float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。
2. 将所有`<li>`写在同一行。不足：代码不美观。
3. 将`<ul>`内的字符尺寸直接设为 0，即 font-size:0。不足：`<ul>`中的其他字符尺寸也被设为 0，需要额外重新设定其他字符尺寸，且在 Safari 浏览器依然会出现空白间隔。
4. 消除`<ul>`的字符间隔 letter-spacing:-8px，不足：这也设置了`<li>`内的字符间隔，因此需要将`<li>`内的字符间隔设为默认 letter-spacing:normal。

# fflex布局 父元素 display:flex  弹性盒模型
flex 布局是 CSS3 新增的一种布局方式，可以通过将一个元素的 display 属性值设置为 flex 从而使它成为一个 flex 容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用 flex-direction 来指定主轴的方向。可以使用 justify-content 来指定元素在主轴上的排列方式，使用 align-items 来指定元素在交叉轴上的排列方式。还可以使用 flex-wrap 来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用 order 属性来指定项目的排列顺序，还可以使用 flex-grow 来指定当排列空间有剩余的时候，项目的放大比例，还可以使用 flex-shrink 来指定当排列空间不足时，项目的缩小比例。

# fBFC  Block Formatting Contex  块级格式化上下文
BFC 是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发 BFC 的条件，则 BFC 中的元素布局不受外部影响。
## f创建BFC:  常用的有 overflow:hidden, display:flow-root;
1. 根元素 `html`
2. 浮动元素（float 值不为 none）
3. 绝对定位元素（position 值为 absolute 或 fixed）
4. 行内块元素（display 值为 inline-block）
5. 表格单元格（display 值为 table-cell，HTML 表格单元格默认值）
6. 表格标题（display 值为 table-caption，HTML 表格标题默认值）
7. 匿名表格单元格元素（display 值为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 inline-table）
8. overflow 值不为 visible、clip 的块元素
9. display 值为 flow-root 的元素
10. contain 值为 layout、content 或 paint 的元素
11. 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
12. 网格元素（display 值为 grid 或 inline-grid 元素的直接子元素），如果它们本身既不是 flex、grid 也不是 table 容器
13. 多列容器（column-count 或 column-width (en-US) 值不为 auto，包括column-count 为 1）
14. column-span 值为 all 的元素始终会创建一个新的 BFC，即使该元素没有包裹在一个多列容器中 (规范变更, Chrome bug)
## 说用途
- **解决 margin 的重叠问题**
由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，给重叠下面的那个元素包裹一个父 BFC，跟上面的元素完全脱离，就解决了 margin 重叠的问题。
- **解决高度塌陷的问题**
在对子元素设置浮动后，父元素会发生高度塌陷。解决这个问题，只需要把父元素变成一个 BFC。因为 BFC 会把浮动子元素的高度计算进去。常用的办法是给父元素设置`overflow:hidden`或`display:flow-root`。
- **创建自适应两栏布局**
可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。

## f高度塌陷
非BFC父元素，不会将浮动子元素的高度计算在内，造成父元素高度比子元素小。
- 解决方法:
把父元素变成一个 BFC。因为 BFC 会把浮动子元素的高度计算进去。常用的办法是给父元素设置`overflow:hidden`或`display:flow-root`。

## fmargin重叠
两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，**浮动的元素和绝对定位**这种脱离文档流的元素的外边距不会折叠。重叠只会出现在**垂直方向**。
- 解决方法:
1. 兄弟重叠
- 底部元素变为行内盒子：`display: inline-block`
- 底部元素设置浮动：`float`
- 底部元素的 position 的值为`absolute/fixed`
2. 父子重叠
- 父元素加入：`overflow: hidden`
- 父元素添加透明边框：`border:1px solid transparent`
- 子元素变为行内盒子：`display: inline-block`
- 子元素加入浮动属性或定位x


# f浮动 f清除浮动
1. 非 IE 浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。
2. 浮动元素是 float 的计算值非 none 的元素。当一个元素浮动之后，它会被移出正常的文档流，然后向左或者向右平移，一直平移直到碰到了所处的容器的边框，或者碰到另外一个浮动的元素。
3. 浮动内容仍然遵循`盒子模型`。
## f浮动危害
- 父元素的高度无法被撑开，影响与父元素同级的元素
- 与浮动元素同级的非浮动元素会跟随其后
- 若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构
## f清除浮动
1. 父元素创建一个BFC
如`display:flow-root`, `overflow:hidden`等, 因为 BFC 元素的高度会把浮动子元素的高度计算进来。
2. 增加末尾元素 `clear:both`
  - 在最后一个浮动元素之后添加一个空的 div 标签，并添加`clear:both`样式。
  - 给父级添加::after伪元素，加上`content:''; display:block; clear:both`。
为什么 clear 可以清除浮动?
clear 使得**元素盒子的边不能和前面的浮动元素相邻**，这样我们定义的块级元素就会渲染到浮动元素下面，把高度撑开。
3. 给父级 div 定义`height`属性。


# f伪类 和 f伪元素 的区别
伪类给元素的特殊状态添加效果, 它是已有元素上添加类别的，不会产生新的元素。如 hover 是鼠标悬停的状态，可以加 color 等效果变化。
伪元素在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。如 ::before 创建一个伪元素作为元素的第一个子元素，通过 content 属性添加内容。

# f伪类  如:hover
伪类选中元素的特殊状态。例如 hover 是选中元素在鼠标悬停时的状态。
伪类连同伪元素一起，他们允许你不仅仅是根据文档 DOM 树中的内容对元素应用样式，而且还允许你根据诸如像导航历史这样的外部因素来应用样式（例如 :visited），同样的，可以根据内容的状态（例如在一些表单元素上的 :checked），或者鼠标的位置（例如 :hover 让你知道是否鼠标在一个元素上悬浮）来应用样式。
## 常用的伪类
:link    匹配所有尚未访问的链接，包括那些已经给定了其他伪类选择器的链接。
:visited 匹配用户已访问过的链接。
:hover   适用于用户使用指示设备虚指一个元素（没有激活它）的情况。
:active  匹配被用户激活的元素。它让页面能在浏览器监测到激活时给出反馈。当用鼠标交互时，它代表的是用户`按下按键`和`松开按键`之间的时间。
:checked 匹配任何处于选中状态的radio, checkbox 或 select元素中的 option。
:focus   匹配获得焦点的元素（如表单输入）。当用户点击或触摸元素或通过键盘的 “tab” 键选择它时会被触发。
:host    匹配包含其内部使用的 CSS 的 shadow DOM 的根元素 - 换句话说，这允许你从其 shadow DOM 中选择一个自定义元素。
:nth-last-of-type(n)  选中倒数第n个type类型的元素, 注意倒数的索引从1开始。
:nth-of-type(n)       指定一个实际参数n，这个参数使用一种模式来匹配哪些元素应该被选中, 如 2n+1奇数, 2n偶数, int代表从1开始的索引。
:root    匹配文档树的根元素。对于 HTML 来说，:root 表示 <html> 元素，除了优先级更高之外，与 html 选择器相同。

# f伪元素  如::before
伪元素创建或选中元素的特定`部分`，如 ::before 创建一个伪元素作为元素的第一个子元素，通过 content 属性添加内容。
如下面这个正方形:
```css
/* 一个紫色的正方形 */
.box::before {
    content: "";
    display: block;
    width: 100px;
    height: 100px;
    background-color: rebeccapurple;
    border: 1px solid black;
} 
```
## 用法
一个选择器中只能使用一个伪元素。伪元素必须紧跟在语句中的简单选择器/基础选择器之后。
按照规范，应该使用双冒号（::）而不是单个冒号（:），以便区分伪类和伪元素。但是，由于旧版本的 W3C 规范并未对此进行特别区分，因此目前绝大多数的浏览器都同时支持使用这两种方式来表示伪元素。
## 常见的伪元素
* ::before  创建一个伪元素，其将成为匹配选中的元素的第一个子元素。常通过 content 属性来为一个元素添加修饰性的内容。此元素默认为行内元素。
* ::after  创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。
* ::selection CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。
* ::first-letter  选中某块级元素第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格）。

# f可替换元素
如 img, iframe, video, audio, embed。
在 CSS 中，可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。简单来说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 <iframe> 元素，可能具有自己的样式表，但它们不会继承父文档的样式。CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。

# f三角形 f画三角形
平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border 属性是梯形组成的。可以利用这一点来画三角形。
- 例子: 一个尖朝上的橙色三角形。
```css
div {
  width: 0;
  height: 0;
  border-top: 100px solid orange;
  border-left: 100px solid transparent;
  border-right: 100px solid transparent;
  border-bottom: 100px solid transparent;
}
```

# f扇形 f画扇形
利用 border 画三角形的特性，加一个 border-radius 属性。
```css
div {
    border: 100px solid transparent;
    width: 0;
    height: 0;
    border-radius: 50%;
    border-top-color: red;
}
```

# f正方形 f画自适应的正方形
1. 宽度用百分比，高度用 vw 的形式，两者同值即可实现宽高相同。
```css
div {
  width: 10%;
  height: 10vw;
  background: tomato;
}
```
2. 利用 padding 百分比是相对于父元素 width 的性质实现。
```css
div {
  width: 20%;
  height: 0;
  padding-top: 20%;
  background: orange;
}
```
3. 利用 margin 百分比是相对于父元素 width 的性质，增加一个伪子元素撑开元素的高度，撑开幅度为元素的宽度。
```css
div {
  width: 30%;
  overflow: hidden;
  background: lightblue;
}
div::after {
  content: '';
  display: block;
  margin-top: 100%;
}
```

# fem vs frem
**共同点**
都是相对长度单位
**区别**
em: 相对于父元素 font-size 的倍数
rem: 相对于根元素, 也就是html的 font-size 的倍数



==============================================fHTML==============================================
# fDOCTYPE
文档类型声明，全称是 document type，告知浏览器用什么文档标准解析这个文档。
## 例子
比如加 html 是让浏览器以 W3C 标准解析文档。
```html
<!DOCTYPE html>
<html>
  ...
</html>
```

# fHTML5 新特性
从 标签、属性、存储、API 四个方面来说:
## 标签
在标签上，新增语义化标签 aside, figure, section, header, footer, nav 等，增加多媒体标签 video 和 audio, 使得样式和结构更加分离。
## 属性
在属性上，增强表单，主要是增强了 input 的 type 属性; meta 增加 charset 属性以设置字符集; script 增加 async 以一步加载脚本。
## 存储
在存储上，增加 localStorage, sessionStorage 和 IndexDB 存储 web 数据。
## API
在 API 上，新增 拖放API, 地理定位, SVG绘图, canvas绘图, Web Worker, WebSocket。

# fmeta
meta 标签用于描述文档的元信息，如网站字符集、响应头、移动设备的视口大小、作者、描述、关键词，它通过键值对的形式来定义信息。常用的属性如 charset, http-equiv, 以及 name-content 形式定义的属性。
## fcharset 字符集
这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与 ASCII 大小写无关（ASCII case-insensitive）的"utf-8"。
```html
<meta charset="UTF-8">
```
## fhttp-equiv HTTP头部(请求+响应)
```html
<!-- 内容安全策略  禁用不安全的内联/动态执行，只允许通过 https 加载这些资源（如图片、字体、脚本等） -->
<meta http-equiv="Content-Security-Policy" content="default-src https:">
<!-- 声明文档的类型 -->
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<!-- 重新载入页面的时间间隔10秒 -->
<meta http-equiv="refresh" content="10">
```
## name-content 对
定义文档的标准元数据，其中 name 作为元数据的名称，content 作为元数据的值。常用的元数据有:
* viewport: 定义视口大小，目前只用于移动设备。
* application-name: 表示网页中运行的应用程序名称。
* author: 文档作者的名字。
* color-scheme: 指定与当前文档兼容的一种或多种配色方案。
* referrer：控制由当前文档发出的请求的 HTTP Referer 请求头。

```html
<!-- 视口宽度为设备宽度; 设备宽度与视口大小之间的缩放比例为1:1 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- 网页中运行的应用程序名称 -->
<meta name="application-name" content="app">
<!-- 文档作者的名字 -->
<meta name="author" content="mike">
<!-- 文档更喜欢黑暗模式，但在光模式下也可以在功能上呈现 -->
<meta name="color-scheme" content="dark light">
<!-- 
  Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，也就是 URL。
  Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。

  Origin: https://time.geekbang.org  (没有Path)
  Referer: https://time.geekbang.org/column/intro/216  (有Path)

  Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。
-->
<!-- 只发送当前文档的 origin -->
<meta name="referrer" content="origin">
```
### fviewport 有哪些属性
* width: 定义 viewport 的宽度，如果值为正整数，则单位为像素。
* initial-scale: 定义设备宽度（宽度和高度中更小的那个：如果是纵向屏幕，就是 device-width，如果是横向屏幕，就是 device-height）与 viewport 大小之间的缩放比例。范围 [0.0~10.0]
* maximum-scale: 定义缩放的最大值，必须大于等于 minimum-scale，否则表现将不可预测。浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。[0.0~10.0]
* minimum-scale: 定义缩放的最小值，必须小于等于 maximum-scale，否则表现将不可预测。浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。[0.0~10.0]
* user-scalable: 默认为 yes，如果设置为 no，用户将无法缩放当前页面。浏览器设置可以忽略此规则；iOS 10 开始，Safari iOS 默认忽略此规则。[yes|no]

# fhref 和 fsrc 有什么区别
href（hyperReference）即超文本引用：当浏览器遇到href时，会并行的地下载资源，不会阻塞页面解析，例如我们使用<link>引入CSS，浏览器会并行地下载CSS而不阻塞页面解析。
src（resource）即资源，当浏览器遇到src时，会暂停页面解析，直到该资源下载或执行完毕。
```html
<link href="style.css" rel="stylesheet" />
<!-- ..body.. -->
<script src="script.js"></script>
```

### fHTML生命周期事件有哪些? f生命周期
DOMContentLoaded => load => beforeunload => unload
1. fDOMContentLoaded  (在 document 上监听)
当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
```js
document.addEventListener('DOMContentLoaded',function(){
  console.log('1');
});
```
2. fload
当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。 
```js
window.addEventListener('load', (event) => {
  console.log('2');
});
```
3. fbeforeunload
当浏览器窗口关闭或者刷新时，会触发 beforeunload 事件。当前页面不会直接关闭，可以点击确定按钮关闭或刷新，也可以取消关闭或刷新。
```js
window.addEventListener('beforeunload', function(event) {
  console.log('3');
});
```
4. funload
当文档或一个子资源正在被卸载时，触发 unload事件。
```js
window.addEventListener('unload', function(event) {
  console.log('4');
});
```

# freadyState  fdocument.readyState
Document.readyState 属性描述了document 的加载状态。
当该属性值发生变化时，会在 document 对象上触发 readystatechange (en-US) 事件。
一个文档的 readyState 可以是以下之一:
* loading（正在加载）
document 仍在加载。
* interactive（可交互）
文档已被解析，"正在加载"状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。
* complete（完成）
文档和所有子资源已完成加载。表示 load 状态的事件即将被触发。
```js
document.addEventListener('readystatechange', (event) => {
  console.log(`readystate: ${document.readyState}\n`);
});
```
