# f时间复杂度
## 概念
执行算法流程发生的`常数时间操作`的数量，和数据量(记为N)之间的关系，用一个表达式来记录。
## 如何确定
O(..) 估计的是`最差`的情况，当完成了表达式的建立，只要把`最高阶项留下`即可。低阶项都去掉，高阶项的系数也去掉。记为: O(忽略掉系数的高阶项)
## 常数时间操作
如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。常数时间操作也有快慢之分:
1. `异或`快于`加法`
2. `加法`快于`除法`

# f排序
      时间复杂度       额外空间复杂度  稳定性
选择    O(N^2)             O(1)      无   非常挫，时间都O(N^2)了，稳定性还做不到
冒泡    O(N^2)             O(1)      有   
插入    O(N^2)             O(1)      有   
归并    O(N*logN) Strict   O(N)      有   稳定
快排    O(N*logN)          O(logN)   无   快
堆排    O(N*logN) Strict   O(1)      无   省空间
                                                                                                                基于比较的排序
============================================================================================================================
                                                                                                               不基于比较的排序
计数排序  O(N)              O(M)      有                                                            
基数排序  O(N)              O(N)      有    

## f排序总结  值钱💰的东西
1）不基于比较的排序，对样本数据有严格要求，不易改写
2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3）基于比较的排序，时间复杂度的极限是O(N*logN)
4）时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。
5）为了绝对的速度选快排(常数时间优异)、为了省空间选堆排(O(1))、为了稳定性选归并(三者里只有它稳定)

## 工程上对排序的改进
### 稳定性的考虑
1. 如果是基础类型，用快排。
因为基础类型不需要稳定性，比如[1,2,4,4,4,6,7]其中三个4怎么互相换位置结果都是对的，所以选三者中最快的`快排`。
2. 如果是非基础类型，用归并。
因为系统不知道你要不要稳定性，它得保证稳定性，三者中只有`归并`有稳定性。
### 充分利用O(N*logN)和O(N^2)排序各自的优势
1. 在快排中，数据量小的时候，用`插入排序`排完直接返回。
```js
// 插入排序指标差O(N^2)，但是常数项小，并且稳定
// 快速排序指标好O(N*logN)，但是常数项大
// 所以:
// N 很大的时候，快排优势明显
// N 不大的时候，插入排序会更快，具体多大取决于该语言的实验结果
function sort(nums, L, R) {
  if (L + 60 > R) {
    // 数据量小于60的时候改为插入排序: 
    // O(N^2) 但是常数项小
    return insertSort(nums, L, R);
  }
  // 快排 指标O(N*logN) 但是常数项高
  return quickSort(nums, L, R);
}
```

## TimSort
数据量小的情况下，使用`插入排序`(常数项小、稳定)。 (插入排序可以用二分法加快`查找插入位置`的速度)
数据量大的情况下，使用`归并排序`保证稳定性。

## f稳定性
稳定性是指同样大小的样本再排序之后不会改变相对次序。
### 用途
对基础类型来说，稳定性毫无意义。
对非基础类型来说，稳定性有重要意义。
有些排序算法可以实现成稳定的，比如冒泡排序，而有些排序算法无论如何都实现不成稳定的，比如选择排序。

## f选择排序  每轮选一个最小值放到本轮开头  一轮只搞定一个值
时间 O(N^2) 空间O(1)
### 流程
1. 无位置有序, 在[0,N-1]上找到`最小值`，把`最小值`和`0位置`交换。  [0, ..., ..., min, ...., N-1]  swap(arr,min,0);
2. [0,0]有序, 在[1,N-1]上找到`最小值`，把`最小值`和`1位置`交换。  [ok, 1, .., min, .., .., N-1]  swap(arr,min,1);
3. [0,1]有序, 在[2,N-1]上找到`最小值`，把`最小值`和`2位置`交换。  [ok, ok, 2, .., min, .., N-1]  swap(arr,min,2);   
...
[0,N-3]已经有序，在[N-2,N-1]上找到`最小值`，把`最小值`和`N-2位置`交换，排序完成✅。
### 时间复杂度
比较的次数: N-1 + N-2 + N-3 + ... + 1 = 等差数列的前 N 项和 (a1+an)* N/2 = (N-1 + 1)*N/2  => O(N^2)
### 空间复杂度
O(1) 只用有限几个变量
### 稳定性
无。[5,5,5,5,5,5,5,5,3] 第一步交换成 [3,5,5,5,5,5,5,5,5]，第一个 5 交换到最后去了，没有稳定性。
### 代码
```js
function selectionSort(nums) {
  if (!nums || nums.length < 2) {
    return;
  }
  for (let i = 0, len = nums.length; i < len; i++) {
    let min = nums[i];  // 每次初始最小值都是第一个位置
    for (let j = i + 1; j < len; j++) {   // i位置是默认最小值不用比较，从i+1开始比。
      if (nums[j] < min) {
        min = nums[j];   // 更新本次选择最小值，供内层循环判断
        swap(nums, j, i);
      }
    }
  }
}
function swap(nums, i, j) {
  const tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}
```
## f冒泡排序  每轮把最大值一路交换送到本轮末尾 一轮只搞定一个值 (有堵墙每轮都往左移动)
时间O(N^2) 空间O(1)
### 流程
1. 无位置有序, [0,1]上谁大谁往后, [1,2]上谁大谁往后, [2,3]上谁大谁往后, ... [N-2,N-1]上谁大谁往后
2. [N-1,N-1]有序, [0,1]上谁大谁往后, [1,2]上谁大谁往后, [2,3]上谁大谁往后, ... [N-3,N-2]上谁大谁往后
3. [N-2,N-1]有序, [0,1]上谁大谁往后, [1,2]上谁大谁往后, [2,3]上谁大谁往后, ... [N-4,N-3]上谁大谁往后
4. [N-3,N-1]有序, [0,1]上谁大谁往后, [1,2]上谁大谁往后, [2,3]上谁大谁往后, ... [N-5,N-4]上谁大谁往后
...
[1,N-1]有序, [0,1]上谁大谁往后，整个数组有序了✅
### 时间复杂度
比较的次数: N-1 + N-2 + N-3 + ... + 1 = 等差数列的前 N 项和 (an+a1)* N/2 = (N-1 + 1)*N/2  => O(N^2)
### 空间复杂度
O(1) 只用有限几个变量
### 稳定性
有。可以实现成稳定的: 相等的情况不交换，这样就稳定了。
### 代码
```js
function bubbleSort(nums) {
  if (!nums || nums.length < 2) {
    return;
  }
  for (let i = nums.length - 1; i >= 0; i--) {
    for (let j = 0; j < i; j++) {
      if (nums[j] > nums[j + 1]) {
        swap(nums, j, j + 1);
      }
    }
  }
  return nums;
}
function swap(nums, i, j) {
  const tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}
```
## f插入排序   手里拿着有序的牌，新抓一张，从右到左滑到一个合适的位置，插进去
时间O(N^2) 空间O(1)   
### 流程
1. 指针在0位置往前看，你比较小就交换往前去，没有数了停🤚
2. [0,0]有序，指针到1位置往前看，你比较小就交换往前去，没有小或没有数了就停
3. [0,1]有序，指针到2位置往前看，你比较小就交换往前去，没有小或没有数了就停
4. [0,2]有序，指针到3位置往前看，你比较小就交换往前去，没有小或没有数了就停
...
[0,N-2]有序，指针到N-1位置往前看，你比较小就交换往前去，没有小或没有数了就停，整个数组有序了✅
### 时间复杂度
不同数据状况下，插入排序的`时间复杂度`表现不一样:
最好情况: [1,2,3,4,5,6,7,8] 每一次抓牌，还没滑呢，比较一下就停了，常数操作: 1 + 1 + 1 + 1 + ... + 1, 看起来是 O(N)
最差情况: [8,7,6,5,4,3,2,1] 每一次抓牌，都要滑到开头才能停，常数操作: 1 + 2 + ... + N-1,  看起来是 O(N^2)
`时间复杂度`---big O，是指用`最差情况`来估计，所以最终`插入排序`的时间复杂度是`O(N^2)`。
### 空间复杂度
O(1) 只用有限几个变量
### 稳定性
有。相等的情况不往前滑，这样就稳定了。
### 代码
```js
function insertSort(nums) {
  if (!nums || nums.length < 2) {
    return nums;
  }
  for (let i = 1, len = nums.length; i < len; i++) {
    for (let j = i; j > 0; j--) {
      if (nums[j] < nums[j-1]) {
        swap(nums, j, j-1);
      }
    }
  }
  return nums;
}
function swap(nums, i, j) {
  const tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}
```
## f归并排序 f归并  fguibing
时间O(N*logN)  空间O(N)        
### 流程  先递归，再排序(merge)，和快排刚好相反
假设存在一个函数f(arr,L,R)，可以让arr在[L,R]上有序，想让arr整体有序，利用这个假设的函数，递归执行: (有黑盒了，要拆黑盒)
1. 求[0,N-1]的中点`M`
2. 执行f(arr,0,M) 让arr在[0,M]上有序(进递归)   T(N/2)
3. f(arr,M+1,N-1) 让arr在[M+1,N-1]上有序(进递归)  T(N/2)
4. 现在[0,M]是有序的，[M+1,N-1]也是有序的，将[0,M]和[M+1,N-1]合并回原数组(需要一个merge函数, O(N))，原数组在[0,N-1]上有序了✅ 
### 分析
为什么归并是O(NlogN)，而`选择/冒泡/插入`都是 O(N^2)?
`选择/冒泡/插入`每次都比较整轮，却只搞定一个数，下一轮又有重复的比较，它们在大量地浪费比较行为。
`归并`比较完的结果，变成`有序数组`返回给父级，所以比较行为没有浪费。
### 时间复杂度
这是一个递归行为，根据`master公式`: T(N) = 2*T(N/2)+O(N), a=2, b=2, d=1, 最终结果是: O(NlogN)。
### 空间复杂度
需要一个辅助数组，跟样本数组同长度，所以是 O(N)。
### 稳定性
有。merge过程，相等的情况拷贝左边的，这样就稳定了。
### 代码
```js
function mergeSort(arr) {
  if (!arr || arr.length < 2) {
    return arr;
  }
  return proc(arr, 0, arr.length-1);
}
/**
 * 使 arr 在 [L,R] 上排好序
 */
function proc(arr, L, R) {
  if (L === R) {
    // 只有一个数已经有序了，返回。
    return;
  }
  // 找[L,R]的中点，如果没有中点就找"上中位"
  const M = L + Math.floor((R - L) / 2);
  // 使[L,M]有序
  proc(arr, L, M);
  // 使[M+1,R]有序
  proc(arr, M + 1, R);
  // [L,M]和[M+1,R]都是有序的，合并到[L,R]上，使[L,R]有序
  merge(arr, L, M, R);
  // 返回排序的数组
  return arr;
}
/**
 * arr的[L,M]有序，[M+1,R]有序，合并这两块，使得arr的[L,R]上有序
 */
function merge(arr, L, M, R) {
  // 准备一个数组，存放最终 [L,R] 的有序排列，所以开的长度为 R-L+1。
  // 根据数据状况，可以换成 new Uint32Array(R-L+1) 等
  const help = [];
  // 两个指针怼在两个有序数组头，依次往前取值、比较，哪个小就拷贝哪个到 help 数组里
  let c1 = L;
  let c2 = M + 1;
  let i = 0;
  while (c1 <= M && c2 <= R) {
    if (arr[c1] <= arr[c2]) {
      help[i] = arr[c1++];
    } else {
      help[i] = arr[c2++];
    }
    i++;
  }
  // 两个只会中一个
  while (c1 <= M) {
    help[i++] = arr[c1++];
  }
  while (c2 <= R) {
    help[i++] = arr[c2++];
  }
  // [L,R]有序了，拷贝回原数组
  for (let j = 0, len = help.length; j < len; j++) {
    arr[L + j] = help[j];
  }
}
```
## f快速排序 f快排 f随机快排
时间O(NlogN) 空间O(logN)  
### 流程  先排序(荷兰国旗🇳🇱排出等于区域)，再递归
1. 在[L,R]上随机选一个数和R位置交换，在[L,R]上玩`荷兰国旗问题`，这样`等于区域`就排好序了，假设等于区域是[E1,E2]。
2. [L,E1-1]进递归，继续上面的过程"在[L,R]上随机...."，这样它的`等于区域也排好了`，它`递`下去的每一步都会排好一个`等于区域`。
3. 当到达`L>=R`时，这一边的[L,E-1]就全部排好了，返回搞最近上一层[E2+1,R]进递归。(深度优先)
4. [E2+1,R]进递归，继续上面的过程..，只要返回了，就是排好了。
5. 最后的右孩子排完返回，一路往上返回到根，整个数组有序了✅
### 例子
1. [3,1,4,7,8,4,0,5,9,12] 随机选中`4`，`4`和`12`交换，从0位置到4前一个位置，玩荷兰国旗问题为[3,1,0,4,7,8,12,5,9,4]，再交换`4`和`大于区域第一个位置`，排为[3,1,0,4,4,8,12,5,9,7]，其中两个`4`已经到达有序位置，后面不用动了。
2. 左边[3,1,0]递下去，随机选中`1`，`1`和`0`交换，经过荷兰国旗问题[0,3,1]，再交换`1`和`大于区域第一个位置`，排为[0,1,3]，这时`1`已经到达有序位置。
3. 左边[0]递下去，[L,R]撞上, 代表已经有序, 直接`归`, 回到父级。
4. 父级[0,1,3]往右递下去是[3]，直接返回，[0,1,3]结束，已经有序，返回它的父级[0,1,3,4,4,8,12,5,9,7], 右边还没递进去。
5. 右边[8,12,5,9,7]递下去, 随机选中`7`, 交换 -> 荷兰 -> 排为[5,7,9,8,12]，`7`已经到达有序位置。
6. 左边[5]递下去直接`归`。
7. 右边[9,8,12]递下去，随机选中`9`，交换->荷兰->排为[8,9,12]，`9`已经到达有序位置。
8. 左边[8]递下去直接`归`。
9. 右边[12]递下去直接`归`。
10. 原数组被调整为[0,1,3,4,4,5,7,8,9,12], 已经有序，一路返回到根。
### 时间复杂度
O(NlogN)。
快排2.0没有随机行为，所以有最差情况 -- 每次都打到最大值:  
1. [3,1,2,12,9,7,8]打到12, 划分为[3,1,2,9,7,8,12], 12和大于区域第一个交换, 也就是和自己交换, 结果为[3,1,2,9,7,8,12] 走了N-1步
2. 12不用动了, [3,1,2,9,7,8,12]打到9, 划分为[3,1,2,7,8,9,12], 9和大于区域第一个交换, 也就是和自己交换, 结果为[3,1,2,7,8,9,12] 走了N-2步
...
最后走1步。总结下来就是 N-1 + N-2 + ... + 1 => 等差数列和 => O(N^2)。
但是，快排3.0有随机行为，这使得递归过程可以看成 T(N) = 2*T(N/2) + O(N)，其中递归两边是 T(N/2)，荷兰国旗问题是 O(N)。所以根据 master 公式，算出快排的时间复杂度是 O(NlogN)。
### 空间复杂度
O(logN)。 也是概率，好O(logN) ~ 坏O(N)，数学期望 O(logN)
### 稳定性
无。随机选中的值，partition完交换回去不知道在等于区域的哪个位置，所以不稳定。
### 代码
```js
function quickSort(nums) {
  if (!nums || nums.length < 2) {
    return nums;
  }
  return proc(nums, 0, nums.length - 1);
}
// 递归含义: 将 nums 的 [L,R] 排好序。
function proc(nums, L, R) {
  if (L >= R) {
    return;
  }
  // 在[L,R]上，随机选一个位置，和 R 位置交换
  swap(nums, L + Math.floor(Math.random() * (R - L + 1)), R);
  // 荷兰国旗排好`等于区域`，分出`小于`和`大于`区域
  const equals = netherlandsFlag(nums, L, R);
  // 小于区域递归
  proc(nums, L, equals[0] - 1);
  // 大于区域递归
  proc(nums, equals[1] + 1, R);
  // 返回排好序的数组
  return nums;
}
// f荷兰国旗 fPartiton
// 在[L,R]上，以nums[R]为划分值，将 <nums[R] 的放在左边，===nums[R]的放中间，>nums[R]的放右边
function netherlandsFlag(nums, L, R) {
  // 处理一些特殊情况，加速返回，没什么坏处。
  if (L > R) {
    return [-1, -1];
  }
  if (L === R) {
    return [L, R];
  }
  // 以 nums[R]作划分值
  const target = nums[R];
  let less = L - 1;   // 小于区域一开始啥也没有
  let more = R;   // 大于区域一开始啥也没有
  let cur = L;  // 从第一个位置开始遍历, O(N)

  while (cur < more) {
    if (nums[cur] < target) {
      // 当前值小于目标，当前值和小于区域下一个值交换，小于区域往右动，当前指针往右动
      swap(nums, cur++, ++less);
    }
    else if (nums[cur] > target) {
      // 当前值大于目标，当前值和大于区域前一个值交换，大于区域往左动，当前指针不动(换过来的数还没检查)
      swap(nums, cur, --more);
    }
    else {
      // 当前值等于目标，当前指针往右动
      cur++;
    }
  }
  // 将划分值`nums[R]`和`大于区域的第一个值`交换，这样`等于区域`就找到了自己在`整个数组排序中`的位置。
  swap(nums, R, more);
  // 返回等于区域的区间
  return [less + 1, more];
}
function swap(nums, i, j) {
  const tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}
```

## f堆排
时间O(NlogN) 空间O(1)      
### 流程
1. 把数组[0,N-1]调整成大根堆: 从上往下建树🌲(heapInsert, O(NlogN));  从下往上建树🌲(heapify, O(N));
2. 将堆顶和数组的[N-1]位置交换，heapSize--, 数组[N-1,N-1]有序了。
3. 交换过来的数，往下heapify，重新将[0,N-2]调整成大根堆。
4. [重复]将新的堆顶和数组[N-2]位置交换，heapSize--，数组[N-2,N-1]有序了。
5. 交换过来的数，往下heapify，重新调整成大根堆，...
最后，heapSize减少为0，整个数组有序了。
### 时间复杂度
O(N *logN)
证明: (数据量增加常数法)
1. 数组[0,N-1]的时候， 每次调整堆的代价累加: O(logN) + O(log(N-1)) + ... + O(1), 一共 N 次，所以时间复杂度 <= O(N*logN);
2. 数组[0,2N-1]的时候，[0,N-1]上堆的高度已经是 logN, 所以一半的过程是 O(log2N) + O(log(2N-1)) + ... O(log(N+1)), 一共 N 次, 时间复杂度 >= O(N*logN)
3. 时间复杂度 >= O(N*logN) 并且 时间复杂度 <= O(N *logN), 所以 时间复杂度 === O(N *logN)。
### 空间复杂度
O(1) 数组自己可以做堆，heapify/heapInsert 都只用有限几个变量就解决了。
### 稳定性
无。[4,4,4,4,4,4,4,6]调成大根堆，中间的4移到了最后, 后面heapify也回不来, 稳定性破坏得非常彻底。
### 代码
```js
// 堆排
function heapSort(nums) {
  if (!nums || nums.length < 2) {
    return nums;
  }
  // 从下往上建树🌲，整个数组初始化成大根堆
  for (let i = nums.length - 1; i >= 0; i--) {
    heapify(nums, i, nums.length);
  }
  let heapSize = nums.length;
  while (heapSize) {
    // 交换堆顶和堆最后一个数，使数组[堆最后一位, N-1]有序。
    swap(nums, 0, --heapSize);
    // 交换过来的数，往下 heapify，重新建立大根堆
    heapify(nums, 0, heapSize);
    // 堆尺寸减少为0时，全部数已经有序，退出。
  }
  return nums;
}
// 从 i 位置往下，调整成大根堆
function heapify(nums, i, heapSize) {
  if (2 * i + 1 > heapSize - 1) {
    // 没有左孩子，返回。
    return;
  }
  // 初始化较大的为左孩子
  let more = 2 * i + 1;
  if (2 * i + 2 <= heapSize - 1) {
    // 如果有右孩子，取左右中较大的那个
    more = nums[2 * i + 1] >= nums[2 * i + 2] ? (2 * i + 1) : (2 * i + 2);
  }
  // 往下沉
  if (nums[more] > nums[i]) {
    swap(nums, i, more);
    heapify(nums, more, heapSize);
  }
}
function swap(nums, i, j) {
  const tmp = nums[i];
  nums[i] = nums[j];
  nums[j] = tmp;
}
```
## f计数排序  f诸多限制 f不基于比较 f桶排序🪣思想
时间O(N)  空间O(N) 
### 流程
1. 准备一个help数组，长度包含样本数组的范围，比如员工年龄最小值16最大值200，那就准备长度201。 [22,17,16,22,16,16,17]
2. 遍历样本数组，遇到的每个数，都在help对应下标处+1, 相当于统计每个数出现的次数。[0(0),0(1),....3(16),2(17),...2(22),...0(200)] O(N)
3. 遍历help数组，根据次数还原每个年龄，得到排序后的数组 [16,16,16,17,17,22,22]  O(N) 没有比较，桶🪣就是有序的
### 时间复杂度
遍历常数遍搞定，O(N)
### 空间复杂度
需要一个等长的辅助数组，O(N)
### 稳定性
有。入桶&出桶是稳定的。
### 缺点
两点限制:
1. 样本是整数  (现实中往往是一个复杂结构，改写巨麻烦..)
2. 数据范围比较窄  (现实中的范围，往往难预测)
一旦要求稍有升级，改写代价增加是显而易见的。比如样本范围增加，help数组的长度就要随之增加。
比如，要排一个随意的 int[] 数组，范围是[-21亿,+21亿]，那就要准备一个长度为`42亿`的`help`数组。。。如果样本只有`1000`个数，这么准备太浪费了。。
### 代码
```js
// 计数排序
function countSort(nums) {
  if (nums == null || nums.length < 2) {
    return nums;
  }
  // 仅适用于非负数
  // 要适用于负数，只要数组全部减个最小值，排完序再全部加上最小值即可。

  // 找到最大值，建桶
  let max = Number.MIN_SAFE_INTEGER;
  for (let i = 0; i < nums.length; i++) {
    max = Math.max(max, nums[i]);
  }
  // 用桶统计词频
  const bucket = new Uint32Array(max + 1);
  for (let i = nums.length - 1; i >= 0; i--) {
    bucket[nums[i]]++;
  }
  let i = 0;
  // 桶里面有数的话，依次倒出来
  for (let j = 0, len = bucket.length; j < len; j++) {
    while (bucket[j]-- > 0) {
      nums[i++] = j;
    }
  }
  return nums;
}
```

## f基数排序  f诸多限制 f不基于比较 f桶排序🪣思想
时间O(N) 空间O(N) 
### 流程
1. [103,13,27,25,17,9]遍历一遍找到最大值103, 103的十进制位数是3位。那么把样本数组不够3位的都补0, 得到[103,013,027,025,017,009]
2. 准备10个队列🚀(可以更优雅), 遍历样本, 按照`个位`的数字找到队列, 依次入队: [()0, ()1, ()2, (013,103)3..., (025)5, (017,027)7, (009)9]
3. 遍历10个队列🚀, 往外倒数字, 先入队列的先出: [103,013,025,027,017,009], 此时数组是按`个位`数字排序的
4. 按`十位`进队列: [(009,103)0, (017,013)1, (027,025)2, ()3, ..., ()9]
5. 把数倒出来: [103,009,013,017,025,027], 此时数组按`十位`排序，`十位`数相同的情况按`个位`排序
6. 按`百位`进队列: [(027,025,017,013,009)0, (103)1, ()2, ... ()9]
7. 把数倒出来: [009,013,017,025,027,103], 样本数组有序了✅  (按`百位`排序, `百位`相同按`十位`排序, `十位`相同按`个位`排序)
### 时间复杂度
遍历常数遍搞定，O(N)
### 空间复杂度
需要一个等长的辅助数组，O(N)
### 稳定性
有。入桶&出桶是稳定的。
### 分析
低位的顺序会依次留下来，但最终以高位为准。
### 缺点
一般来讲，基数排序要求样本是10进制的正整数。
如果不是(比如字母)，就必须调研它内部如何按基数来排，这样就比较麻烦。如果是基于比较的排序，定义一个比较器就搞定了。
### 代码
```js
function radixSort(nums) {
  if (!nums || nums.length < 2) {
    return nums;
  }
  // 要适用于负数，只要数组全部减个最小值，排完序再全部加上最小值即可。
  const min = getMin(nums);
  if (min < 0) {
    for (let i = nums.length - 1; i >= 0; i--) {
      nums[i] = nums[i] - min;
    }
  }
  const sortedNums =  doRadixSort(nums, 0, nums.length - 1, maxBits(nums));
  if (min < 0) {
    for (let i = sortedNums.length - 1; i >= 0; i--) {
      sortedNums[i] = sortedNums[i] + min;
    }
  }
  return sortedNums;
}
function getMin(nums) {
    let min = Number.MAX_SAFE_INTEGER;
    for (let i = nums.length - 1; i >= 0; i--) {
        min = Math.min(min, nums[i]);
    }
    return min;
}
// 只适用于非负数
// 在 nums 的 [L,R] 上，最大的位数是 digit，请把 nums 的 [L,R] 排好序。
function doRadixSort(nums, L, R, digit) {
  const radix = 10;
  let i = 0;
  let j = 0;
  const help = new Uint32Array(R - L + 1);
  // O(N * digit) ~= O(N)
  for (let d = 1; d <= digit; d++) {
    // 每个数 进出队列 digit 次   
    // 比如 digit 是3，那就代表每个数 "按个位进出1次，按十位进出1次，按百位进出1次"，一共3次。
    // 每次出队列，都将 nums 按当前位排序，同时低位的顺序保留了下来。

    // count 记录当前位下，每个数出现的数量
    // 比如当前位是个位，样本是 [101,001,022,031,040], 那么count是 [1(040), 3(101,001,031), 1(022), 0,0,0,0,0,0,0]。
    const count = new Uint32Array(radix);
    for (i = L; i <= R; i++) {
      // 提取每个数在当前位的数字，比如`031`在`个位`的数字是 1。
      j = getDigit(nums[i], d);
      count[j]++;
    }
    // count -> count' 求前缀和数组: [1(040),4(040,101,001,031),5(all),5,5,5,5,5,5,5]，代表样本中，个位的数小于等于 index 的个数
    for (i = 1; i < radix; i++) {
      count[i] = count[i] + count[i - 1];
    }
    // 从右往左遍历样本:
    // 1. 040个位是0，count'[0]为1, 代表[0,0], 所以放到0位置 [040(0), ..]; count'[0]--;
    // 2. 031个位是1，count'[1]为4, 代表[0,3], 所以放到3位置 [040(0), ..., 031(3)]; count'[1]--;
    // 3. 022个位是2，count'[2]为5, 代表[0,4], 所以放到4位置 [040(0), ..., 031(3), 022(4)]; count'[2]--; 
    // 4. 001个位是1，count'[1]为3, 代表[0,2], 所以放到2位置 [040(0), ..., 001(2), 031(3), 022(4)]; count'[1]--; (count'[2]只关心`个位为2`的最右位置，所以count'[1]--的时候，与count'[2]无关)
    // 5. 101个位是1，count'[1]为2, 代表[0,1], 所以放到2位置 [040(0), 101(1), 001(2), 031(3), 022(4)]; count'[1]--;
    // 遍历完成，数组已经按个位排好序: [040,101,001,031,022]
    for (i = R; i >= L; i--) {
      // 022个位是2
      j = getDigit(nums[i], d);
      // count'[2]为5, 代表[0,4], 所以 022 放到4位置 (count'[2]-1)
      help[count[j] - 1] = nums[i];
      // 词频--
      count[j]--;
    }
    // 辅助数组同步到原数组
    for (i = L, j = 0; i <= R; i++, j++) {
      nums[i] = help[j];
    }
  }
  return nums;
}
// 返回数组的最大位数
// 比如 [56,3,12,100], 最大位到百位是3个位，所以返回 3。
function maxBits(nums) {
  let max = Number.MIN_SAFE_INTEGER;
  for (let i = nums.length - 1; i >= 0; i--) {
    max = Math.max(max, nums[i]);
  }
  // max 每次除以 10，除成 0 需要的次数，就是 max 的位数。
  let res = 0;
  while (max !== 0) {
    res++;  // 除了几次
    max = Math.floor(max / 10);
  }
  return res;
}
// 返回 x 从右往左数 d 位的数字
// 比如:
// d 为 1，x 为 022，返回`个位`的 2。
// d 为 3，x 为 987654321，返回`百位`的 3。
function getDigit(x, d) {
  return Math.floor(x / (d === 1 ? 1 : Math.pow(10, d - 1))) % 10;
}
```
## f经典交换
```js
function swap(arr, i, j) {
  const temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
```
## f原地交换
不见得比`经典交换`快，但是没有用任何额外变量。且面试官可以看出，你是道上的人。
```js
function swap(arr, i, j) {
   arr[i] = arr[i] ^ arr[j];
   arr[j] = arr[i] ^ arr[j];  // arr[j] = (arr[i]^arr[j]) ^ arr[j] = arr[i] ^ (arr[j]^arr[j]) = arr[i] ^ 0 = arr[i]
   arr[i] = arr[i] ^ arr[j];  // arr[i] = (arr[i]^arr[j]) ^ arr[i] = (arr[i]^arr[i]) ^ arr[j] = 0 ^ arr[j] = arr[j]
}
```

# f二叉树
## f遍历
对每一棵子树，先处理头结点，再处理左子树，最后处理右子树，这就是先序遍历。
对每一棵子树，先处理左子树，再处理头结点，最后处理右子树，这就是中序遍历。
对每一棵子树，先处理右子树，再处理左子树，最后处理头结点，这就是后序遍历。

## f递归遍历 f递归序
到达每个结点三次
```js
function travel(head) {
  if (!head) {
    return;
  }
  // f先序遍历 递归方式
  travel(head.left);
  // f中序遍历 递归方式
  travel(head.right);
  // f后序遍历 递归方式
}
```

# f二叉树的递归套路 f树形dp
1）假设以X节点为头，假设可以向X左树和X右树要`任何信息`
2）在上一步的假设下，讨论以`X`为头节点的树，得到答案的可能性（最重要🔥）
3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4）把左树信息和右树信息`求全集`，就是任何一棵子树都需要返回的信息S
5）递归函数都返回S，每一棵子树都这么要求
6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息
## 本质 后序遍历  O(N) 
x向左树要信息，x向右树要信息，得到两边的信息再加工出自己的信息，相当于玩了一次`后序遍历`。
递归方法一个结点只会到达`3`次，所以如果树的结点数量是`N`，那么这个方法的常数时间操作是`3N`·，时间复杂度就是O(N)。
## 卖点
1. 思想提醒
不管遇到什么树形dp的题目，都思考`以x为头的返回信息怎么实现`, 实现的重要手段是`可以向左树要信息也可以向右树要信息`, 拿到信息以后分可能性，常见的分类是`x参与的情况`和`x不参与的情况`。
2. 高度模板化
信息体一旦定了:
* 写Info是模板
* 递归函数proc形参+返回值是模板的。
* head为空好设置就设置,不好设置就设为空，返回去上游处理是模板。
* 拿到左右子树信息，加工自己信息是模板的。

## f二叉树的最大 BST 子树
给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小。其中，最大指的是子树节点数最多的。
### 流程
1. 列条件🔥 定出子树的信息
假设以x结点为头，可以向x左树和x右树要`任何信息`，思考怎么得到`以x为头的子树`的`最大BST子树结点数`？
有两种可能:
* x不参与，`maxBSTSize`是`左树的maxBSTSize`和`右树的maxBSTSize`中的较大值。
* x参与。那么 x 必须是搜索二叉树才能参与比较，也就需要: `左isBST && 右isBST && 左max < x.val < 右min`。
计算自己的maxBSTSize时: maxBSTSize = 左size+右size+1。
所以，需要的信息有: (maxBSTSize, isBST, max, min, size), 由于`isBST`等同于`maxBSTSize === size`，所以 isBST 可以去掉。
那么最终的信息是 `(maxBSTSize, max, min, size)`。
2. 处理空树
不知道怎么设置时，就返回`null`让上游处理
3. 算自己的信息，完成递归
流程1已经说明。
4. 主函数调用递归，返回信息中的`maxBSTSize`，判断完成✅
### 代码
```js
// 最大 BST 子树
function largestBSTSubtree(root) {
  if (!root) {
    return 0;
  }
  return proc(root).maxBSTSize;
};

// 每棵子树都应该有的信息
class Info {
  constructor(mbs, max, min, size) {
    this.maxBSTSize = mbs;   // 最大BST结点数
    this.max = max;  // 最大值
    this.min = min;  // 最小值
    this.size = size;  // 结点数量
    // 隐含属性isBST(是否为搜索二叉树): 当 maxBSTSize === size 时是，否则不是。
  }
}
function proc(x) {
  if (!x) {
    // 不知道怎么设置空树的Info时，就设置为null，交给上游去处理。
    return null;
  }
  // 跟左右子树要信息
  const leftInfo = proc(x.left);
  const rightInfo = proc(x.right);

  // 组合出 max, min, size
  let max = x.val;
  let min = x.val;
  let size = 1;
  if (leftInfo) {
    max = Math.max(max, leftInfo.max);
    min = Math.min(min, leftInfo.min);
    size += leftInfo.size;
  }
  if (rightInfo) {
    max = Math.max(max, rightInfo.max);
    min = Math.min(min, rightInfo.min);
    size += rightInfo.size;
  }

  // 可能性1: x不参与 maxBSTSize 计算
  // 结果要么是左子树的 maxBSTSize, 要么是右子树的 maxBSTSize。
  const p1 = leftInfo ? leftInfo.maxBSTSize : -1;
  const p2 = rightInfo ? rightInfo.maxBSTSize : -1;

  // 可能性2: x参与 maxBSTSize 计算，那么 x 就得先是搜索二叉树。
  // 这需要满足以下条件:
  // 1. 左子树是搜索二叉树
  // 2. 右子树是搜索二叉树
  // 3. 左max < x.val < 右max

  // 初始值设置为 -1, 如果以x为头的子树不是搜索二叉树，p3就会维持-1，这样在后面的max比较中就会落败，结果一定是 p1 或 p2。
  let p3 = -1;
  // 左子树是否搜索二叉树  (注意空树认为是搜索二叉树，这是为了上游好处理  比如[5,null,6]是搜索二叉树 )
  const isLeftBST = leftInfo ? (leftInfo.maxBSTSize === leftInfo.size) : true;
  // 右子树是否搜索二叉树  (注意空树认为是搜索二叉树，这是为了上游好处理  比如[5,3,null]是搜索二叉树 )
  const isRightBST = rightInfo ? (rightInfo.maxBSTSize === rightInfo.size) : true;
  // 左max < x.val < 右max   注意空树不违规，这是为了上游好处理，同上面👆
  const leftMaxLessX = leftInfo ? (leftInfo.max < x.val) : true;
  const rightMinMoreX = rightInfo ? (rightInfo.min > x.val) : true;

  if (isLeftBST && isRightBST && leftMaxLessX && rightMinMoreX) {
    // 以x为头的子树是搜索二叉树，计算可能性2的 maxBSTSize = 左子树的结点数量 + 右子树的结点数量 + 1
    const leftSize = leftInfo ? leftInfo.size : 0;
    const rightSize = rightInfo ? rightInfo.size : 0;
    p3 = leftSize + rightSize + 1;
  }
  // PK 所有可能性，选出最大值，就是 `以x为头的子树的最大 BST 结点数量`
  const maxBSTSize = Math.max(Math.max(p1, p2), p3);
  // 返回信息给上游使用
  return new Info(maxBSTSize, max, min, size);
}
```

## f二叉树的最大距离
二叉树每两个结点之间都有`距离`，给你一个头结点，返回该二叉树中的最大`距离`，注意这个距离可能经过头结点，也可能不经过头结点。
(`距离`是指从一个结点到另一个结点，中间结点只能经过一次，得到的结点数量。)
### 流程
1. 列条件🔥
假设以x结点为头，可以向x左树和x右树要`任何信息`，思考怎么得到`以x为头的子树`的最大距离？
有两种可能:
* x不参与，最大距离是`左树的最大距离`或`右树的最大距离`。
* x参与，最大路径是"左边离x最远的结点->x->右边离x最远的结点"，所以最大距离就是`左树高度+右树高度+1`
这两种可能求最大值，就是`以x为头的子树`的最大距离。
所以需要的信息有: (左maxDistance、左height) (右maxDistance、右height) 
2. 处理空树
空树的maxDistance是0，空树的height是0。
3. 算自己的信息，完成递归
* 自己的height = max(左height,右height)+1
* 自己的maxDistance = max(左树的最大距离, 右树的最大距离, 左树高度+右树高度+1)
组合自己的信息，返回给上游，递归连起来了。
4. 主函数调用递归，返回`信息`中的`maxDistance`，完成✅
### 代码
```js
function maxDistance(root) {
  if (!root) {
      return 0;
  }
  return proc(root).maxDistance;
};
class Info {
  constructor(maxDistance, height) {
      this.maxDistance = maxDistance;
      this.height = height;
  }
}
function proc(head) {
  if (!head) {
      return new Info(0, 0);
  }
  const leftInfo = proc(head.left);
  const rightInfo = proc(head.right);
  // 组合自己的信息
  const height = Math.max(leftInfo.height, rightInfo.height) + 1;
  // 三种情况求最大值
  const p1 = leftInfo.maxDistance;
  const p2 = rightInfo.maxDistance;
  const p3 = leftInfo.height + rightInfo.height + 1;
  const maxDistance = Math.max(Math.max(p1, p2), p3);
  // 返回自己的信息给上游
  return new Info(maxDistance, height);
}
```

## f满二叉树
树的高度是h，结点数量是2^h-1的，就是满二叉树。
### 流程
1. 列条件🔥，定子树信息。
假设以x节点为头，可以向x左树和x右树要`任何信息`，思考以x为头的子树，怎么判断是满二叉树？
需要同时满足以下条件:
* x子树的结点数量 = 2^x高度-1
所以需要的信息有: (左结点数量nums、左height) (右结点数量nums、右height)。
2. 处理空树
认为空树的nums是0，空树的height是0。
3. 算自己的信息，完成递归
自己的height = max(左height, 右height)+1
自己的nums = 左nums+右nums+1
组合自己的信息，返回给上游，递归连起来了。
4. 主函数调用递归，判断`信息`中是否满足`nums = 2^height-1`。如果满足，就是满二叉树; 如果不满足，就不是满二叉树，判断完成✅
### 代码
```js
// 是否是满二叉树
function isFill(root) {
  const { height, nums } = proc(root);
  // 满足 结点数量 = 2^高度 - 1 的，就是满二叉树，否则不是。
  return (1 << height) - 1 === nums;
}
class Info {
  constructor(h, n) {
    this.height = h;  // 高度
    this.num = n;  // 结点数量
  }
}
function proc(head) {
  if (!head) {
    return new Info(0, 0);
  }
  // 向左右子树要信息
  const leftInfo = proc(head.left);
  const rightInfo = proc(head.right);
  // 组合自己的信息
  const nums = leftInfo.nums + rightInfo.nums + 1;
  const height = Math.max(leftInfo.height, rightInfo.height) + 1;
  // 返回给上游
  return new Info(height, nums);
}
```

## f搜索二叉树
对于树中的`任意一个节点`，左子树只包含`小于`当前节点的数，右子树只包含`大于`当前节点的数，这样的树就是搜索二叉树。
### 流程
1. 列条件🔥
假设以x节点为头，可以向x左树和x右树要`任何信息`，思考以x为头的子树，怎么判断是搜索二叉树？
需要同时满足以下条件:
* x左树得是搜索二叉树
* x右树得是搜索二叉树
* x左树的max必须小于x.val, x右树的min必须大于x.val
所以需要的信息有: (左搜否、左max) (右搜否、右min)，这时候x对左右子树要的信息不一样，但是由于递归对所有结点一视同仁，所以定子树信息为全集: 搜否、max、min。
2. 处理空树
认为空树是搜索二叉树，这样上游好处理。
认为空树的max是系统最小值 (让空树max无效)
认为空树的min是系统最大值 (让空树min无效)
3. 算自己的信息，完成递归
拿到左右树的min算出自己的min，
判断是否 左max < x.val < 右min，算出自己的isSearch
组合自己的信息，返回给上游，递归连起来了。
4. 主函数调用递归，返回`信息`中的`搜否`，完成✅
### 代码
```js
// 是否是搜索二叉树
function isSearchTree(head) {
  return proc(head).isSearch;
}
class Info {
  constructor(isSearch, max, min) {
    this.isSearch = isSearch;
    this.max = max;
    this.min = min;
  }
}
/**
 * 
 * @param {Node} head
 * @return {Info} 
 */
function proc(head) {
  if (!head) {
    // 认为空树是搜索二叉树
    // 认为空树的max是系统最小值，空树的min是系统最大值，这是为了让它们无效。
    return new Info(true, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
  }
  // 向左右子树要信息
  const leftInfo = proc(head.left);
  const rightInfo = proc(head.right);
  // 组合自己的信息
  const max = Math.max(Math.max(leftInfo.max, rightInfo.max), head.val);
  const min = Math.min(Math.min(leftInfo.min, rightInfo.min), head.val);
  let isSearch = false;
  if (leftInfo.isSearch && rightInfo.isSearch && leftInfo.max < head.val && head.val < rightInfo.min) {
    isSearch = true;
  }
  // 返给上游，递归连起来
  return new Info(isSearch, max, min);
}
```
### 不用套路判断一棵树是否是搜索二叉树
中序遍历一下，如果数组一直上升，那就是搜索二叉树。

## f平衡二叉树
对于树中的`任意一个结点`，左子树和右子树的`高度差`不超过`1`，这样的树就叫平衡二叉树。
### 流程
1. 分析可能性，定出子树的信息(结构)
看概念好像只要高度，但是`x`为头的左右子树可能很大，如果左右子树一样高，但是有一棵不平衡，这样x为头的整棵树也是不平衡的。
所以，要让以结点`x`为头的子树是平衡二叉树，需满足:
* x的左子树是平衡二叉树
* x的右子树是平衡二叉树
* x的左子树和x的右子树的高度差不超过1
在x的处理环节，x需要`向两边的子树`要`2`个信息，第一个是`是否平衡`，第二个是`子树的高度`，这就是`子树的信息`。
2. 定义递归函数
x拿到左右子树的`信息`，然后组合出自己的`信息`，返回给父级。整个递归连起来了。
3. 主函数调用递归 
根调用递归，有两个信息:`是否平衡`和`高度`，它返回自己`是否平衡`就行，搞定✅
### 代码
```js
function isBalanceTree(head) {
  return proc(head).isBalance;
}
/**
 * 子树的信息
 * @param {boolean} isBalance 是否是平衡二叉树
 * @param {number} height 高度
 */
class Info {
  constructor(isBalance, height) {
    this.isBalance = isBalance;
    this.height = height;
  }
}
/**
 * 返回每棵子树的信息
 * @param {Node} head 子树头
 * @return {Info} 子树的信息
 */
function proc(head) {
  if (!head) {
    // 空树是平衡二叉树 (这么定义代码好写)
    // 空树的高度是0
    return new Info(true, 0);
  }
  // 向左右子树要信息
  const leftInfo = proc(head.left);
  const rightInfo = proc(head.right);
  // 我也得返回 Info，整个递归才能连起来，所以求:
  // 1. 我是不是平衡二叉树
  // 2. 我的高度

  // 1. 左右子树都平衡，并且高度差不超过1，我就是平衡二叉树
  let isBalance = false;
  if (leftInfo.isBalance && rightInfo.isBalance && Math.abs(leftInfo.height - rightInfo.height) < 2) {
    isBalance = true;
  }
  // 2. 两棵子树中较高的高度+1，就是我的高度。
  const height = Math.max(leftInfo.height, rightInfo.height) + 1;
  // 返回我的信息给父级，整个递归连起来了
  return new Info(isBalance, height);
}
```

## f完全二叉树
一棵树要么是满二叉树，要么是从左往右依次变满的过程，这样的树就叫完全二叉树。
### 判断一棵树是否是完全二叉树
`按层遍历`这棵树，如果:
1. 遇到的结点有右无左，返回 false。
2. 当第一次遇到左右孩子不双全的结点时，接下来遍历到的结点必须都是叶子结点，否则返回 false。
如果遍历过程上面两个原则都不违反，顺利遍历完，就是完全二叉树✅
### 代码
```js
// 是否是完全二叉树  层序遍历法
function isCBT1(head) {
  if (head === null) {
    // 看你怎么规定，经典方法认为 空树是完全二叉树
    return true;
  }
  // 准备一个队列，进行按层遍历
  const queue = [];
  // 是否遇到过左右孩子不双全的结点
  let leaf = false;
  let l = null;
  let r = null;
  // 二叉树的层序遍历，先把头结点入队
  queue.unshift(head);
  while (queue.length > 0) {
    // 从队列弹出一个结点
    head = queue.pop();
    // 拿到左右孩子
    l = head.left;
    r = head.right;
    // 每遍历一个结点，都判断是否命中🎯违规情况
    if (
      // 违规情况1: 有右无左，返回 false
      (r !== null && l === null)
      ||
      // 违规2情况: 之前遇到过`左右孩子不双全`的结点，同时本结点不是叶子结点，返回 false
      (leaf && (l !== null || r !== null))
    ) {
      return false;
    }
    // 按层遍历传递: 左孩子不为空左孩子入队，然后右孩子不为空右孩子入队
    if (l !== null) {
      queue.unshift(l);
    }
    if (r !== null) {
      queue.unshift(r);
    }
    // 遇到了左右孩子不双全的结点，打开开关
    // 开关一旦打开，就永远是 true，不会再关上。
    if (l === null || r === null) {
      leaf = true;
    }
  }
  // 顺利遍历完，没有违规，是完全二叉树
  return true;
}
```

## f序列化二叉树
如果用程序描述一棵二叉树🌲，它存在于内存里。
那么有一个问题，如果现在我的机器要停机🤚，停机内存里的数据就没了，于是我想把这棵树变成文件📃的形式，最好把这棵树转成一个字符串(省空间)，这个字符串代表唯一的二叉树，这棵二叉树也代表唯一的字符串。树转字符串的过程就是`序列化`。
如果你想把这棵树在别的机器上还原出来，就用这个字符串去还原，这就是`反序列化`。
### f先序方式序列化
                 1
       1               null
null        1
        null  null

上面👆这棵树，`null`用`#`表示，每个结点用`,`分割，用`先序遍历`的方式`序列化`, 结果是 "1,1,#,1,#,#,#"。
### 代码
```js
// 先序方式序列化
function preSerialize(root) {
  const queue = [];  // 队列顺序: first <-- last
  serialize(root, queue);
  return queue;
}
function serialize(node, queue) {
  if (!node) {
    // 规定空结点用 null 来占位
    queue.push(null);
    return;
  }
  // 先序遍历, 对于任意一棵子树:
  // 先序列化头结点
  queue.push(node.val);
  // 再序列化左子树
  serialize(node.left, queue);
  // 最后序列化右子树
  serialize(node.right, queue);
}
```
## f反序列化二叉树
### f先序方式反序列化
先序顺序是`头左右`，那么从字符串建立树的顺序，也应该是`头左右`。
### 流程
1. 把字符串按`,`分隔开，得到一个数组。
2. 数组弹出第一个元素，建立head
3. 数组从头弹出一个元素
* 如果是`#`, 父级等待的子树结束了。返回空结点。
* 如果不是`#`，以这个值建立一个头结点head。然后用队列接下来的数据`递下去`建立左子树`归回来`回来给head.left; 再`递下去`建立右子树`归回来`给head.right。返回头结点给父级建立子树。
### 代码
```js
// 先序方式反序列化
// 队列顺序  first <-- last
function buildByPreQueue(queue) {
  if (!queue || queue.length === 0) {
    // 收到捣乱的数据，返回空树
    return null;
  }
  return reConstruct(queue);
}
function reConstruct(queue) {
  // 弹出队列的第一个元素
  const value = queue.shift();
  // value 不知道它的父结点是谁，只知道父结点在等待`建一棵子树`，而 value 会是子树的头结点。
  if (value === null) {
    // 如果是null，说明父结点等的是空树，所以建一个空结点，返回
    return null;
  }
  // value 不是null, 说明父结点等待一棵非空的子树，建出这棵子树的头结点
  const head = new Node(value);
  // 因为队列是用`头左右`的方式入队建出来的，所以用队列接下来的数据，先建出子树的左子树。
  head.left = reConstruct(queue);
  // 再建出子树的右子树
  head.right = reConstruct(queue);
  // 返回父级等待的子树
  return head;
}
```



## f中序遍历 非递归方式
TODO:
https://leetcode.cn/problems/binary-tree-inorder-traversal/

## f先序遍历 非递归方式
### 流程
准备一个栈，把头结点放进去:
1. 弹出栈顶，记为cur。弹出就打印。
2. cur有右孩子就压入右孩子，cur有左孩子就压入左孩子，一定是`先右再左`。没有的孩子不压入。
3. 继续弹出结点，重复步骤1和步骤2，直到栈清空。
打印顺序就是先序遍历的顺序✅
### 原理
头弹出的时候，先压右再压左。接着`左`弹出的时候，先压了小右再压小左。这时`右`在最底部，也就是被`左`分解的小任务压着。栈是从上面出的，所以`右`得等到所有`左`分解出来的子孙全部执行完，才能到它。
所以，对于任意一个结点，都是先处理自己，再处理整棵左子树，最后处理右子树。实现先序遍历✅
### 代码
```js
function preorderTraversal(head) {
  if (!head) {
    return;
  }
  const stack = [head];
  let cur = null;

  // 重复弹出结点以保存先序遍历结果，直到栈清空。
  while (stack.length > 0) {
    cur = stack.pop();
    console.log(cur);  // 弹出就打印
    // 先压右，再压左
    if (cur.right) {
      stack.push(cur.right)
    }
    if (cur.left) {
      stack.push(cur.left)
    }
  }
}
```
## f后序遍历 非递归方式
### 流程
1. 非递归的先序遍历过程是`头左右`，现在加工出`头右左`(弹出头时，先压左，再压右)，弹出的时候不要打印，全部放入栈2中。
2. 从栈2中弹出结点，顺序就是`左右头`，后序遍历✅
### 代码
```js
// 非递归后序遍历 
var postorderTraversal = function (root) {
  if (!root) {
    return;
  }
  const s1 = [root];
  const s2 = [];
  let cur = null;
  while (s1.length > 0) {
    cur = s1.pop();
    // 弹出的时候不要打印，压入到s2
    s2.push(cur);

    // 先压左再压右
    // 实现`头左右`
    if (cur.left) {
      s1.push(cur.left);
    }
    if (cur.right) {
      s1.push(cur.right);
    }
  }
  // s2依次弹出
  while (s2.length > 0) {
    console.log(s2.pop());
  }
};
```
# JS 的小技巧
1. 把字符串转成数组
   ```js
   const arr = Array.from(str);
   ```
2. 新建一个二维数组 N*M
   ```js
   const matrix = Array(N).fill(0).map(_ => new Uint8Array(M));
   ```


# f暴力递归改动态规划 f动态规划
遇到一道新的题目，就想: 怎么尝试一件事？

f尝试模型🔥
1. 从左往右的尝试模型  (背包问题🎒, 组成货币🪙问题)
2. 范围上的尝试模型  (纸牌博弈问题🃏, 在[L,R]上去尝试)
3. 样本对应模型 (一个样本作行，一个样本作列，比如最长公共子序列)
4. 业务限制模型

## f机器人走路
假设有排成一行的N个位置，记为1~N (N 一定大于或等于 2)，开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)，每次走一步:
  如果机器人来到1位置，那么下一步只能往右来到2位置；
  如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
  如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走 K 步，返回最终能来到P位置(P也是1~N中的一个)的方法有多少种。
### f暴力递归 f写尝试
```js
function robotWalk(N, M, K, P) {
  // 主函数调用递归返回:
  // 机器人在 1~N 的 M位置，还有K步要走，走到 aim 的方法数。
  return proc(M, K, P, N);
}
/**
 * 怎么尝试一件事? 这个递归函数就是一种尝试。
 * 尝试非常符合自然智慧，是很容易想的。
 * 
 * @param {number} cur 机器人当前来到的位置是 cur
 * @param {number} rest 机器人还有 rest 步需要去走 (必须走，不能停在原地) 
 * @param {number} aim  目标位置是 aim
 * @param {number} N  机器人能够走的位置 1~N
 * 
 * @return {number} 机器人从 cur 出发，走 rest 步刚好到 aim 位置的方法数
 */
function proc(cur, rest, aim, N) {
  if (rest === 0) {
    // 还有0步要走，也就是不能走了。
    // 如果机器人🤖️在aim就是一种方法(机器人不动)，如果不在就是0种(无法到达aim)
    return cur === aim ? 1 : 0;
  }
  // 接下来的过程 rest > 0，代表还有步数要走。
  if (cur === 1) {
    // 运动范围是 [1,N]，而机器人在1位置，所以下一步只能往2位置走。
    // 也就是说，从1位置出发到达 aim 的所有方法，必然要先经过2位置，再走出去，所以:
    // ”在 1 位置走 rest 步到达 aim 的方法数“ 等同于 ”在 2 位置走 rest-1 步到达 aim 的方法数"
    return proc(2, rest - 1, aim, N);
  }
  if (cur === N) {
    // 运动范围是 [1,N]，而机器人在N位置，所以下一步只能往N-1位置走。
    // 也就是说，从N位置出发到达 aim 的所有方法，必然要先经过N-1位置，再走出去，所以:
    // ”在 N 位置走 rest 步到达 aim 的方法数“ 等同于 ”在 N-1 位置走 rest-1 步到达 aim 的方法数"
    return proc(N - 1, rest - 1, aim, N);
  }
  // 机器人现在在中间位置上。
  // 机器人可以往左走，也可以往右走，这是两种不同的方法，所以总的方法等于 "从左边出去的方法数" 加上 "从右边出去的方法数"。
  return proc(cur - 1, rest - 1, aim, N) + proc(cur + 1, rest - 1, aim, N);
}
```
### f暴力递归为什么暴力?
递归过程，四个参数中只有`cur`和`rest`一直在变，其他两个是固定的。所以分析递归只关心这两个可变参数即可。

比如: 从`7`位置出发，还要走`10`步到达`aim`的方法数:

                    f(7,10) 
          f(6,9)               f(8,9)
    f(5,8)     f(7,8)     f(7,8)    f(9,8) 

到这一层已经看到，f(7,8) 重复了，下面还会有更多重复的调用，但是暴力递归会把它们都跑完，所以暴力递归暴力。

那么如何避免重复调用的过程？傻缓存法。

### f傻缓存法
TODO: 169

## f纸牌博弈 f博弈 f范围上的尝试模型
给定一个整型数组arr，代表数值不同的纸牌排成一条线, 玩家A和玩家B依次拿走每张纸牌。
  规定:
    1. 玩家A先拿，玩家B后拿
    2. 每个玩家每次只能拿走最左或最右的纸牌
    3. 玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数。
### 代码
```js
/**
 * 给定一个整型数组arr，代表数值不同的纸牌排成一条线, 玩家A和玩家B依次拿走每张纸牌。

  规定:
    1. 玩家A先拿，玩家B后拿
    2. 每个玩家每次只能拿走最左或最右的纸牌
    3. 玩家A和玩家B都绝顶聪明

  请返回最后获胜者的分数。
*/

function win(arr) {
  if (!arr || arr.length === 0) {
    return 0;
  }
  console.log('\n🚀🚀先手起步🚀🚀');
  const first = f(arr, 0, arr.length - 1);
  console.log('\n🚀🚀后手起步🚀🚀');
  const second = g(arr, 0, arr.length - 1);

  console.log('=================🔥结果==================');
  console.log(first > second ? '先手赢了🎉' : '后手赢了🎉');

  return Math.max(first, second);
}

// 返回: 在arr[L..R]上先手, 获得的最好分数
// 🌰例子:
// 传入[100], 先手选走100, 返回100
// 传入[100,3], 先手选走100, 后手选走3, 返回100
// 传入[2,100,6], 先手选走2, 后手选走100, 先手选走6，返回2+6=8
function f(arr, L, R) {
  console.log(arr.slice(L, R + 1) + `先`);
  // 你是先手，现在是你选。

  if (L === R) {
    // 如果只剩一张牌，先手直接拿走
    return arr[L];
  }

  // 不止一张牌

  // 先手的第一种选择:`拿走最左侧的牌`, 最终分数=左牌分数+我在[L+1,R]上后手获得的最好分数 (我在[L+1,R]上后手,意味着现在[L+1,R]上对方先选)
  // 左牌分数+后续分数
  // 把g看成普通的函数，本体只有先手一个人，只是在g里它不能主动，只能被迫接收对方留下的结果。
  const p1 = arr[L] + g(arr, L + 1, R);
  // 先手的第二种选择:`拿走最右侧的牌`, 最终分数=右牌分数+我在[L,R-1]上后手获得的最好分数 (我在[L+1,R]上后手,意味着现在[L+1,R]上对方先选)
  // 右牌分数+后续分数
  const p2 = arr[R] + g(arr, L, R - 1);
  // 选最大的
  return Math.max(p1, p2);
}

// 返回: 在arr[L..R]上后手, 获得的最好分数 (先手留给你一个情况，你被动接受，然后全力以赴去算)
// 🌟得出两个信息:
// 1. 先手先选，那么[L..R]跟你没有关系，先手选完的 [L+1,R]或[L,R-1]才跟你有关系 
// 2. 先手绝顶聪明, 那么你能赢的唯一情况就是: 先手怎么选都输。
// 🌰例子:
// 传入[100], 先手选走100, 后手没有得到数, 返回0
// 传入[100,3], 先手选走100, 后手选走3, 返回3
// 传入[2,100,6], 先手选走2, 后手选走100, 先手选走6，返回100
function g(arr, L, R) {
  console.log(arr.slice(L, R + 1) + `后`);
  // 注意⚠️⚠️ 你是后手，现在不是你选!!

  if (L === R) {
    // 先手选走唯一的一张牌，后手没有得到数，返回0。
    return 0;
  }

  // 不止一张牌
  // 你是后手，现在你不能选。先手可以选，他有两种选择:

  // 1.先手选走 arr[L]，让后手 (就是我) 只能在 [L+1,R] 上`先手`得到最好分数
  // p1 是: 对方挑走了 arr[L]，我在剩下的 [L+1,R] 得到的最优分数
  const p1 = f(arr, L + 1, R);
  // 2.先手选走 arr[R]，让后手 (就是我) 只能在 [L,R-1] 上`先手`得到最好分数
  // p2 是: 对方挑走了 arr[R]，我在剩下的 [L,R-1] 得到的最优分数
  const p2 = f(arr, L, R - 1);

  // 重点来了: 先手绝顶聪明，他会算出: 选哪边使得`你在剩下的范围得到最优分`比较小，给你留一个小的，所以返回两者的 min。
  // 🔥感受到被动了吗？
  return Math.min(p1, p2);

  // 那是不是后手一定输？
  // 不是!!!  如果这两种可能性都大于先手获得的分，后手就赢了!!   
  // 比如: 我在[2,100,6]上后手，先手的两种选择是: `给我留 [2,100]` 或 `给我留[100,6]`，给我留的这两种情况我都能拿到 100, 我作为后手, 赢了。 
  // 也就是说，后手能赢的情况是: 先手选哪边都会输。
}

// [2,100,6] 是天意，先手是诸葛亮，后手是司马懿。诸葛亮绝顶聪明，但是不管怎么选，最终都会输。
win([2, 100, 6]);
```

## f背包问题🎒 f从f左往右的尝试模型
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值。
给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。
返回你能装下的最多价值。
### 代码
```js
function knapsack(weights, values, bag) {
  return dpWays(weights, values, bag);
  return proc(weights, values, 0, bag);
}

// 从左往右的尝试模型，每一个货物`要`或`不要`全展开。

// 在不超过rest重量的情况下，自由选择[index,N-1]的物品, 返回最多能得到的价值。
function proc(weights, values, index, rest) {
  // 剩余载重是负数，说明上游有选择是错的
  // 这个是左神后来加的，由此可见，尝试是非常轻的，上游有特殊情况处理时，下游加一个base case返回去，就能满足。
  if (rest < 0) {
    return -1;  // 本次尝试失败，返回-1给上一级处理。
  }
  // 有剩余载重，但是没有货物📦了，返回价值0。
  if (index === weights.length) {
    return 0;
  }

  // index < weights.length 
  // 还有货物, 面对 index 号货物，我可以选择`要`或`不要`。

  // 尝试1: 要 index 的货物
  let p1 = 0;
  const next = proc(weights, values, index + 1, rest - weights[index]);
  // 如果要了 index 货物，结果超重了，这个尝试就是失败的，价值维持一开始的0
  if (next !== -1) {
    // 如果到最后没有超重，本次选择方案有效，index货物的价值+后续过程的价值和=本次尝试的价值。
    p1 = values[index] + next;
  }
  // 尝试2: 不要 index 的货物
  // 得到 背包剩余载重还是rest的情况下，在[index+1,N-1]上自由选择货物得到的最大价值
  const p2 = proc(weights, values, index + 1, rest);

  // 当前货物只能`选`或`不选`，所以返回 `两种尝试中价值大的那个`。
  return Math.max(p1, p2);
}

// index: 0~weight.length
// rest: 0~bag
function dpWays(weights, values, bag) {
  const N = weights.length + 1;
  const M = bag + 1;
  const dp = Array(N).fill(0).map(_ => new Uint32Array(M));

  //  最后一行全是0，默认就是0，不用填

  // 从倒数第二行开始，从下往上，每行再从左往右填
  for (let i = N - 2; i >= 0; i--) {
    for (let j = 0; j < M; j++) {
      let p1 = 0;
      if (j - weights[i] > -1) {
        p1 = values[i] + dp[i + 1][j - weights[i]];
      }
      const p2 = dp[i + 1][j];
      dp[i][j] = Math.max(p1, p2);
    }
  }
  return dp[0][M - 1];
}
// [2,9,5]  w
// [9,5,8]  v
// 10      bag
console.log(knapsack([2, 9, 5], [9, 5, 8], 10));   // 17
```

## f最长公共子序列 f样本对应模型
给定两个字符串str1和str2，
返回这两个字符串的最长公共子序列长度

比如: str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”
最长公共子序列是“123456”，所以返回长度6
### 代码
```js
function longestCommonSubsequence(str1, str2) {
  if (!str1 || !str2) {
    return 0;
  }
  return dpWays(str1, str2);
  return proc(str1, str2, str1.length - 1, str2.length - 1);
}

// 这是样本对应模型🔥, str1作行，str2作列，非常在意结尾位置, 所以定出尝试:
// 返回: `str1[0,..,i]这一段` 和 `str2[0,..,j]这一段` 两个字符串, 最长公共子序列的长度
function proc(str1, str2, i, j) {
  // 第四步
  // base case 1
  if (i === 0 && j === 0) {
    return str1[i] === str2[j] ? 1 : 0;
  }
  // 第一步  (else 是后面补的)
  // 从右往左尝试的，所以 i 到 0 的时候返回
  else if (i === 0) {
    // 第二步
    // str1只剩一个字符, str2[0,..,j]
    // `样本模型对应结尾`
    if (str1[i] === str2[j]) {
      return 1;
    }
    // 第三步
    // 有 str2[j] 没 str2[j] 都一样, 继续尝试
    // 此时i是0，但是 j-1 可能越界，所以补 base case 1
    return proc(str1, str2, i, j - 1);
  }
  else if (j === 0) {
    // 同 i === 0
    if (str1[i] === str2[j]) {
      return 1;
    }
    return proc(str1, str2, i - 1, j);
  }
  else {
    // 样本对应模型往往讨`结尾位置🔥`，这是一个经验

    // 可能性1
    // 最长公共子序列不以i结尾，有可能以j结尾， 比如"123d"和"1a23"(以j结尾)、"123d"和"123c"(不以j结尾)
    // 为啥要定成`可能以j结尾`?  因为如果定成`一定以j结尾`，就要去验证 str1[0,..,i] 里有没有 str2[j] 字符，这件事就变得很麻烦。
    const p1 = proc(str1, str2, i - 1, j);
    // 可能性2
    // 最长公共子序列有可能以i结尾，不以j结尾， 比如"a123d"和"e123f"(不以i结尾)、"a123"和"e123f"(以i结尾)
    const p2 = proc(str1, str2, i, j - 1);
    // 可能性1和可能性2是有交集的，但是目标是最长的序列，交集又如何？不影响找到答案。
    // 交集是: 不以i结尾，也不以j结尾， 比如"123d"和"a123e"
    // 可能性3
    // 最长公共子序列以i结尾，以j结尾， 比如"a123d"和"e123d"
    const p3 = str1[i] === str2[j] ? (1 + proc(str1, str2, i - 1, j - 1)) : 0;
    // 选最长的
    return Math.max(Math.max(p1, p2), p3);
  }
}

function dpWays(str1, str2) {
  const N = str1.length;
  const M = str2.length;
  const dp = Array(N).fill(0).map(_ => new Uint32Array(M));  // N*M

  dp[0][0] = str1[0] === str2[0] ? 1 : 0;
  // 第一行
  for (let j = 1; j < M; j++) {
    dp[0][j] = str1[0] === str2[j] ? 1 : dp[0][j - 1];
  }
  // 第一列
  for (let i = 1; i < N; i++) {
    dp[i][0] = str1[i] === str2[0] ? 1 : dp[i - 1][0];
  }
  // 普遍位置
  for (let i = 1; i < N; i++) {
    for (let j = 1; j < M; j++) {
      const p1 = dp[i - 1][j];
      const p2 = dp[i][j - 1];
      const p3 = str1[i] === str2[j] ? 1 + dp[i - 1][j - 1] : 0;
      dp[i][j] = Math.max(Math.max(p1, p2), p3);
    }
  }
  // 目标格子
  return dp[N - 1][M - 1];
}
```

## f最长回文子序列 f范围上的尝试模型[L,R]
给定一个字符串str，返回这个字符串的最长回文子序列长度
比如 ： str = “a12b3c43def2ghi1kpm”
最长回文子序列是“1234321”或者“123c321”，返回长度7
### 代码
```js
function lpsl(s) {
  if (!s) {
    return 0;
  }
  return proc(s, 0, s.length - 1);
}

// 返回 str 在 [L,R] 上的最长回文子序列长度
function proc(str, L, R) {
  if (L === R) {
    return 1;
  }
  if (L === R - 1) {
    // 尝试有很多种，这里不处理 L === R-1 的情况，交给上游处理也是可以的
    return str[L] === str[R] ? 2 : 1;
  }

  // 最长回文子序列`以L开头,不以R结尾`, 因为不以R结尾，所以有R没R都一样，等同于在[L,R-1]上尝试。
  const p1 = proc(str, L, R - 1);
  // 最长回文子序列`不以L开头,不以R结尾`  “这里我加了`str[L] === str[R] ? 0 : ...`, 也是对的, 只要能解释得通就对”
  const p2 = proc(str, L + 1, R - 1);  // 下一步有可能 L === R，所以要补这个 base case
  // 最长回文子序列`不以L开头,以R结尾`
  const p3 = proc(str, L + 1, R);
  // 最长回文子序列`以L开头,以R结尾`
  const p4 = str[L] === str[R] ? (2 + proc(str, L + 1, R - 1)) : 0;

  // 只有以上四种可能性，除此之外再无可能，所以返回其中的最大值。
  return Math.max(Math.max(p1, p2), Math.max(p3, p4));
}
```

## f跳马问题
请同学们自行搜索或者想象一个象棋的棋盘，
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
给你三个 参数 x，y，k
返回“马”从(0,0)位置出发，必须走k步
最后落在(x,y)上的方法数有多少种? 

### 代码
```js
/**
  请同学们自行搜索或者想象一个象棋的棋盘，
  然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
  那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
  给你三个 参数 x，y，k
  返回“马”从(0,0)位置出发，必须走k步
  最后落在(x,y)上的方法数有多少种? 
*/
function jump1(k, x, y) {
  return proc(0, 0, k, x, y);
}

function jump2(k, x, y) {
  return dpWays(x, y, k);
}

// 从 (i,j) 出发刚好跳 k 步，到达 (x,y) 的方法数。
function proc(i, j, k, x, y) {
  // 越界方法数是0
  if (i < 0 || i > 8 || j < 0 || j > 9) {
    return 0;
  }

  // 没越界，步数刚好用完
  if (k === 0) {
    // 到达目标点，算一种方法
    // 没到达目标点，由于没有步数了，所以没有方法
    return i === x && j === y ? 1 : 0;
  }

  // 还有步数
  // 普遍位置，每一个点都可以往 8 个方向跳，取 8 个方向的方法数累加，就是自己的方法数
  const p1 = proc(i + 2, j + 1, k - 1, x, y);
  const p2 = proc(i + 2, j - 1, k - 1, x, y);
  const p3 = proc(i + 1, j - 2, k - 1, x, y);
  const p4 = proc(i - 1, j - 2, k - 1, x, y);
  const p5 = proc(i - 2, j - 1, k - 1, x, y);
  const p6 = proc(i - 2, j + 1, k - 1, x, y);
  const p7 = proc(i - 1, j + 2, k - 1, x, y);
  const p8 = proc(i + 1, j + 2, k - 1, x, y);

  // 当前点(i,j) 是父级 8 个点中的一个，现在返回给父级。
  return p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8;
}

function dpWays(x, y, k) {
  // 高维度的在前面，低维度在后面:   层 -> 行 -> 列   (k, i, j)    高k+1, 行9, 列10
  const dp = Array(k + 1).fill(0).map(_ => new Array(9).fill(0).map(_ => new Uint32Array(10)));

  // 先填 base case: 高为0的平面
  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 10; j++) {
      dp[0][i][j] = i === x && j === y ? 1 : 0;
    }
  }

  // 从下往上，每一个平面填好
  for (let h = 1; h < k + 1; h++) {
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 10; j++) {
        const p1 = getValue(dp, h - 1, i + 2, j + 1);
        const p2 = getValue(dp, h - 1, i + 2, j - 1);
        const p3 = getValue(dp, h - 1, i + 1, j - 2);
        const p4 = getValue(dp, h - 1, i - 1, j - 2);
        const p5 = getValue(dp, h - 1, i - 2, j - 1);
        const p6 = getValue(dp, h - 1, i - 2, j + 1);
        const p7 = getValue(dp, h - 1, i - 1, j + 2);
        const p8 = getValue(dp, h - 1, i + 1, j + 2);

        dp[h][i][j] = p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8;
      }
    }
  }

  return dp[k][0][0];
}

// 处理越界的情况
function getValue(dp, k, i, j) {
  if (i < 0 || i > 8 || j < 0 || j > 9) {
    return 0;
  }
  return dp[k][i][j];
}

test('暴力递归', jump1.bind(null, 10, 7, 7));
test('动态规划', jump2.bind(null, 10, 7, 7));

function test(name, cb) {
  console.time(name);
  console.log(cb());  // 515813
  console.timeEnd(name);
}
```


## f货币问题
arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的最少货币数
### 代码
```js
var coinChange = function (coins, amount) {
  return dpWays2(coins, amount);
  return dpWays1(coins, amount);
  const min = proc(coins, 0, amount);
  return min === Number.MAX_SAFE_INTEGER ? -1 : min;
};

// index: 0~coins.length
// rest: 0~amount
function dpWays1(coins, amount) {
  const N = coins.length + 1;
  const M = amount + 1;
  // 因为要存放 Number.MAX_SAFE_INTEGER, Uint32Array 放不下，所以用普通数组。
  const dp = Array(N).fill(0).map(_ => Array(M).fill(0));

  dp[N - 1][0] = 0;

  // rest<0返回系统最大，说明表格左外侧全是系统最大值。
  // 最后一行, 第一个是0, 其余都是系统最大值
  for (let j = 1; j < M; j++) {
    dp[N - 1][j] = Number.MAX_SAFE_INTEGER;
  }

  // 下->上, 左->右
  for (let i = N - 2; i >= 0; i--) {
    for (let j = 0; j < M; j++) {
      let ans = Number.MAX_SAFE_INTEGER;
      for (let zhang = 0; zhang * coins[i] <= j; zhang++) {
        const next = dp[i + 1][j - zhang * coins[i]];
        if (next !== Number.MAX_SAFE_INTEGER) {
          ans = Math.min(ans, zhang + next);
        }
      }
      dp[i][j] = ans;
    }
  }

  return dp[0][M - 1] === Number.MAX_SAFE_INTEGER ? -1 : dp[0][M - 1];
}

// 省去枚举行为的 dp
function dpWays2(coins, amount) {
  const N = coins.length + 1;
  const M = amount + 1;
  const dp = Array(N).fill(0).map(_ => Array(M).fill(0));

  dp[N - 1][0] = 0;

  for (let j = 1; j < M; j++) {
    dp[N - 1][j] = Number.MAX_SAFE_INTEGER;
  }

  /**
   *           8元    11元    14元        rest
   * ...
   * i(3元)           ⬆️      🌟
   * i+1    .. c      b       a
   * ...
   * 
   * index
   * 
   * 原本的尝试中:  🌟 = Min(0+a, 1+b, 2+c, ...)
   * 但是我们发现:  ⬆️ = Min(0+b, 1+c, ...)
   * 所以，可以优化成: 🌟=Min(⬆️+1, 0+a), 省去枚举行为。
   */

  for (let i = N - 2; i >= 0; i--) {
    for (let j = 0; j < M; j++) {
      dp[i][j] = dp[i + 1][j];  // 让🌟等于`a`

      // 让⬆️和`a`PK, 谁小取谁
      if (j - coins[i] >= 0 && dp[i][j - coins[i]] !== Number.MAX_SAFE_INTEGER) {
        // 保证⬆️ `不越界`并且`有效`
        // ⬆️+1和`a`比较，谁小，留谁
        dp[i][j] = Math.min(dp[i][j - coins[i]] + 1, dp[i + 1][j]);
      }
    }
  }

  return dp[0][M - 1] === Number.MAX_SAFE_INTEGER ? -1 : dp[0][M - 1];
}


// arr[index....] 每种面值张数自由选择，搞出刚好rest的钱，返回最少张数。
function proc(arr, index, rest) {

  // // 下面的尝试过程，不会让 rest 小于 0，所以这个 base case 废弃。
  // if (rest < 0) {
  //   // 剩余钱数小于0，返回无效解给上游处理。
  //   return Number.MAX_SAFE_INTEGER;
  // }

  // 剩余钱数 >= 0

  if (index === arr.length) {
    // 没钱了
    // 搞出 0 元钱，需要 0 张货币
    // 搞出 >0 元钱，不能搞出，无效解
    return rest === 0 ? 0 : Number.MAX_SAFE_INTEGER;
  }

  let ans = Number.MAX_SAFE_INTEGER;
  // 从 0 张 index面值开始尝试，[index...]的面值自由选择, 花费的张数记录下来。
  // 然后尝试 (index面值) 1张, 2张, ..., 一直尝试到`不超过 rest 元的张数`，最后，完成 rest 的最少的张数保留下来。
  for (let zhang = 0; zhang * arr[index] <= rest; zhang++) {
    const next = proc(arr, index + 1, rest - zhang * arr[index]);
    // 如果 next 是系统最大值，代表尝试失败(钱超了或到末尾钱不够)，不予理会。
    if (next !== Number.MAX_SAFE_INTEGER) {
      // 记录本次尝试花费的张数: zhang + next;
      // 和之前对 index 的尝试比较，保留最小张数。
      ans = Math.min(ans, zhang + next);
    }
  }

  return ans;
}
```