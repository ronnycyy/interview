/**
 * ç»™å®šä¸€ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹head, è¯·åˆ¤æ–­è¯¥é“¾è¡¨æ˜¯å¦æ˜¯å›æ–‡ç»“æ„
 *
 * 1->2->3->2->1 æ˜¯å›æ–‡
 * 1->2->2->1 æ˜¯å›æ–‡
 * 1->2->2 ä¸æ˜¯å›æ–‡
 * 2->1 ä¸æ˜¯å›æ–‡
 * 1-2->3->3->2->1 æ˜¯å›æ–‡
 * 1->20->3->2->0->1 ä¸æ˜¯å›æ–‡
 * 1->20->3->20->1 æ˜¯å›æ–‡
 *
 * @param {ListNode} head  é“¾è¡¨å¤´ç»“ç‚¹
 * @return {boolean} isPalindrome æ˜¯å¦å›æ–‡
 */
function isPalindromeList(head) {}

// æ–¹æ³•äºŒ (é¢è¯•ï¼Œå’Œé¢è¯•å®˜èŠ)
// 1. æ‰¾åˆ°é“¾è¡¨çš„ä¸­ç‚¹: å¦‚æœæ˜¯å¥‡æ•°è¿”å›`ä¸­ç‚¹`ï¼Œå¦‚æœæ˜¯å¶æ•°è¿”å›`ä¸Šä¸­ç‚¹`ã€‚
// 2. ä»ä¸­ç‚¹å¼€å§‹ï¼Œä¸­ç‚¹æŒ‡å‘ null, å³åŠéƒ¨åˆ†çš„æŒ‡é’ˆå¾€å›æŒ‡ã€‚
// 3. è®¾ç½® L,R æŒ‡é’ˆåˆ†åˆ«æŒ‡å‘å¤´å°¾ï¼Œä¸¤è¾¹åŒæ—¶å¾€ä¸­é—´éå†ç›´åˆ°æœ‰ä¸€ä¸ªåˆ°è¾¾ nullã€‚å¦‚æœæ¯ä¸€æ­¥çš„å€¼éƒ½ä¸€è‡´ï¼Œé‚£å°±æ˜¯å›æ–‡; å¦‚æœæœ‰æŸä¸€æ­¥ä¸ä¸€è‡´ï¼Œé‚£å°±ä¸æ˜¯å›æ–‡ã€‚
// 4. åœ¨è¿”å›ç»“æœä¹‹å‰ï¼ŒæŠŠå³åŠéƒ¨åˆ†çš„æŒ‡å‘è°ƒæ•´å›æ¥ã€‚
// æ—¶é—´å¤æ‚åº¦: O(N)
// ç©ºé—´å¤æ‚åº¦: O(1)  åªç”¨äº†æœ‰é™çš„å‡ ä¸ªå˜é‡ï¼Œæ²¡æœ‰ç”¨å®¹å™¨
function isPalindromeList2(head) {
  if (!head) {
    // https://leetcode.cn/problems/palindrome-linked-list-lcci/
    // è®¤ä¸ºç©ºé“¾è¡¨æ˜¯ true, è¿™ä¸ªçœ‹é¢˜ç›®å°±è¡Œ
    return true;
  }
  let c1 = head;
  let c2 = head;   // æ‰¾ä¸­ç‚¹
  while (c1 && c1.next && c1.next.next) {
    c1 = c1.next.next;
    c2 = c2.next;
  }
  let middle = c2;  // è®°å½•ä¸€ä¸‹ä¸­ç‚¹çš„ä½ç½®
  // å³åŠéƒ¨åˆ†
  c1 = c2.next;
  // ä¸­ç‚¹æŒ‡å‘ null
  c2.next = null;
  // å¾€å›çš„æŒ‡é’ˆ
  let pre = c2;
  // å³åŠéƒ¨åˆ†å¾€å›æŒ‡
  while (c1) {
    // æŠ“ä¸€ä¸‹
    const next = c1.next;
    // å¾€å›æŒ‡
    c1.next = pre;
    // éå†å³åŠéƒ¨åˆ†
    pre = c1;
    c1 = next;
  }
  // å³åŠéƒ¨åˆ†åè½¬å®Œæˆ
  // c1 ä»å°¾å¼€å§‹
  c1 = pre;
  // c2 ä»å¤´å¼€å§‹
  c2 = head;
  let isPalindrome = true;
  // ä¸¤ä¸ªæŒ‡é’ˆå¾€ä¸­é—´èµ°ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªåˆ°è¾¾ null åœ
  while (c1 && c2) {
    if (c1.val !== c2.val) {
      // ä½†å‡¡æœ‰ä¸€ä¸ªä¸ä¸€æ ·ï¼Œå°±ä¸æ˜¯å›æ–‡;
      // æ¯ä¸€ä¸ªéƒ½ä¸€æ ·ï¼Œå›æ–‡
      isPalindrome = false;
      break;
    }
    c1 = c1.next;
    c2 = c2.next;
  }
  // åœ¨è¿”å›ä¹‹å‰ï¼ŒæŠŠå³åŠéƒ¨åˆ†è°ƒæ•´å›æ¥ã€‚
  // ç”¨ c1 å½“ cur
  c1 = pre;
  // pre ä» null å¼€å§‹
  pre = null;
  // åˆ°è¾¾ä¸­ç‚¹ä½ç½®å°±åœ
  while (c1 !== middle) {
    // æŠ“ä¸€ä¸‹
    const next = c1.next;
    // å¾€å›æŒ‡
    c1.next = pre;
    // å¾€ä¸­é—´èµ°
    pre = c1;
    c1 = next;
  }
  // c1 å·²ç»åˆ°è¾¾ middle, c1.next è¿ä¸Šå³åŠéƒ¨åˆ†ï¼Œè¿˜åŸé“¾è¡¨
  c1.next = pre;
  // è¿”å›`æ˜¯å¦æ˜¯å›æ–‡`è¿™ä¸ªç»“æœ
  return isPalindrome;
}

// æ–¹æ³•ä¸€ (ç¬”è¯•)
// 1. å‡†å¤‡ä¸€ä¸ªæ ˆï¼Œéå†é“¾è¡¨ï¼ŒæŠŠç»“ç‚¹æ”¾åˆ°æ ˆé‡Œ
// 2. å†éå†ä¸€éé“¾è¡¨ï¼Œæ¯èµ°ä¸€æ­¥ä»æ ˆé‡Œå¼¹å‡ºä¸€ä¸ªæ¥æ¯”è¾ƒï¼Œå¦‚æœæ¯ä¸€æ­¥éƒ½ä¸€æ ·ï¼Œé‚£å°±æ˜¯å›æ–‡
// åŸç†:
// ç”±äºæ ˆå¼¹å‡ºé¡ºåºæ˜¯é“¾è¡¨çš„é€†åºï¼Œæ‰€ä»¥å¦‚æœé“¾è¡¨æ˜¯å›æ–‡ï¼Œé‚£ä¹ˆå¼¹å‡ºçš„æ¯ä¸€ä¸ªç»“ç‚¹å€¼éƒ½ä¼šå’Œé“¾è¡¨æ­£åºçš„ç»“ç‚¹å€¼ä¸€æ ·ã€‚
// æ–¹æ³•è®º:
// å¦‚æœæ˜¯ç¬”è¯•ï¼Œå°±ç”¨è¿™ä¸ªæ–¹æ³•!! å› ä¸ºè¿™æ ·æ˜¯æœ€å¿«çš„! èµ¶ç´§åˆ°ä¸‹ä¸€é“é¢˜!ğŸ”¥
// æ—¶é—´å¤æ‚åº¦: O(N)
// ç©ºé—´å¤æ‚åº¦: O(N)  ç”¨äº†ä¸€ä¸ª`å’Œé“¾è¡¨åŒç­‰è§„æ¨¡`çš„æ ˆ
function isPalindromeList1(head) {
  if (!head) {
    return true;
  }
  let cur = head;
  const stack = [];
  while (cur) {
    stack.push(cur);
    cur = cur.next;
  }
  cur = head;
  while (cur) {
    const p = stack.pop();
    if (p.val !== cur.val) {
      return false;
    }
    cur = cur.next;
  }
  return true;
}

function main() {
  const ListNode = require('./ListNode');
  const node = new ListNode(1);
  node.next = new ListNode(2);
  node.next.next = new ListNode(3);
  node.next.next.next = new ListNode(2);
  node.next.next.next.next = new ListNode(1);
  console.log(isPalindromeList2(node));
}

main();
