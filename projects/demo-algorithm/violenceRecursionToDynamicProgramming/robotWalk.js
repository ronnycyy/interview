/**
 * 假设有排成一行的N个位置，记为1~N (N 一定大于或等于 2)，开始时机器人在其中的M位置上(M 一定是 1~N 中的一个)，每次走一步:
    如果机器人来到1位置，那么下一步只能往右来到2位置；
    如果机器人来到N位置，那么下一步只能往左来到 N-1 位置；
    如果机器人来到中间位置，那么下一步可以往左走或者往右走；
  规定机器人必须走 K 步，返回最终能来到P位置(P也是1~N中的一个)的方法有多少种。
*/
function robotWalk(N, M, K, P) {
  // 主函数调用递归返回:
  // 机器人在 1~N 的 M位置，还有K步要走，走到 aim 的方法数。
  return proc(M, K, P, N);
}

/**
 * 怎么尝试一件事? 这个递归函数就是一种尝试。
 * 尝试非常符合自然智慧，是很容易想的。
 * 
 * @param {number} cur 机器人当前来到的位置是 cur
 * @param {number} rest 机器人还有 rest 步需要去走 (必须走，不能停在原地) 
 * @param {number} aim  目标位置是 aim
 * @param {number} N  机器人能够走的位置 1~N
 * 
 * @return {number} 机器人从 cur 出发，走 rest 步刚好到 aim 位置的方法数
 */
function proc(cur, rest, aim, N) {
  if (rest === 0) {
    // 还有0步要走，也就是不能走了。
    // 如果机器人🤖️在aim就是一种方法(机器人不动)，如果不在就是0种(无法到达aim)
    return cur === aim ? 1 : 0;
  }
  // 接下来的过程 rest > 0，代表还有步数要走。

  if (cur === 1) {
    // 运动范围是 [1,N]，而机器人在1位置，所以下一步只能往2位置走。
    // 也就是说，从1位置出发到达 aim 的所有方法，必然要先经过2位置，再走出去，所以:
    // ”在 1 位置走 rest 步到达 aim 的方法数“ 等同于 ”在 2 位置走 rest-1 步到达 aim 的方法数"
    return proc(2, rest - 1, aim, N);
  }
  if (cur === N) {
    // 运动范围是 [1,N]，而机器人在N位置，所以下一步只能往N-1位置走。
    // 也就是说，从N位置出发到达 aim 的所有方法，必然要先经过N-1位置，再走出去，所以:
    // ”在 N 位置走 rest 步到达 aim 的方法数“ 等同于 ”在 N-1 位置走 rest-1 步到达 aim 的方法数"
    return proc(N - 1, rest - 1, aim, N);
  }

  // 机器人现在在中间位置上。
  // 机器人可以往左走，也可以往右走，这是两种不同的方法，所以总的方法等于 "从左边出去的方法数" 加上 "从右边出去的方法数"。
  return proc(cur - 1, rest - 1, aim, N) + proc(cur + 1, rest - 1, aim, N);
}


function test() {
  // [1,2,3,4]  N=4(范围)
  // M=2(位置), P=4(目标), K=4(步数)
  // 方法:
  // 1. 2->3->4->3->4
  // 2. 2->3->2->3->4
  // 3. 2->1->2->3->4
  // 一共有3种
  console.log(robotWalk(4, 2, 4, 4));   // 3
}


